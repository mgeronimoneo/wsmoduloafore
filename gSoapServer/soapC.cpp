/* soapC.cpp
   Generated by gSOAP 2.8.15 from wsModuloAfore.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under ONE of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.15 2019-06-26 17:55:53 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_ns2__TipoRetiroParcial:
		return soap_in_ns2__TipoRetiroParcial(soap, NULL, NULL, "ns2:TipoRetiroParcial");
	case SOAP_TYPE_ns2__TipoTrabajador:
		return soap_in_ns2__TipoTrabajador(soap, NULL, NULL, "ns2:TipoTrabajador");
	case SOAP_TYPE_ns2__ClasificacionServicio:
		return soap_in_ns2__ClasificacionServicio(soap, NULL, NULL, "ns2:ClasificacionServicio");
	case SOAP_TYPE_ns2__RespuestaMensualidad:
		return soap_in_ns2__RespuestaMensualidad(soap, NULL, NULL, "ns2:RespuestaMensualidad");
	case SOAP_TYPE_ns2__NumMensualidad:
		return soap_in_ns2__NumMensualidad(soap, NULL, NULL, "ns2:NumMensualidad");
	case SOAP_TYPE_ns2__RespuestaFechaLiquida:
		return soap_in_ns2__RespuestaFechaLiquida(soap, NULL, NULL, "ns2:RespuestaFechaLiquida");
	case SOAP_TYPE_ns2__FechaLiquida:
		return soap_in_ns2__FechaLiquida(soap, NULL, NULL, "ns2:FechaLiquida");
	case SOAP_TYPE_ns2__RespuestaSaldoRecuperar:
		return soap_in_ns2__RespuestaSaldoRecuperar(soap, NULL, NULL, "ns2:RespuestaSaldoRecuperar");
	case SOAP_TYPE_ns2__SaldoRecuperar:
		return soap_in_ns2__SaldoRecuperar(soap, NULL, NULL, "ns2:SaldoRecuperar");
	case SOAP_TYPE_ns2__ParametroCurpNss:
		return soap_in_ns2__ParametroCurpNss(soap, NULL, NULL, "ns2:ParametroCurpNss");
	case SOAP_TYPE_ns2__ParametroAportacionesPost:
		return soap_in_ns2__ParametroAportacionesPost(soap, NULL, NULL, "ns2:ParametroAportacionesPost");
	case SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda:
		return soap_in_ns2__RespuestaConsultaSaldoVivienda(soap, NULL, NULL, "ns2:RespuestaConsultaSaldoVivienda");
	case SOAP_TYPE_ns2__ConsultarSaldoVivienda:
		return soap_in_ns2__ConsultarSaldoVivienda(soap, NULL, NULL, "ns2:ConsultarSaldoVivienda");
	case SOAP_TYPE_ns2__ParamConsultaSaldoVivienda:
		return soap_in_ns2__ParamConsultaSaldoVivienda(soap, NULL, NULL, "ns2:ParamConsultaSaldoVivienda");
	case SOAP_TYPE_ns2__RespuestaCtaSaldoVol:
		return soap_in_ns2__RespuestaCtaSaldoVol(soap, NULL, NULL, "ns2:RespuestaCtaSaldoVol");
	case SOAP_TYPE_ArrayOfDatosCtaSaldoVol:
		return soap_in_ArrayOfDatosCtaSaldoVol(soap, NULL, NULL, "ns2:DatosCtaSaldoVol");
	case SOAP_TYPE_ns2__DatosCtaSaldoVol:
		return soap_in_ns2__DatosCtaSaldoVol(soap, NULL, NULL, "ns2:DatosCtaSaldoVol");
	case SOAP_TYPE_ns2__ParamNssCtaSaldoVol:
		return soap_in_ns2__ParamNssCtaSaldoVol(soap, NULL, NULL, "ns2:ParamNssCtaSaldoVol");
	case SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen:
		return soap_in_ns2__RespuestaSieforeCtaRegimen(soap, NULL, NULL, "ns2:RespuestaSieforeCtaRegimen");
	case SOAP_TYPE_ArrayOfSieforeCtaRegimen:
		return soap_in_ArrayOfSieforeCtaRegimen(soap, NULL, NULL, "ns2:SieforeCtaRegimen");
	case SOAP_TYPE_ns2__SieforeCtaRegimen:
		return soap_in_ns2__SieforeCtaRegimen(soap, NULL, NULL, "ns2:SieforeCtaRegimen");
	case SOAP_TYPE_ns2__ParamNssCtaRegimen:
		return soap_in_ns2__ParamNssCtaRegimen(soap, NULL, NULL, "ns2:ParamNssCtaRegimen");
	case SOAP_TYPE_ns2__RespuestaAportacionesPosteriores:
		return soap_in_ns2__RespuestaAportacionesPosteriores(soap, NULL, NULL, "ns2:RespuestaAportacionesPosteriores");
	case SOAP_TYPE_ns2__AportacionesPosteriores:
		return soap_in_ns2__AportacionesPosteriores(soap, NULL, NULL, "ns2:AportacionesPosteriores");
	case SOAP_TYPE_ns2__ParamAportacionesPosteriores:
		return soap_in_ns2__ParamAportacionesPosteriores(soap, NULL, NULL, "ns2:ParamAportacionesPosteriores");
	case SOAP_TYPE_ns2__RespuestaResolucionTotalIssste:
		return soap_in_ns2__RespuestaResolucionTotalIssste(soap, NULL, NULL, "ns2:RespuestaResolucionTotalIssste");
	case SOAP_TYPE_ns2__ResolucionTotalIssste:
		return soap_in_ns2__ResolucionTotalIssste(soap, NULL, NULL, "ns2:ResolucionTotalIssste");
	case SOAP_TYPE_ns2__ParamResolucionTotalIssste:
		return soap_in_ns2__ParamResolucionTotalIssste(soap, NULL, NULL, "ns2:ParamResolucionTotalIssste");
	case SOAP_TYPE_ns2__RespuestaMovimientosCuentas:
		return soap_in_ns2__RespuestaMovimientosCuentas(soap, NULL, NULL, "ns2:RespuestaMovimientosCuentas");
	case SOAP_TYPE_ns2__MovimientosCuentas:
		return soap_in_ns2__MovimientosCuentas(soap, NULL, NULL, "ns2:MovimientosCuentas");
	case SOAP_TYPE_ns2__ParamMovimientosCuentas:
		return soap_in_ns2__ParamMovimientosCuentas(soap, NULL, NULL, "ns2:ParamMovimientosCuentas");
	case SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss:
		return soap_in_ns2__RespuestaCOperacionesPmgImss(soap, NULL, NULL, "ns2:RespuestaCOperacionesPmgImss");
	case SOAP_TYPE_ns2__ResolucionOperacionPmg:
		return soap_in_ns2__ResolucionOperacionPmg(soap, NULL, NULL, "ns2:ResolucionOperacionPmg");
	case SOAP_TYPE_ns2__ParamOperacionPmgImss:
		return soap_in_ns2__ParamOperacionPmgImss(soap, NULL, NULL, "ns2:ParamOperacionPmgImss");
	case SOAP_TYPE_ns2__RespuestaResolucionTotalImss:
		return soap_in_ns2__RespuestaResolucionTotalImss(soap, NULL, NULL, "ns2:RespuestaResolucionTotalImss");
	case SOAP_TYPE_ns2__ResolucionTotalImss:
		return soap_in_ns2__ResolucionTotalImss(soap, NULL, NULL, "ns2:ResolucionTotalImss");
	case SOAP_TYPE_ns2__ParamResolucionTotalImssRI:
		return soap_in_ns2__ParamResolucionTotalImssRI(soap, NULL, NULL, "ns2:ParamResolucionTotalImssRI");
	case SOAP_TYPE_ns2__ParamResolucionTotalImss:
		return soap_in_ns2__ParamResolucionTotalImss(soap, NULL, NULL, "ns2:ParamResolucionTotalImss");
	case SOAP_TYPE_ns2__RespuestaComplementoResolucion:
		return soap_in_ns2__RespuestaComplementoResolucion(soap, NULL, NULL, "ns2:RespuestaComplementoResolucion");
	case SOAP_TYPE_ns2__ComplementoResolucion:
		return soap_in_ns2__ComplementoResolucion(soap, NULL, NULL, "ns2:ComplementoResolucion");
	case SOAP_TYPE_ns2__RespuestaDatosResolucion:
		return soap_in_ns2__RespuestaDatosResolucion(soap, NULL, NULL, "ns2:RespuestaDatosResolucion");
	case SOAP_TYPE_ns2__DatosResolucion:
		return soap_in_ns2__DatosResolucion(soap, NULL, NULL, "ns2:DatosResolucion");
	case SOAP_TYPE_ns2__RespuestaMontosFechasDatamart:
		return soap_in_ns2__RespuestaMontosFechasDatamart(soap, NULL, NULL, "ns2:RespuestaMontosFechasDatamart");
	case SOAP_TYPE_ns2__MontosFechasDatamart:
		return soap_in_ns2__MontosFechasDatamart(soap, NULL, NULL, "ns2:MontosFechasDatamart");
	case SOAP_TYPE_ns2__RespuestaValidarResolucionImss:
		return soap_in_ns2__RespuestaValidarResolucionImss(soap, NULL, NULL, "ns2:RespuestaValidarResolucionImss");
	case SOAP_TYPE_ns2__ValidarResolucionImss:
		return soap_in_ns2__ValidarResolucionImss(soap, NULL, NULL, "ns2:ValidarResolucionImss");
	case SOAP_TYPE_ns2__SaldoDiarioRetiroParcial:
		return soap_in_ns2__SaldoDiarioRetiroParcial(soap, NULL, NULL, "ns2:SaldoDiarioRetiroParcial");
	case SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial:
		return soap_in_ns2__ConsultaSaldoDiarioRetiroParcial(soap, NULL, NULL, "ns2:ConsultaSaldoDiarioRetiroParcial");
	case SOAP_TYPE_ns2__RespuestaTipoSolicitante:
		return soap_in_ns2__RespuestaTipoSolicitante(soap, NULL, NULL, "ns2:RespuestaTipoSolicitante");
	case SOAP_TYPE_ns2__TipoSolicitante:
		return soap_in_ns2__TipoSolicitante(soap, NULL, NULL, "ns2:TipoSolicitante");
	case SOAP_TYPE_ns2__RespuestaConvivenciaMarca:
		return soap_in_ns2__RespuestaConvivenciaMarca(soap, NULL, NULL, "ns2:RespuestaConvivenciaMarca");
	case SOAP_TYPE_ns2__ValidaConvivenciaMarcas:
		return soap_in_ns2__ValidaConvivenciaMarcas(soap, NULL, NULL, "ns2:ValidaConvivenciaMarcas");
	case SOAP_TYPE_ns2__ConvivenciaMarcas:
		return soap_in_ns2__ConvivenciaMarcas(soap, NULL, NULL, "ns2:ConvivenciaMarcas");
	case SOAP_TYPE_ns2__FolioServicio:
		return soap_in_ns2__FolioServicio(soap, NULL, NULL, "ns2:FolioServicio");
	case SOAP_TYPE_ns2__FoliadorServicio:
		return soap_in_ns2__FoliadorServicio(soap, NULL, NULL, "ns2:FoliadorServicio");
	case SOAP_TYPE_ns2__SaldoPorSubcuentaPmg:
		return soap_in_ns2__SaldoPorSubcuentaPmg(soap, NULL, NULL, "ns2:SaldoPorSubcuentaPmg");
	case SOAP_TYPE_ns2__SaldosCuentasPmg:
		return soap_in_ns2__SaldosCuentasPmg(soap, NULL, NULL, "ns2:SaldosCuentasPmg");
	case SOAP_TYPE_ns2__SaldoPorSubcuenta:
		return soap_in_ns2__SaldoPorSubcuenta(soap, NULL, NULL, "ns2:SaldoPorSubcuenta");
	case SOAP_TYPE_ArrayOfSaldoSubCuenta:
		return soap_in_ArrayOfSaldoSubCuenta(soap, NULL, NULL, "ns2:SaldoSubCuenta");
	case SOAP_TYPE_ns2__SaldoSubCuenta:
		return soap_in_ns2__SaldoSubCuenta(soap, NULL, NULL, "ns2:SaldoSubCuenta");
	case SOAP_TYPE_ns2__RespConsultarAfiliado:
		return soap_in_ns2__RespConsultarAfiliado(soap, NULL, NULL, "ns2:RespConsultarAfiliado");
	case SOAP_TYPE_ns2__Afiliado:
		return soap_in_ns2__Afiliado(soap, NULL, NULL, "ns2:Afiliado");
	case SOAP_TYPE_ns2__ParametroNssTipoRetiro:
		return soap_in_ns2__ParametroNssTipoRetiro(soap, NULL, NULL, "ns2:ParametroNssTipoRetiro");
	case SOAP_TYPE_ns2__ParametroSaldoPmg:
		return soap_in_ns2__ParametroSaldoPmg(soap, NULL, NULL, "ns2:ParametroSaldoPmg");
	case SOAP_TYPE_ns2__ParametroNss:
		return soap_in_ns2__ParametroNss(soap, NULL, NULL, "ns2:ParametroNss");
	case SOAP_TYPE_ns2__ParamConsultarAfiliado:
		return soap_in_ns2__ParamConsultarAfiliado(soap, NULL, NULL, "ns2:ParamConsultarAfiliado");
	case SOAP_TYPE_ns2__EstadoProceso:
		return soap_in_ns2__EstadoProceso(soap, NULL, NULL, "ns2:EstadoProceso");
	case SOAP_TYPE_ns2__consultarSaldosPenMinGar:
		return soap_in_ns2__consultarSaldosPenMinGar(soap, NULL, NULL, "ns2:consultarSaldosPenMinGar");
	case SOAP_TYPE_ns2__consultarSaldosPenMinGarResponse:
		return soap_in_ns2__consultarSaldosPenMinGarResponse(soap, NULL, NULL, "ns2:consultarSaldosPenMinGarResponse");
	case SOAP_TYPE_ns2__CConsultarNumMensualidad:
		return soap_in_ns2__CConsultarNumMensualidad(soap, NULL, NULL, "ns2:CConsultarNumMensualidad");
	case SOAP_TYPE_ns2__CConsultarNumMensualidadResponse:
		return soap_in_ns2__CConsultarNumMensualidadResponse(soap, NULL, NULL, "ns2:CConsultarNumMensualidadResponse");
	case SOAP_TYPE_ns2__CConsultarFechaLiquida:
		return soap_in_ns2__CConsultarFechaLiquida(soap, NULL, NULL, "ns2:CConsultarFechaLiquida");
	case SOAP_TYPE_ns2__CConsultarFechaLiquidaResponse:
		return soap_in_ns2__CConsultarFechaLiquidaResponse(soap, NULL, NULL, "ns2:CConsultarFechaLiquidaResponse");
	case SOAP_TYPE_ns2__CConsultarSaldoRecuperar:
		return soap_in_ns2__CConsultarSaldoRecuperar(soap, NULL, NULL, "ns2:CConsultarSaldoRecuperar");
	case SOAP_TYPE_ns2__CConsultarSaldoRecuperarResponse:
		return soap_in_ns2__CConsultarSaldoRecuperarResponse(soap, NULL, NULL, "ns2:CConsultarSaldoRecuperarResponse");
	case SOAP_TYPE_ns2__CConsultarResolusionRetAportaciones:
		return soap_in_ns2__CConsultarResolusionRetAportaciones(soap, NULL, NULL, "ns2:CConsultarResolusionRetAportaciones");
	case SOAP_TYPE_ns2__CConsultarResolusionRetAportacionesResponse:
		return soap_in_ns2__CConsultarResolusionRetAportacionesResponse(soap, NULL, NULL, "ns2:CConsultarResolusionRetAportacionesResponse");
	case SOAP_TYPE_ns2__ConsultaAportacionesPosteriores:
		return soap_in_ns2__ConsultaAportacionesPosteriores(soap, NULL, NULL, "ns2:ConsultaAportacionesPosteriores");
	case SOAP_TYPE_ns2__ConsultaAportacionesPosterioresResponse:
		return soap_in_ns2__ConsultaAportacionesPosterioresResponse(soap, NULL, NULL, "ns2:ConsultaAportacionesPosterioresResponse");
	case SOAP_TYPE_ns2__ConsultaSaldoVivienda:
		return soap_in_ns2__ConsultaSaldoVivienda(soap, NULL, NULL, "ns2:ConsultaSaldoVivienda");
	case SOAP_TYPE_ns2__ConsultaSaldoViviendaResponse:
		return soap_in_ns2__ConsultaSaldoViviendaResponse(soap, NULL, NULL, "ns2:ConsultaSaldoViviendaResponse");
	case SOAP_TYPE_ns2__ConsultarSaldoVol:
		return soap_in_ns2__ConsultarSaldoVol(soap, NULL, NULL, "ns2:ConsultarSaldoVol");
	case SOAP_TYPE_ns2__ConsultarSaldoVolResponse:
		return soap_in_ns2__ConsultarSaldoVolResponse(soap, NULL, NULL, "ns2:ConsultarSaldoVolResponse");
	case SOAP_TYPE_ns2__ConsultarSieforeCtaRegimen:
		return soap_in_ns2__ConsultarSieforeCtaRegimen(soap, NULL, NULL, "ns2:ConsultarSieforeCtaRegimen");
	case SOAP_TYPE_ns2__ConsultarSieforeCtaRegimenResponse:
		return soap_in_ns2__ConsultarSieforeCtaRegimenResponse(soap, NULL, NULL, "ns2:ConsultarSieforeCtaRegimenResponse");
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssRI:
		return soap_in_ns2__ConsultarResolucionTotalImssRI(soap, NULL, NULL, "ns2:ConsultarResolucionTotalImssRI");
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssRIResponse:
		return soap_in_ns2__ConsultarResolucionTotalImssRIResponse(soap, NULL, NULL, "ns2:ConsultarResolucionTotalImssRIResponse");
	case SOAP_TYPE_ns2__consultarAportaciones:
		return soap_in_ns2__consultarAportaciones(soap, NULL, NULL, "ns2:consultarAportaciones");
	case SOAP_TYPE_ns2__consultarAportacionesResponse:
		return soap_in_ns2__consultarAportacionesResponse(soap, NULL, NULL, "ns2:consultarAportacionesResponse");
	case SOAP_TYPE_ns2__consultarSaldosPmg:
		return soap_in_ns2__consultarSaldosPmg(soap, NULL, NULL, "ns2:consultarSaldosPmg");
	case SOAP_TYPE_ns2__consultarSaldosPmgResponse:
		return soap_in_ns2__consultarSaldosPmgResponse(soap, NULL, NULL, "ns2:consultarSaldosPmgResponse");
	case SOAP_TYPE_ns2__ConsultarResolucionTotalIssste:
		return soap_in_ns2__ConsultarResolucionTotalIssste(soap, NULL, NULL, "ns2:ConsultarResolucionTotalIssste");
	case SOAP_TYPE_ns2__ConsultarResolucionTotalIsssteResponse:
		return soap_in_ns2__ConsultarResolucionTotalIsssteResponse(soap, NULL, NULL, "ns2:ConsultarResolucionTotalIsssteResponse");
	case SOAP_TYPE_ns2__movimientosCuentas:
		return soap_in_ns2__movimientosCuentas(soap, NULL, NULL, "ns2:movimientosCuentas");
	case SOAP_TYPE_ns2__movimientosCuentasResponse:
		return soap_in_ns2__movimientosCuentasResponse(soap, NULL, NULL, "ns2:movimientosCuentasResponse");
	case SOAP_TYPE_ns2__COperacionesPmg:
		return soap_in_ns2__COperacionesPmg(soap, NULL, NULL, "ns2:COperacionesPmg");
	case SOAP_TYPE_ns2__COperacionesPmgResponse:
		return soap_in_ns2__COperacionesPmgResponse(soap, NULL, NULL, "ns2:COperacionesPmgResponse");
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImss:
		return soap_in_ns2__ConsultarResolucionTotalImss(soap, NULL, NULL, "ns2:ConsultarResolucionTotalImss");
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssResponse:
		return soap_in_ns2__ConsultarResolucionTotalImssResponse(soap, NULL, NULL, "ns2:ConsultarResolucionTotalImssResponse");
	case SOAP_TYPE_ns2__ConsultarComplementoResolucion:
		return soap_in_ns2__ConsultarComplementoResolucion(soap, NULL, NULL, "ns2:ConsultarComplementoResolucion");
	case SOAP_TYPE_ns2__ConsultarComplementoResolucionResponse:
		return soap_in_ns2__ConsultarComplementoResolucionResponse(soap, NULL, NULL, "ns2:ConsultarComplementoResolucionResponse");
	case SOAP_TYPE_ns2__consultarResolucion:
		return soap_in_ns2__consultarResolucion(soap, NULL, NULL, "ns2:consultarResolucion");
	case SOAP_TYPE_ns2__consultarResolucionResponse:
		return soap_in_ns2__consultarResolucionResponse(soap, NULL, NULL, "ns2:consultarResolucionResponse");
	case SOAP_TYPE_ns2__MontosFechasDatamart_:
		return soap_in_ns2__MontosFechasDatamart_(soap, NULL, NULL, "ns2:MontosFechasDatamart");
	case SOAP_TYPE_ns2__MontosFechasDatamartResponse:
		return soap_in_ns2__MontosFechasDatamartResponse(soap, NULL, NULL, "ns2:MontosFechasDatamartResponse");
	case SOAP_TYPE_ns2__ValidarResolucionImss_:
		return soap_in_ns2__ValidarResolucionImss_(soap, NULL, NULL, "ns2:ValidarResolucionImss");
	case SOAP_TYPE_ns2__ValidarResolucionImssResponse:
		return soap_in_ns2__ValidarResolucionImssResponse(soap, NULL, NULL, "ns2:ValidarResolucionImssResponse");
	case SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcial:
		return soap_in_ns2__ObtenerSaldoDiarioRetiroParcial(soap, NULL, NULL, "ns2:ObtenerSaldoDiarioRetiroParcial");
	case SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcialResponse:
		return soap_in_ns2__ObtenerSaldoDiarioRetiroParcialResponse(soap, NULL, NULL, "ns2:ObtenerSaldoDiarioRetiroParcialResponse");
	case SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativa:
		return soap_in_ns2__ValidarConvivenciaMarcaOperativa(soap, NULL, NULL, "ns2:ValidarConvivenciaMarcaOperativa");
	case SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativaResponse:
		return soap_in_ns2__ValidarConvivenciaMarcaOperativaResponse(soap, NULL, NULL, "ns2:ValidarConvivenciaMarcaOperativaResponse");
	case SOAP_TYPE_ns2__ObtenerFolioServicio:
		return soap_in_ns2__ObtenerFolioServicio(soap, NULL, NULL, "ns2:ObtenerFolioServicio");
	case SOAP_TYPE_ns2__ObtenerFolioServicioResponse:
		return soap_in_ns2__ObtenerFolioServicioResponse(soap, NULL, NULL, "ns2:ObtenerFolioServicioResponse");
	case SOAP_TYPE_ns2__consultarSaldos:
		return soap_in_ns2__consultarSaldos(soap, NULL, NULL, "ns2:consultarSaldos");
	case SOAP_TYPE_ns2__consultarSaldosResponse:
		return soap_in_ns2__consultarSaldosResponse(soap, NULL, NULL, "ns2:consultarSaldosResponse");
	case SOAP_TYPE_ns2__consultarAfiliado:
		return soap_in_ns2__consultarAfiliado(soap, NULL, NULL, "ns2:consultarAfiliado");
	case SOAP_TYPE_ns2__consultarAfiliadoResponse:
		return soap_in_ns2__consultarAfiliadoResponse(soap, NULL, NULL, "ns2:consultarAfiliadoResponse");
	case SOAP_TYPE_PointerTons2__RespuestaMensualidad:
		return soap_in_PointerTons2__RespuestaMensualidad(soap, NULL, NULL, "ns2:RespuestaMensualidad");
	case SOAP_TYPE_PointerTons2__RespuestaFechaLiquida:
		return soap_in_PointerTons2__RespuestaFechaLiquida(soap, NULL, NULL, "ns2:RespuestaFechaLiquida");
	case SOAP_TYPE_PointerTons2__RespuestaSaldoRecuperar:
		return soap_in_PointerTons2__RespuestaSaldoRecuperar(soap, NULL, NULL, "ns2:RespuestaSaldoRecuperar");
	case SOAP_TYPE_PointerTons2__ParametroCurpNss:
		return soap_in_PointerTons2__ParametroCurpNss(soap, NULL, NULL, "ns2:ParametroCurpNss");
	case SOAP_TYPE_PointerTons2__RespuestaTipoSolicitante:
		return soap_in_PointerTons2__RespuestaTipoSolicitante(soap, NULL, NULL, "ns2:RespuestaTipoSolicitante");
	case SOAP_TYPE_PointerTons2__ParametroAportacionesPost:
		return soap_in_PointerTons2__ParametroAportacionesPost(soap, NULL, NULL, "ns2:ParametroAportacionesPost");
	case SOAP_TYPE_PointerTons2__ParamConsultaSaldoVivienda:
		return soap_in_PointerTons2__ParamConsultaSaldoVivienda(soap, NULL, NULL, "ns2:ParamConsultaSaldoVivienda");
	case SOAP_TYPE_PointerTons2__RespuestaConsultaSaldoVivienda:
		return soap_in_PointerTons2__RespuestaConsultaSaldoVivienda(soap, NULL, NULL, "ns2:RespuestaConsultaSaldoVivienda");
	case SOAP_TYPE_PointerTons2__RespuestaCtaSaldoVol:
		return soap_in_PointerTons2__RespuestaCtaSaldoVol(soap, NULL, NULL, "ns2:RespuestaCtaSaldoVol");
	case SOAP_TYPE_PointerTons2__ParamNssCtaRegimen:
		return soap_in_PointerTons2__ParamNssCtaRegimen(soap, NULL, NULL, "ns2:ParamNssCtaRegimen");
	case SOAP_TYPE_PointerTons2__RespuestaSieforeCtaRegimen:
		return soap_in_PointerTons2__RespuestaSieforeCtaRegimen(soap, NULL, NULL, "ns2:RespuestaSieforeCtaRegimen");
	case SOAP_TYPE_PointerTons2__ParamResolucionTotalImssRI:
		return soap_in_PointerTons2__ParamResolucionTotalImssRI(soap, NULL, NULL, "ns2:ParamResolucionTotalImssRI");
	case SOAP_TYPE_PointerTons2__ParamAportacionesPosteriores:
		return soap_in_PointerTons2__ParamAportacionesPosteriores(soap, NULL, NULL, "ns2:ParamAportacionesPosteriores");
	case SOAP_TYPE_PointerTons2__RespuestaAportacionesPosteriores:
		return soap_in_PointerTons2__RespuestaAportacionesPosteriores(soap, NULL, NULL, "ns2:RespuestaAportacionesPosteriores");
	case SOAP_TYPE_PointerTons2__ParametroSaldoPmg:
		return soap_in_PointerTons2__ParametroSaldoPmg(soap, NULL, NULL, "ns2:ParametroSaldoPmg");
	case SOAP_TYPE_PointerTons2__SaldoPorSubcuentaPmg:
		return soap_in_PointerTons2__SaldoPorSubcuentaPmg(soap, NULL, NULL, "ns2:SaldoPorSubcuentaPmg");
	case SOAP_TYPE_PointerTons2__ParamResolucionTotalIssste:
		return soap_in_PointerTons2__ParamResolucionTotalIssste(soap, NULL, NULL, "ns2:ParamResolucionTotalIssste");
	case SOAP_TYPE_PointerTons2__RespuestaResolucionTotalIssste:
		return soap_in_PointerTons2__RespuestaResolucionTotalIssste(soap, NULL, NULL, "ns2:RespuestaResolucionTotalIssste");
	case SOAP_TYPE_PointerTons2__ParamMovimientosCuentas:
		return soap_in_PointerTons2__ParamMovimientosCuentas(soap, NULL, NULL, "ns2:ParamMovimientosCuentas");
	case SOAP_TYPE_PointerTons2__RespuestaMovimientosCuentas:
		return soap_in_PointerTons2__RespuestaMovimientosCuentas(soap, NULL, NULL, "ns2:RespuestaMovimientosCuentas");
	case SOAP_TYPE_PointerTons2__ParamOperacionPmgImss:
		return soap_in_PointerTons2__ParamOperacionPmgImss(soap, NULL, NULL, "ns2:ParamOperacionPmgImss");
	case SOAP_TYPE_PointerTons2__RespuestaCOperacionesPmgImss:
		return soap_in_PointerTons2__RespuestaCOperacionesPmgImss(soap, NULL, NULL, "ns2:RespuestaCOperacionesPmgImss");
	case SOAP_TYPE_PointerTons2__ParamResolucionTotalImss:
		return soap_in_PointerTons2__ParamResolucionTotalImss(soap, NULL, NULL, "ns2:ParamResolucionTotalImss");
	case SOAP_TYPE_PointerTons2__RespuestaResolucionTotalImss:
		return soap_in_PointerTons2__RespuestaResolucionTotalImss(soap, NULL, NULL, "ns2:RespuestaResolucionTotalImss");
	case SOAP_TYPE_PointerTons2__RespuestaComplementoResolucion:
		return soap_in_PointerTons2__RespuestaComplementoResolucion(soap, NULL, NULL, "ns2:RespuestaComplementoResolucion");
	case SOAP_TYPE_PointerTons2__RespuestaDatosResolucion:
		return soap_in_PointerTons2__RespuestaDatosResolucion(soap, NULL, NULL, "ns2:RespuestaDatosResolucion");
	case SOAP_TYPE_PointerTons2__RespuestaMontosFechasDatamart:
		return soap_in_PointerTons2__RespuestaMontosFechasDatamart(soap, NULL, NULL, "ns2:RespuestaMontosFechasDatamart");
	case SOAP_TYPE_PointerTons2__ParametroNssTipoRetiro:
		return soap_in_PointerTons2__ParametroNssTipoRetiro(soap, NULL, NULL, "ns2:ParametroNssTipoRetiro");
	case SOAP_TYPE_PointerTons2__RespuestaValidarResolucionImss:
		return soap_in_PointerTons2__RespuestaValidarResolucionImss(soap, NULL, NULL, "ns2:RespuestaValidarResolucionImss");
	case SOAP_TYPE_PointerTons2__ConsultaSaldoDiarioRetiroParcial:
		return soap_in_PointerTons2__ConsultaSaldoDiarioRetiroParcial(soap, NULL, NULL, "ns2:ConsultaSaldoDiarioRetiroParcial");
	case SOAP_TYPE_PointerTons2__SaldoDiarioRetiroParcial:
		return soap_in_PointerTons2__SaldoDiarioRetiroParcial(soap, NULL, NULL, "ns2:SaldoDiarioRetiroParcial");
	case SOAP_TYPE_PointerTons2__ConvivenciaMarcas:
		return soap_in_PointerTons2__ConvivenciaMarcas(soap, NULL, NULL, "ns2:ConvivenciaMarcas");
	case SOAP_TYPE_PointerTons2__RespuestaConvivenciaMarca:
		return soap_in_PointerTons2__RespuestaConvivenciaMarca(soap, NULL, NULL, "ns2:RespuestaConvivenciaMarca");
	case SOAP_TYPE_PointerTons2__FoliadorServicio:
		return soap_in_PointerTons2__FoliadorServicio(soap, NULL, NULL, "ns2:FoliadorServicio");
	case SOAP_TYPE_PointerTons2__FolioServicio:
		return soap_in_PointerTons2__FolioServicio(soap, NULL, NULL, "ns2:FolioServicio");
	case SOAP_TYPE_PointerTons2__ParametroNss:
		return soap_in_PointerTons2__ParametroNss(soap, NULL, NULL, "ns2:ParametroNss");
	case SOAP_TYPE_PointerTons2__SaldoPorSubcuenta:
		return soap_in_PointerTons2__SaldoPorSubcuenta(soap, NULL, NULL, "ns2:SaldoPorSubcuenta");
	case SOAP_TYPE_PointerTons2__ParamConsultarAfiliado:
		return soap_in_PointerTons2__ParamConsultarAfiliado(soap, NULL, NULL, "ns2:ParamConsultarAfiliado");
	case SOAP_TYPE_PointerTons2__RespConsultarAfiliado:
		return soap_in_PointerTons2__RespConsultarAfiliado(soap, NULL, NULL, "ns2:RespConsultarAfiliado");
	case SOAP_TYPE_PointerToPointerTons2__DatosCtaSaldoVol:
		return soap_in_PointerToPointerTons2__DatosCtaSaldoVol(soap, NULL, NULL, "ns2:DatosCtaSaldoVol");
	case SOAP_TYPE_PointerTons2__DatosCtaSaldoVol:
		return soap_in_PointerTons2__DatosCtaSaldoVol(soap, NULL, NULL, "ns2:DatosCtaSaldoVol");
	case SOAP_TYPE_PointerToPointerTons2__SieforeCtaRegimen:
		return soap_in_PointerToPointerTons2__SieforeCtaRegimen(soap, NULL, NULL, "ns2:SieforeCtaRegimen");
	case SOAP_TYPE_PointerTons2__SieforeCtaRegimen:
		return soap_in_PointerTons2__SieforeCtaRegimen(soap, NULL, NULL, "ns2:SieforeCtaRegimen");
	case SOAP_TYPE_PointerToPointerTons2__SaldoSubCuenta:
		return soap_in_PointerToPointerTons2__SaldoSubCuenta(soap, NULL, NULL, "ns2:SaldoSubCuenta");
	case SOAP_TYPE_PointerTons2__SaldoSubCuenta:
		return soap_in_PointerTons2__SaldoSubCuenta(soap, NULL, NULL, "ns2:SaldoSubCuenta");
	case SOAP_TYPE_PointerTons2__NumMensualidad:
		return soap_in_PointerTons2__NumMensualidad(soap, NULL, NULL, "ns2:NumMensualidad");
	case SOAP_TYPE_PointerTons2__FechaLiquida:
		return soap_in_PointerTons2__FechaLiquida(soap, NULL, NULL, "ns2:FechaLiquida");
	case SOAP_TYPE_PointerTons2__SaldoRecuperar:
		return soap_in_PointerTons2__SaldoRecuperar(soap, NULL, NULL, "ns2:SaldoRecuperar");
	case SOAP_TYPE_PointerTons2__ConsultarSaldoVivienda:
		return soap_in_PointerTons2__ConsultarSaldoVivienda(soap, NULL, NULL, "ns2:ConsultarSaldoVivienda");
	case SOAP_TYPE_PointerToArrayOfDatosCtaSaldoVol:
		return soap_in_PointerToArrayOfDatosCtaSaldoVol(soap, NULL, NULL, "ns2:DatosCtaSaldoVol");
	case SOAP_TYPE_PointerToArrayOfSieforeCtaRegimen:
		return soap_in_PointerToArrayOfSieforeCtaRegimen(soap, NULL, NULL, "ns2:SieforeCtaRegimen");
	case SOAP_TYPE_PointerTons2__AportacionesPosteriores:
		return soap_in_PointerTons2__AportacionesPosteriores(soap, NULL, NULL, "ns2:AportacionesPosteriores");
	case SOAP_TYPE_PointerTons2__ResolucionTotalIssste:
		return soap_in_PointerTons2__ResolucionTotalIssste(soap, NULL, NULL, "ns2:ResolucionTotalIssste");
	case SOAP_TYPE_PointerTons2__MovimientosCuentas:
		return soap_in_PointerTons2__MovimientosCuentas(soap, NULL, NULL, "ns2:MovimientosCuentas");
	case SOAP_TYPE_PointerTons2__ResolucionOperacionPmg:
		return soap_in_PointerTons2__ResolucionOperacionPmg(soap, NULL, NULL, "ns2:ResolucionOperacionPmg");
	case SOAP_TYPE_PointerTons2__ResolucionTotalImss:
		return soap_in_PointerTons2__ResolucionTotalImss(soap, NULL, NULL, "ns2:ResolucionTotalImss");
	case SOAP_TYPE_PointerTons2__ComplementoResolucion:
		return soap_in_PointerTons2__ComplementoResolucion(soap, NULL, NULL, "ns2:ComplementoResolucion");
	case SOAP_TYPE_PointerTons2__DatosResolucion:
		return soap_in_PointerTons2__DatosResolucion(soap, NULL, NULL, "ns2:DatosResolucion");
	case SOAP_TYPE_PointerTons2__MontosFechasDatamart:
		return soap_in_PointerTons2__MontosFechasDatamart(soap, NULL, NULL, "ns2:MontosFechasDatamart");
	case SOAP_TYPE_PointerTons2__ValidarResolucionImss:
		return soap_in_PointerTons2__ValidarResolucionImss(soap, NULL, NULL, "ns2:ValidarResolucionImss");
	case SOAP_TYPE_PointerTons2__TipoSolicitante:
		return soap_in_PointerTons2__TipoSolicitante(soap, NULL, NULL, "ns2:TipoSolicitante");
	case SOAP_TYPE_PointerTons2__ValidaConvivenciaMarcas:
		return soap_in_PointerTons2__ValidaConvivenciaMarcas(soap, NULL, NULL, "ns2:ValidaConvivenciaMarcas");
	case SOAP_TYPE_PointerTons2__SaldosCuentasPmg:
		return soap_in_PointerTons2__SaldosCuentasPmg(soap, NULL, NULL, "ns2:SaldosCuentasPmg");
	case SOAP_TYPE_PointerToArrayOfSaldoSubCuenta:
		return soap_in_PointerToArrayOfSaldoSubCuenta(soap, NULL, NULL, "ns2:SaldoSubCuenta");
	case SOAP_TYPE_PointerTons2__EstadoProceso:
		return soap_in_PointerTons2__EstadoProceso(soap, NULL, NULL, "ns2:EstadoProceso");
	case SOAP_TYPE_PointerTons2__Afiliado:
		return soap_in_PointerTons2__Afiliado(soap, NULL, NULL, "ns2:Afiliado");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "ns2:RespuestaMensualidad"))
		{	*type = SOAP_TYPE_ns2__RespuestaMensualidad;
			return soap_in_ns2__RespuestaMensualidad(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:NumMensualidad"))
		{	*type = SOAP_TYPE_ns2__NumMensualidad;
			return soap_in_ns2__NumMensualidad(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaFechaLiquida"))
		{	*type = SOAP_TYPE_ns2__RespuestaFechaLiquida;
			return soap_in_ns2__RespuestaFechaLiquida(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FechaLiquida"))
		{	*type = SOAP_TYPE_ns2__FechaLiquida;
			return soap_in_ns2__FechaLiquida(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaSaldoRecuperar"))
		{	*type = SOAP_TYPE_ns2__RespuestaSaldoRecuperar;
			return soap_in_ns2__RespuestaSaldoRecuperar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SaldoRecuperar"))
		{	*type = SOAP_TYPE_ns2__SaldoRecuperar;
			return soap_in_ns2__SaldoRecuperar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParametroCurpNss"))
		{	*type = SOAP_TYPE_ns2__ParametroCurpNss;
			return soap_in_ns2__ParametroCurpNss(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParametroAportacionesPost"))
		{	*type = SOAP_TYPE_ns2__ParametroAportacionesPost;
			return soap_in_ns2__ParametroAportacionesPost(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaConsultaSaldoVivienda"))
		{	*type = SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda;
			return soap_in_ns2__RespuestaConsultaSaldoVivienda(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarSaldoVivienda"))
		{	*type = SOAP_TYPE_ns2__ConsultarSaldoVivienda;
			return soap_in_ns2__ConsultarSaldoVivienda(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParamConsultaSaldoVivienda"))
		{	*type = SOAP_TYPE_ns2__ParamConsultaSaldoVivienda;
			return soap_in_ns2__ParamConsultaSaldoVivienda(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaCtaSaldoVol"))
		{	*type = SOAP_TYPE_ns2__RespuestaCtaSaldoVol;
			return soap_in_ns2__RespuestaCtaSaldoVol(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns2:DatosCtaSaldoVol"))
		{	*type = SOAP_TYPE_ArrayOfDatosCtaSaldoVol;
			return soap_in_ArrayOfDatosCtaSaldoVol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DatosCtaSaldoVol"))
		{	*type = SOAP_TYPE_ns2__DatosCtaSaldoVol;
			return soap_in_ns2__DatosCtaSaldoVol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParamNssCtaSaldoVol"))
		{	*type = SOAP_TYPE_ns2__ParamNssCtaSaldoVol;
			return soap_in_ns2__ParamNssCtaSaldoVol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaSieforeCtaRegimen"))
		{	*type = SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen;
			return soap_in_ns2__RespuestaSieforeCtaRegimen(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns2:SieforeCtaRegimen"))
		{	*type = SOAP_TYPE_ArrayOfSieforeCtaRegimen;
			return soap_in_ArrayOfSieforeCtaRegimen(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SieforeCtaRegimen"))
		{	*type = SOAP_TYPE_ns2__SieforeCtaRegimen;
			return soap_in_ns2__SieforeCtaRegimen(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParamNssCtaRegimen"))
		{	*type = SOAP_TYPE_ns2__ParamNssCtaRegimen;
			return soap_in_ns2__ParamNssCtaRegimen(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaAportacionesPosteriores"))
		{	*type = SOAP_TYPE_ns2__RespuestaAportacionesPosteriores;
			return soap_in_ns2__RespuestaAportacionesPosteriores(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:AportacionesPosteriores"))
		{	*type = SOAP_TYPE_ns2__AportacionesPosteriores;
			return soap_in_ns2__AportacionesPosteriores(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParamAportacionesPosteriores"))
		{	*type = SOAP_TYPE_ns2__ParamAportacionesPosteriores;
			return soap_in_ns2__ParamAportacionesPosteriores(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaResolucionTotalIssste"))
		{	*type = SOAP_TYPE_ns2__RespuestaResolucionTotalIssste;
			return soap_in_ns2__RespuestaResolucionTotalIssste(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ResolucionTotalIssste"))
		{	*type = SOAP_TYPE_ns2__ResolucionTotalIssste;
			return soap_in_ns2__ResolucionTotalIssste(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParamResolucionTotalIssste"))
		{	*type = SOAP_TYPE_ns2__ParamResolucionTotalIssste;
			return soap_in_ns2__ParamResolucionTotalIssste(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaMovimientosCuentas"))
		{	*type = SOAP_TYPE_ns2__RespuestaMovimientosCuentas;
			return soap_in_ns2__RespuestaMovimientosCuentas(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MovimientosCuentas"))
		{	*type = SOAP_TYPE_ns2__MovimientosCuentas;
			return soap_in_ns2__MovimientosCuentas(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParamMovimientosCuentas"))
		{	*type = SOAP_TYPE_ns2__ParamMovimientosCuentas;
			return soap_in_ns2__ParamMovimientosCuentas(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaCOperacionesPmgImss"))
		{	*type = SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss;
			return soap_in_ns2__RespuestaCOperacionesPmgImss(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ResolucionOperacionPmg"))
		{	*type = SOAP_TYPE_ns2__ResolucionOperacionPmg;
			return soap_in_ns2__ResolucionOperacionPmg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParamOperacionPmgImss"))
		{	*type = SOAP_TYPE_ns2__ParamOperacionPmgImss;
			return soap_in_ns2__ParamOperacionPmgImss(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaResolucionTotalImss"))
		{	*type = SOAP_TYPE_ns2__RespuestaResolucionTotalImss;
			return soap_in_ns2__RespuestaResolucionTotalImss(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ResolucionTotalImss"))
		{	*type = SOAP_TYPE_ns2__ResolucionTotalImss;
			return soap_in_ns2__ResolucionTotalImss(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParamResolucionTotalImssRI"))
		{	*type = SOAP_TYPE_ns2__ParamResolucionTotalImssRI;
			return soap_in_ns2__ParamResolucionTotalImssRI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParamResolucionTotalImss"))
		{	*type = SOAP_TYPE_ns2__ParamResolucionTotalImss;
			return soap_in_ns2__ParamResolucionTotalImss(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaComplementoResolucion"))
		{	*type = SOAP_TYPE_ns2__RespuestaComplementoResolucion;
			return soap_in_ns2__RespuestaComplementoResolucion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ComplementoResolucion"))
		{	*type = SOAP_TYPE_ns2__ComplementoResolucion;
			return soap_in_ns2__ComplementoResolucion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaDatosResolucion"))
		{	*type = SOAP_TYPE_ns2__RespuestaDatosResolucion;
			return soap_in_ns2__RespuestaDatosResolucion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:DatosResolucion"))
		{	*type = SOAP_TYPE_ns2__DatosResolucion;
			return soap_in_ns2__DatosResolucion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaMontosFechasDatamart"))
		{	*type = SOAP_TYPE_ns2__RespuestaMontosFechasDatamart;
			return soap_in_ns2__RespuestaMontosFechasDatamart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MontosFechasDatamart"))
		{	*type = SOAP_TYPE_ns2__MontosFechasDatamart;
			return soap_in_ns2__MontosFechasDatamart(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaValidarResolucionImss"))
		{	*type = SOAP_TYPE_ns2__RespuestaValidarResolucionImss;
			return soap_in_ns2__RespuestaValidarResolucionImss(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValidarResolucionImss"))
		{	*type = SOAP_TYPE_ns2__ValidarResolucionImss;
			return soap_in_ns2__ValidarResolucionImss(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SaldoDiarioRetiroParcial"))
		{	*type = SOAP_TYPE_ns2__SaldoDiarioRetiroParcial;
			return soap_in_ns2__SaldoDiarioRetiroParcial(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultaSaldoDiarioRetiroParcial"))
		{	*type = SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial;
			return soap_in_ns2__ConsultaSaldoDiarioRetiroParcial(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaTipoSolicitante"))
		{	*type = SOAP_TYPE_ns2__RespuestaTipoSolicitante;
			return soap_in_ns2__RespuestaTipoSolicitante(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TipoSolicitante"))
		{	*type = SOAP_TYPE_ns2__TipoSolicitante;
			return soap_in_ns2__TipoSolicitante(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespuestaConvivenciaMarca"))
		{	*type = SOAP_TYPE_ns2__RespuestaConvivenciaMarca;
			return soap_in_ns2__RespuestaConvivenciaMarca(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValidaConvivenciaMarcas"))
		{	*type = SOAP_TYPE_ns2__ValidaConvivenciaMarcas;
			return soap_in_ns2__ValidaConvivenciaMarcas(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConvivenciaMarcas"))
		{	*type = SOAP_TYPE_ns2__ConvivenciaMarcas;
			return soap_in_ns2__ConvivenciaMarcas(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FolioServicio"))
		{	*type = SOAP_TYPE_ns2__FolioServicio;
			return soap_in_ns2__FolioServicio(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:FoliadorServicio"))
		{	*type = SOAP_TYPE_ns2__FoliadorServicio;
			return soap_in_ns2__FoliadorServicio(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SaldoPorSubcuentaPmg"))
		{	*type = SOAP_TYPE_ns2__SaldoPorSubcuentaPmg;
			return soap_in_ns2__SaldoPorSubcuentaPmg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SaldosCuentasPmg"))
		{	*type = SOAP_TYPE_ns2__SaldosCuentasPmg;
			return soap_in_ns2__SaldosCuentasPmg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SaldoPorSubcuenta"))
		{	*type = SOAP_TYPE_ns2__SaldoPorSubcuenta;
			return soap_in_ns2__SaldoPorSubcuenta(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns2:SaldoSubCuenta"))
		{	*type = SOAP_TYPE_ArrayOfSaldoSubCuenta;
			return soap_in_ArrayOfSaldoSubCuenta(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:SaldoSubCuenta"))
		{	*type = SOAP_TYPE_ns2__SaldoSubCuenta;
			return soap_in_ns2__SaldoSubCuenta(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:RespConsultarAfiliado"))
		{	*type = SOAP_TYPE_ns2__RespConsultarAfiliado;
			return soap_in_ns2__RespConsultarAfiliado(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:Afiliado"))
		{	*type = SOAP_TYPE_ns2__Afiliado;
			return soap_in_ns2__Afiliado(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParametroNssTipoRetiro"))
		{	*type = SOAP_TYPE_ns2__ParametroNssTipoRetiro;
			return soap_in_ns2__ParametroNssTipoRetiro(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParametroSaldoPmg"))
		{	*type = SOAP_TYPE_ns2__ParametroSaldoPmg;
			return soap_in_ns2__ParametroSaldoPmg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParametroNss"))
		{	*type = SOAP_TYPE_ns2__ParametroNss;
			return soap_in_ns2__ParametroNss(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ParamConsultarAfiliado"))
		{	*type = SOAP_TYPE_ns2__ParamConsultarAfiliado;
			return soap_in_ns2__ParamConsultarAfiliado(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:EstadoProceso"))
		{	*type = SOAP_TYPE_ns2__EstadoProceso;
			return soap_in_ns2__EstadoProceso(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TipoRetiroParcial"))
		{	*type = SOAP_TYPE_ns2__TipoRetiroParcial;
			return soap_in_ns2__TipoRetiroParcial(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:TipoTrabajador"))
		{	*type = SOAP_TYPE_ns2__TipoTrabajador;
			return soap_in_ns2__TipoTrabajador(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ClasificacionServicio"))
		{	*type = SOAP_TYPE_ns2__ClasificacionServicio;
			return soap_in_ns2__ClasificacionServicio(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:consultarSaldosPenMinGar"))
		{	*type = SOAP_TYPE_ns2__consultarSaldosPenMinGar;
			return soap_in_ns2__consultarSaldosPenMinGar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:consultarSaldosPenMinGarResponse"))
		{	*type = SOAP_TYPE_ns2__consultarSaldosPenMinGarResponse;
			return soap_in_ns2__consultarSaldosPenMinGarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CConsultarNumMensualidad"))
		{	*type = SOAP_TYPE_ns2__CConsultarNumMensualidad;
			return soap_in_ns2__CConsultarNumMensualidad(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CConsultarNumMensualidadResponse"))
		{	*type = SOAP_TYPE_ns2__CConsultarNumMensualidadResponse;
			return soap_in_ns2__CConsultarNumMensualidadResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CConsultarFechaLiquida"))
		{	*type = SOAP_TYPE_ns2__CConsultarFechaLiquida;
			return soap_in_ns2__CConsultarFechaLiquida(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CConsultarFechaLiquidaResponse"))
		{	*type = SOAP_TYPE_ns2__CConsultarFechaLiquidaResponse;
			return soap_in_ns2__CConsultarFechaLiquidaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CConsultarSaldoRecuperar"))
		{	*type = SOAP_TYPE_ns2__CConsultarSaldoRecuperar;
			return soap_in_ns2__CConsultarSaldoRecuperar(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CConsultarSaldoRecuperarResponse"))
		{	*type = SOAP_TYPE_ns2__CConsultarSaldoRecuperarResponse;
			return soap_in_ns2__CConsultarSaldoRecuperarResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CConsultarResolusionRetAportaciones"))
		{	*type = SOAP_TYPE_ns2__CConsultarResolusionRetAportaciones;
			return soap_in_ns2__CConsultarResolusionRetAportaciones(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:CConsultarResolusionRetAportacionesResponse"))
		{	*type = SOAP_TYPE_ns2__CConsultarResolusionRetAportacionesResponse;
			return soap_in_ns2__CConsultarResolusionRetAportacionesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultaAportacionesPosteriores"))
		{	*type = SOAP_TYPE_ns2__ConsultaAportacionesPosteriores;
			return soap_in_ns2__ConsultaAportacionesPosteriores(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultaAportacionesPosterioresResponse"))
		{	*type = SOAP_TYPE_ns2__ConsultaAportacionesPosterioresResponse;
			return soap_in_ns2__ConsultaAportacionesPosterioresResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultaSaldoVivienda"))
		{	*type = SOAP_TYPE_ns2__ConsultaSaldoVivienda;
			return soap_in_ns2__ConsultaSaldoVivienda(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultaSaldoViviendaResponse"))
		{	*type = SOAP_TYPE_ns2__ConsultaSaldoViviendaResponse;
			return soap_in_ns2__ConsultaSaldoViviendaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarSaldoVol"))
		{	*type = SOAP_TYPE_ns2__ConsultarSaldoVol;
			return soap_in_ns2__ConsultarSaldoVol(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarSaldoVolResponse"))
		{	*type = SOAP_TYPE_ns2__ConsultarSaldoVolResponse;
			return soap_in_ns2__ConsultarSaldoVolResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarSieforeCtaRegimen"))
		{	*type = SOAP_TYPE_ns2__ConsultarSieforeCtaRegimen;
			return soap_in_ns2__ConsultarSieforeCtaRegimen(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarSieforeCtaRegimenResponse"))
		{	*type = SOAP_TYPE_ns2__ConsultarSieforeCtaRegimenResponse;
			return soap_in_ns2__ConsultarSieforeCtaRegimenResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarResolucionTotalImssRI"))
		{	*type = SOAP_TYPE_ns2__ConsultarResolucionTotalImssRI;
			return soap_in_ns2__ConsultarResolucionTotalImssRI(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarResolucionTotalImssRIResponse"))
		{	*type = SOAP_TYPE_ns2__ConsultarResolucionTotalImssRIResponse;
			return soap_in_ns2__ConsultarResolucionTotalImssRIResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:consultarAportaciones"))
		{	*type = SOAP_TYPE_ns2__consultarAportaciones;
			return soap_in_ns2__consultarAportaciones(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:consultarAportacionesResponse"))
		{	*type = SOAP_TYPE_ns2__consultarAportacionesResponse;
			return soap_in_ns2__consultarAportacionesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:consultarSaldosPmg"))
		{	*type = SOAP_TYPE_ns2__consultarSaldosPmg;
			return soap_in_ns2__consultarSaldosPmg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:consultarSaldosPmgResponse"))
		{	*type = SOAP_TYPE_ns2__consultarSaldosPmgResponse;
			return soap_in_ns2__consultarSaldosPmgResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarResolucionTotalIssste"))
		{	*type = SOAP_TYPE_ns2__ConsultarResolucionTotalIssste;
			return soap_in_ns2__ConsultarResolucionTotalIssste(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarResolucionTotalIsssteResponse"))
		{	*type = SOAP_TYPE_ns2__ConsultarResolucionTotalIsssteResponse;
			return soap_in_ns2__ConsultarResolucionTotalIsssteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:movimientosCuentas"))
		{	*type = SOAP_TYPE_ns2__movimientosCuentas;
			return soap_in_ns2__movimientosCuentas(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:movimientosCuentasResponse"))
		{	*type = SOAP_TYPE_ns2__movimientosCuentasResponse;
			return soap_in_ns2__movimientosCuentasResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:COperacionesPmg"))
		{	*type = SOAP_TYPE_ns2__COperacionesPmg;
			return soap_in_ns2__COperacionesPmg(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:COperacionesPmgResponse"))
		{	*type = SOAP_TYPE_ns2__COperacionesPmgResponse;
			return soap_in_ns2__COperacionesPmgResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarResolucionTotalImss"))
		{	*type = SOAP_TYPE_ns2__ConsultarResolucionTotalImss;
			return soap_in_ns2__ConsultarResolucionTotalImss(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarResolucionTotalImssResponse"))
		{	*type = SOAP_TYPE_ns2__ConsultarResolucionTotalImssResponse;
			return soap_in_ns2__ConsultarResolucionTotalImssResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarComplementoResolucion"))
		{	*type = SOAP_TYPE_ns2__ConsultarComplementoResolucion;
			return soap_in_ns2__ConsultarComplementoResolucion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ConsultarComplementoResolucionResponse"))
		{	*type = SOAP_TYPE_ns2__ConsultarComplementoResolucionResponse;
			return soap_in_ns2__ConsultarComplementoResolucionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:consultarResolucion"))
		{	*type = SOAP_TYPE_ns2__consultarResolucion;
			return soap_in_ns2__consultarResolucion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:consultarResolucionResponse"))
		{	*type = SOAP_TYPE_ns2__consultarResolucionResponse;
			return soap_in_ns2__consultarResolucionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MontosFechasDatamart"))
		{	*type = SOAP_TYPE_ns2__MontosFechasDatamart_;
			return soap_in_ns2__MontosFechasDatamart_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:MontosFechasDatamartResponse"))
		{	*type = SOAP_TYPE_ns2__MontosFechasDatamartResponse;
			return soap_in_ns2__MontosFechasDatamartResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValidarResolucionImss"))
		{	*type = SOAP_TYPE_ns2__ValidarResolucionImss_;
			return soap_in_ns2__ValidarResolucionImss_(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValidarResolucionImssResponse"))
		{	*type = SOAP_TYPE_ns2__ValidarResolucionImssResponse;
			return soap_in_ns2__ValidarResolucionImssResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ObtenerSaldoDiarioRetiroParcial"))
		{	*type = SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcial;
			return soap_in_ns2__ObtenerSaldoDiarioRetiroParcial(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ObtenerSaldoDiarioRetiroParcialResponse"))
		{	*type = SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcialResponse;
			return soap_in_ns2__ObtenerSaldoDiarioRetiroParcialResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValidarConvivenciaMarcaOperativa"))
		{	*type = SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativa;
			return soap_in_ns2__ValidarConvivenciaMarcaOperativa(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ValidarConvivenciaMarcaOperativaResponse"))
		{	*type = SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativaResponse;
			return soap_in_ns2__ValidarConvivenciaMarcaOperativaResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ObtenerFolioServicio"))
		{	*type = SOAP_TYPE_ns2__ObtenerFolioServicio;
			return soap_in_ns2__ObtenerFolioServicio(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:ObtenerFolioServicioResponse"))
		{	*type = SOAP_TYPE_ns2__ObtenerFolioServicioResponse;
			return soap_in_ns2__ObtenerFolioServicioResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:consultarSaldos"))
		{	*type = SOAP_TYPE_ns2__consultarSaldos;
			return soap_in_ns2__consultarSaldos(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:consultarSaldosResponse"))
		{	*type = SOAP_TYPE_ns2__consultarSaldosResponse;
			return soap_in_ns2__consultarSaldosResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:consultarAfiliado"))
		{	*type = SOAP_TYPE_ns2__consultarAfiliado;
			return soap_in_ns2__consultarAfiliado(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns2:consultarAfiliadoResponse"))
		{	*type = SOAP_TYPE_ns2__consultarAfiliadoResponse;
			return soap_in_ns2__consultarAfiliadoResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_ns2__TipoRetiroParcial:
		return soap_out_ns2__TipoRetiroParcial(soap, tag, id, (const enum ns2__TipoRetiroParcial *)ptr, "ns2:TipoRetiroParcial");
	case SOAP_TYPE_ns2__TipoTrabajador:
		return soap_out_ns2__TipoTrabajador(soap, tag, id, (const enum ns2__TipoTrabajador *)ptr, "ns2:TipoTrabajador");
	case SOAP_TYPE_ns2__ClasificacionServicio:
		return soap_out_ns2__ClasificacionServicio(soap, tag, id, (const enum ns2__ClasificacionServicio *)ptr, "ns2:ClasificacionServicio");
	case SOAP_TYPE_ns2__RespuestaMensualidad:
		return ((ns2__RespuestaMensualidad *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaMensualidad");
	case SOAP_TYPE_ns2__NumMensualidad:
		return ((ns2__NumMensualidad *)ptr)->soap_out(soap, tag, id, "ns2:NumMensualidad");
	case SOAP_TYPE_ns2__RespuestaFechaLiquida:
		return ((ns2__RespuestaFechaLiquida *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaFechaLiquida");
	case SOAP_TYPE_ns2__FechaLiquida:
		return ((ns2__FechaLiquida *)ptr)->soap_out(soap, tag, id, "ns2:FechaLiquida");
	case SOAP_TYPE_ns2__RespuestaSaldoRecuperar:
		return ((ns2__RespuestaSaldoRecuperar *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaSaldoRecuperar");
	case SOAP_TYPE_ns2__SaldoRecuperar:
		return ((ns2__SaldoRecuperar *)ptr)->soap_out(soap, tag, id, "ns2:SaldoRecuperar");
	case SOAP_TYPE_ns2__ParametroCurpNss:
		return ((ns2__ParametroCurpNss *)ptr)->soap_out(soap, tag, id, "ns2:ParametroCurpNss");
	case SOAP_TYPE_ns2__ParametroAportacionesPost:
		return ((ns2__ParametroAportacionesPost *)ptr)->soap_out(soap, tag, id, "ns2:ParametroAportacionesPost");
	case SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda:
		return ((ns2__RespuestaConsultaSaldoVivienda *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaConsultaSaldoVivienda");
	case SOAP_TYPE_ns2__ConsultarSaldoVivienda:
		return ((ns2__ConsultarSaldoVivienda *)ptr)->soap_out(soap, tag, id, "ns2:ConsultarSaldoVivienda");
	case SOAP_TYPE_ns2__ParamConsultaSaldoVivienda:
		return ((ns2__ParamConsultaSaldoVivienda *)ptr)->soap_out(soap, tag, id, "ns2:ParamConsultaSaldoVivienda");
	case SOAP_TYPE_ns2__RespuestaCtaSaldoVol:
		return ((ns2__RespuestaCtaSaldoVol *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaCtaSaldoVol");
	case SOAP_TYPE_ArrayOfDatosCtaSaldoVol:
		return ((ArrayOfDatosCtaSaldoVol *)ptr)->soap_out(soap, tag, id, "ns2:DatosCtaSaldoVol");
	case SOAP_TYPE_ns2__DatosCtaSaldoVol:
		return ((ns2__DatosCtaSaldoVol *)ptr)->soap_out(soap, tag, id, "ns2:DatosCtaSaldoVol");
	case SOAP_TYPE_ns2__ParamNssCtaSaldoVol:
		return ((ns2__ParamNssCtaSaldoVol *)ptr)->soap_out(soap, tag, id, "ns2:ParamNssCtaSaldoVol");
	case SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen:
		return ((ns2__RespuestaSieforeCtaRegimen *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaSieforeCtaRegimen");
	case SOAP_TYPE_ArrayOfSieforeCtaRegimen:
		return ((ArrayOfSieforeCtaRegimen *)ptr)->soap_out(soap, tag, id, "ns2:SieforeCtaRegimen");
	case SOAP_TYPE_ns2__SieforeCtaRegimen:
		return ((ns2__SieforeCtaRegimen *)ptr)->soap_out(soap, tag, id, "ns2:SieforeCtaRegimen");
	case SOAP_TYPE_ns2__ParamNssCtaRegimen:
		return ((ns2__ParamNssCtaRegimen *)ptr)->soap_out(soap, tag, id, "ns2:ParamNssCtaRegimen");
	case SOAP_TYPE_ns2__RespuestaAportacionesPosteriores:
		return ((ns2__RespuestaAportacionesPosteriores *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaAportacionesPosteriores");
	case SOAP_TYPE_ns2__AportacionesPosteriores:
		return ((ns2__AportacionesPosteriores *)ptr)->soap_out(soap, tag, id, "ns2:AportacionesPosteriores");
	case SOAP_TYPE_ns2__ParamAportacionesPosteriores:
		return ((ns2__ParamAportacionesPosteriores *)ptr)->soap_out(soap, tag, id, "ns2:ParamAportacionesPosteriores");
	case SOAP_TYPE_ns2__RespuestaResolucionTotalIssste:
		return ((ns2__RespuestaResolucionTotalIssste *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaResolucionTotalIssste");
	case SOAP_TYPE_ns2__ResolucionTotalIssste:
		return ((ns2__ResolucionTotalIssste *)ptr)->soap_out(soap, tag, id, "ns2:ResolucionTotalIssste");
	case SOAP_TYPE_ns2__ParamResolucionTotalIssste:
		return ((ns2__ParamResolucionTotalIssste *)ptr)->soap_out(soap, tag, id, "ns2:ParamResolucionTotalIssste");
	case SOAP_TYPE_ns2__RespuestaMovimientosCuentas:
		return ((ns2__RespuestaMovimientosCuentas *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaMovimientosCuentas");
	case SOAP_TYPE_ns2__MovimientosCuentas:
		return ((ns2__MovimientosCuentas *)ptr)->soap_out(soap, tag, id, "ns2:MovimientosCuentas");
	case SOAP_TYPE_ns2__ParamMovimientosCuentas:
		return ((ns2__ParamMovimientosCuentas *)ptr)->soap_out(soap, tag, id, "ns2:ParamMovimientosCuentas");
	case SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss:
		return ((ns2__RespuestaCOperacionesPmgImss *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaCOperacionesPmgImss");
	case SOAP_TYPE_ns2__ResolucionOperacionPmg:
		return ((ns2__ResolucionOperacionPmg *)ptr)->soap_out(soap, tag, id, "ns2:ResolucionOperacionPmg");
	case SOAP_TYPE_ns2__ParamOperacionPmgImss:
		return ((ns2__ParamOperacionPmgImss *)ptr)->soap_out(soap, tag, id, "ns2:ParamOperacionPmgImss");
	case SOAP_TYPE_ns2__RespuestaResolucionTotalImss:
		return ((ns2__RespuestaResolucionTotalImss *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaResolucionTotalImss");
	case SOAP_TYPE_ns2__ResolucionTotalImss:
		return ((ns2__ResolucionTotalImss *)ptr)->soap_out(soap, tag, id, "ns2:ResolucionTotalImss");
	case SOAP_TYPE_ns2__ParamResolucionTotalImssRI:
		return ((ns2__ParamResolucionTotalImssRI *)ptr)->soap_out(soap, tag, id, "ns2:ParamResolucionTotalImssRI");
	case SOAP_TYPE_ns2__ParamResolucionTotalImss:
		return ((ns2__ParamResolucionTotalImss *)ptr)->soap_out(soap, tag, id, "ns2:ParamResolucionTotalImss");
	case SOAP_TYPE_ns2__RespuestaComplementoResolucion:
		return ((ns2__RespuestaComplementoResolucion *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaComplementoResolucion");
	case SOAP_TYPE_ns2__ComplementoResolucion:
		return ((ns2__ComplementoResolucion *)ptr)->soap_out(soap, tag, id, "ns2:ComplementoResolucion");
	case SOAP_TYPE_ns2__RespuestaDatosResolucion:
		return ((ns2__RespuestaDatosResolucion *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaDatosResolucion");
	case SOAP_TYPE_ns2__DatosResolucion:
		return ((ns2__DatosResolucion *)ptr)->soap_out(soap, tag, id, "ns2:DatosResolucion");
	case SOAP_TYPE_ns2__RespuestaMontosFechasDatamart:
		return ((ns2__RespuestaMontosFechasDatamart *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaMontosFechasDatamart");
	case SOAP_TYPE_ns2__MontosFechasDatamart:
		return ((ns2__MontosFechasDatamart *)ptr)->soap_out(soap, tag, id, "ns2:MontosFechasDatamart");
	case SOAP_TYPE_ns2__RespuestaValidarResolucionImss:
		return ((ns2__RespuestaValidarResolucionImss *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaValidarResolucionImss");
	case SOAP_TYPE_ns2__ValidarResolucionImss:
		return ((ns2__ValidarResolucionImss *)ptr)->soap_out(soap, tag, id, "ns2:ValidarResolucionImss");
	case SOAP_TYPE_ns2__SaldoDiarioRetiroParcial:
		return ((ns2__SaldoDiarioRetiroParcial *)ptr)->soap_out(soap, tag, id, "ns2:SaldoDiarioRetiroParcial");
	case SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial:
		return ((ns2__ConsultaSaldoDiarioRetiroParcial *)ptr)->soap_out(soap, tag, id, "ns2:ConsultaSaldoDiarioRetiroParcial");
	case SOAP_TYPE_ns2__RespuestaTipoSolicitante:
		return ((ns2__RespuestaTipoSolicitante *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaTipoSolicitante");
	case SOAP_TYPE_ns2__TipoSolicitante:
		return ((ns2__TipoSolicitante *)ptr)->soap_out(soap, tag, id, "ns2:TipoSolicitante");
	case SOAP_TYPE_ns2__RespuestaConvivenciaMarca:
		return ((ns2__RespuestaConvivenciaMarca *)ptr)->soap_out(soap, tag, id, "ns2:RespuestaConvivenciaMarca");
	case SOAP_TYPE_ns2__ValidaConvivenciaMarcas:
		return ((ns2__ValidaConvivenciaMarcas *)ptr)->soap_out(soap, tag, id, "ns2:ValidaConvivenciaMarcas");
	case SOAP_TYPE_ns2__ConvivenciaMarcas:
		return ((ns2__ConvivenciaMarcas *)ptr)->soap_out(soap, tag, id, "ns2:ConvivenciaMarcas");
	case SOAP_TYPE_ns2__FolioServicio:
		return ((ns2__FolioServicio *)ptr)->soap_out(soap, tag, id, "ns2:FolioServicio");
	case SOAP_TYPE_ns2__FoliadorServicio:
		return ((ns2__FoliadorServicio *)ptr)->soap_out(soap, tag, id, "ns2:FoliadorServicio");
	case SOAP_TYPE_ns2__SaldoPorSubcuentaPmg:
		return ((ns2__SaldoPorSubcuentaPmg *)ptr)->soap_out(soap, tag, id, "ns2:SaldoPorSubcuentaPmg");
	case SOAP_TYPE_ns2__SaldosCuentasPmg:
		return ((ns2__SaldosCuentasPmg *)ptr)->soap_out(soap, tag, id, "ns2:SaldosCuentasPmg");
	case SOAP_TYPE_ns2__SaldoPorSubcuenta:
		return ((ns2__SaldoPorSubcuenta *)ptr)->soap_out(soap, tag, id, "ns2:SaldoPorSubcuenta");
	case SOAP_TYPE_ArrayOfSaldoSubCuenta:
		return ((ArrayOfSaldoSubCuenta *)ptr)->soap_out(soap, tag, id, "ns2:SaldoSubCuenta");
	case SOAP_TYPE_ns2__SaldoSubCuenta:
		return ((ns2__SaldoSubCuenta *)ptr)->soap_out(soap, tag, id, "ns2:SaldoSubCuenta");
	case SOAP_TYPE_ns2__RespConsultarAfiliado:
		return ((ns2__RespConsultarAfiliado *)ptr)->soap_out(soap, tag, id, "ns2:RespConsultarAfiliado");
	case SOAP_TYPE_ns2__Afiliado:
		return ((ns2__Afiliado *)ptr)->soap_out(soap, tag, id, "ns2:Afiliado");
	case SOAP_TYPE_ns2__ParametroNssTipoRetiro:
		return ((ns2__ParametroNssTipoRetiro *)ptr)->soap_out(soap, tag, id, "ns2:ParametroNssTipoRetiro");
	case SOAP_TYPE_ns2__ParametroSaldoPmg:
		return ((ns2__ParametroSaldoPmg *)ptr)->soap_out(soap, tag, id, "ns2:ParametroSaldoPmg");
	case SOAP_TYPE_ns2__ParametroNss:
		return ((ns2__ParametroNss *)ptr)->soap_out(soap, tag, id, "ns2:ParametroNss");
	case SOAP_TYPE_ns2__ParamConsultarAfiliado:
		return ((ns2__ParamConsultarAfiliado *)ptr)->soap_out(soap, tag, id, "ns2:ParamConsultarAfiliado");
	case SOAP_TYPE_ns2__EstadoProceso:
		return ((ns2__EstadoProceso *)ptr)->soap_out(soap, tag, id, "ns2:EstadoProceso");
	case SOAP_TYPE_ns2__consultarSaldosPenMinGar:
		return soap_out_ns2__consultarSaldosPenMinGar(soap, tag, id, (const struct ns2__consultarSaldosPenMinGar *)ptr, "ns2:consultarSaldosPenMinGar");
	case SOAP_TYPE_ns2__consultarSaldosPenMinGarResponse:
		return soap_out_ns2__consultarSaldosPenMinGarResponse(soap, tag, id, (const struct ns2__consultarSaldosPenMinGarResponse *)ptr, "ns2:consultarSaldosPenMinGarResponse");
	case SOAP_TYPE_ns2__CConsultarNumMensualidad:
		return soap_out_ns2__CConsultarNumMensualidad(soap, tag, id, (const struct ns2__CConsultarNumMensualidad *)ptr, "ns2:CConsultarNumMensualidad");
	case SOAP_TYPE_ns2__CConsultarNumMensualidadResponse:
		return soap_out_ns2__CConsultarNumMensualidadResponse(soap, tag, id, (const struct ns2__CConsultarNumMensualidadResponse *)ptr, "ns2:CConsultarNumMensualidadResponse");
	case SOAP_TYPE_ns2__CConsultarFechaLiquida:
		return soap_out_ns2__CConsultarFechaLiquida(soap, tag, id, (const struct ns2__CConsultarFechaLiquida *)ptr, "ns2:CConsultarFechaLiquida");
	case SOAP_TYPE_ns2__CConsultarFechaLiquidaResponse:
		return soap_out_ns2__CConsultarFechaLiquidaResponse(soap, tag, id, (const struct ns2__CConsultarFechaLiquidaResponse *)ptr, "ns2:CConsultarFechaLiquidaResponse");
	case SOAP_TYPE_ns2__CConsultarSaldoRecuperar:
		return soap_out_ns2__CConsultarSaldoRecuperar(soap, tag, id, (const struct ns2__CConsultarSaldoRecuperar *)ptr, "ns2:CConsultarSaldoRecuperar");
	case SOAP_TYPE_ns2__CConsultarSaldoRecuperarResponse:
		return soap_out_ns2__CConsultarSaldoRecuperarResponse(soap, tag, id, (const struct ns2__CConsultarSaldoRecuperarResponse *)ptr, "ns2:CConsultarSaldoRecuperarResponse");
	case SOAP_TYPE_ns2__CConsultarResolusionRetAportaciones:
		return soap_out_ns2__CConsultarResolusionRetAportaciones(soap, tag, id, (const struct ns2__CConsultarResolusionRetAportaciones *)ptr, "ns2:CConsultarResolusionRetAportaciones");
	case SOAP_TYPE_ns2__CConsultarResolusionRetAportacionesResponse:
		return soap_out_ns2__CConsultarResolusionRetAportacionesResponse(soap, tag, id, (const struct ns2__CConsultarResolusionRetAportacionesResponse *)ptr, "ns2:CConsultarResolusionRetAportacionesResponse");
	case SOAP_TYPE_ns2__ConsultaAportacionesPosteriores:
		return soap_out_ns2__ConsultaAportacionesPosteriores(soap, tag, id, (const struct ns2__ConsultaAportacionesPosteriores *)ptr, "ns2:ConsultaAportacionesPosteriores");
	case SOAP_TYPE_ns2__ConsultaAportacionesPosterioresResponse:
		return soap_out_ns2__ConsultaAportacionesPosterioresResponse(soap, tag, id, (const struct ns2__ConsultaAportacionesPosterioresResponse *)ptr, "ns2:ConsultaAportacionesPosterioresResponse");
	case SOAP_TYPE_ns2__ConsultaSaldoVivienda:
		return soap_out_ns2__ConsultaSaldoVivienda(soap, tag, id, (const struct ns2__ConsultaSaldoVivienda *)ptr, "ns2:ConsultaSaldoVivienda");
	case SOAP_TYPE_ns2__ConsultaSaldoViviendaResponse:
		return soap_out_ns2__ConsultaSaldoViviendaResponse(soap, tag, id, (const struct ns2__ConsultaSaldoViviendaResponse *)ptr, "ns2:ConsultaSaldoViviendaResponse");
	case SOAP_TYPE_ns2__ConsultarSaldoVol:
		return soap_out_ns2__ConsultarSaldoVol(soap, tag, id, (const struct ns2__ConsultarSaldoVol *)ptr, "ns2:ConsultarSaldoVol");
	case SOAP_TYPE_ns2__ConsultarSaldoVolResponse:
		return soap_out_ns2__ConsultarSaldoVolResponse(soap, tag, id, (const struct ns2__ConsultarSaldoVolResponse *)ptr, "ns2:ConsultarSaldoVolResponse");
	case SOAP_TYPE_ns2__ConsultarSieforeCtaRegimen:
		return soap_out_ns2__ConsultarSieforeCtaRegimen(soap, tag, id, (const struct ns2__ConsultarSieforeCtaRegimen *)ptr, "ns2:ConsultarSieforeCtaRegimen");
	case SOAP_TYPE_ns2__ConsultarSieforeCtaRegimenResponse:
		return soap_out_ns2__ConsultarSieforeCtaRegimenResponse(soap, tag, id, (const struct ns2__ConsultarSieforeCtaRegimenResponse *)ptr, "ns2:ConsultarSieforeCtaRegimenResponse");
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssRI:
		return soap_out_ns2__ConsultarResolucionTotalImssRI(soap, tag, id, (const struct ns2__ConsultarResolucionTotalImssRI *)ptr, "ns2:ConsultarResolucionTotalImssRI");
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssRIResponse:
		return soap_out_ns2__ConsultarResolucionTotalImssRIResponse(soap, tag, id, (const struct ns2__ConsultarResolucionTotalImssRIResponse *)ptr, "ns2:ConsultarResolucionTotalImssRIResponse");
	case SOAP_TYPE_ns2__consultarAportaciones:
		return soap_out_ns2__consultarAportaciones(soap, tag, id, (const struct ns2__consultarAportaciones *)ptr, "ns2:consultarAportaciones");
	case SOAP_TYPE_ns2__consultarAportacionesResponse:
		return soap_out_ns2__consultarAportacionesResponse(soap, tag, id, (const struct ns2__consultarAportacionesResponse *)ptr, "ns2:consultarAportacionesResponse");
	case SOAP_TYPE_ns2__consultarSaldosPmg:
		return soap_out_ns2__consultarSaldosPmg(soap, tag, id, (const struct ns2__consultarSaldosPmg *)ptr, "ns2:consultarSaldosPmg");
	case SOAP_TYPE_ns2__consultarSaldosPmgResponse:
		return soap_out_ns2__consultarSaldosPmgResponse(soap, tag, id, (const struct ns2__consultarSaldosPmgResponse *)ptr, "ns2:consultarSaldosPmgResponse");
	case SOAP_TYPE_ns2__ConsultarResolucionTotalIssste:
		return soap_out_ns2__ConsultarResolucionTotalIssste(soap, tag, id, (const struct ns2__ConsultarResolucionTotalIssste *)ptr, "ns2:ConsultarResolucionTotalIssste");
	case SOAP_TYPE_ns2__ConsultarResolucionTotalIsssteResponse:
		return soap_out_ns2__ConsultarResolucionTotalIsssteResponse(soap, tag, id, (const struct ns2__ConsultarResolucionTotalIsssteResponse *)ptr, "ns2:ConsultarResolucionTotalIsssteResponse");
	case SOAP_TYPE_ns2__movimientosCuentas:
		return soap_out_ns2__movimientosCuentas(soap, tag, id, (const struct ns2__movimientosCuentas *)ptr, "ns2:movimientosCuentas");
	case SOAP_TYPE_ns2__movimientosCuentasResponse:
		return soap_out_ns2__movimientosCuentasResponse(soap, tag, id, (const struct ns2__movimientosCuentasResponse *)ptr, "ns2:movimientosCuentasResponse");
	case SOAP_TYPE_ns2__COperacionesPmg:
		return soap_out_ns2__COperacionesPmg(soap, tag, id, (const struct ns2__COperacionesPmg *)ptr, "ns2:COperacionesPmg");
	case SOAP_TYPE_ns2__COperacionesPmgResponse:
		return soap_out_ns2__COperacionesPmgResponse(soap, tag, id, (const struct ns2__COperacionesPmgResponse *)ptr, "ns2:COperacionesPmgResponse");
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImss:
		return soap_out_ns2__ConsultarResolucionTotalImss(soap, tag, id, (const struct ns2__ConsultarResolucionTotalImss *)ptr, "ns2:ConsultarResolucionTotalImss");
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssResponse:
		return soap_out_ns2__ConsultarResolucionTotalImssResponse(soap, tag, id, (const struct ns2__ConsultarResolucionTotalImssResponse *)ptr, "ns2:ConsultarResolucionTotalImssResponse");
	case SOAP_TYPE_ns2__ConsultarComplementoResolucion:
		return soap_out_ns2__ConsultarComplementoResolucion(soap, tag, id, (const struct ns2__ConsultarComplementoResolucion *)ptr, "ns2:ConsultarComplementoResolucion");
	case SOAP_TYPE_ns2__ConsultarComplementoResolucionResponse:
		return soap_out_ns2__ConsultarComplementoResolucionResponse(soap, tag, id, (const struct ns2__ConsultarComplementoResolucionResponse *)ptr, "ns2:ConsultarComplementoResolucionResponse");
	case SOAP_TYPE_ns2__consultarResolucion:
		return soap_out_ns2__consultarResolucion(soap, tag, id, (const struct ns2__consultarResolucion *)ptr, "ns2:consultarResolucion");
	case SOAP_TYPE_ns2__consultarResolucionResponse:
		return soap_out_ns2__consultarResolucionResponse(soap, tag, id, (const struct ns2__consultarResolucionResponse *)ptr, "ns2:consultarResolucionResponse");
	case SOAP_TYPE_ns2__MontosFechasDatamart_:
		return soap_out_ns2__MontosFechasDatamart_(soap, tag, id, (const struct ns2__MontosFechasDatamart_ *)ptr, "ns2:MontosFechasDatamart");
	case SOAP_TYPE_ns2__MontosFechasDatamartResponse:
		return soap_out_ns2__MontosFechasDatamartResponse(soap, tag, id, (const struct ns2__MontosFechasDatamartResponse *)ptr, "ns2:MontosFechasDatamartResponse");
	case SOAP_TYPE_ns2__ValidarResolucionImss_:
		return soap_out_ns2__ValidarResolucionImss_(soap, tag, id, (const struct ns2__ValidarResolucionImss_ *)ptr, "ns2:ValidarResolucionImss");
	case SOAP_TYPE_ns2__ValidarResolucionImssResponse:
		return soap_out_ns2__ValidarResolucionImssResponse(soap, tag, id, (const struct ns2__ValidarResolucionImssResponse *)ptr, "ns2:ValidarResolucionImssResponse");
	case SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcial:
		return soap_out_ns2__ObtenerSaldoDiarioRetiroParcial(soap, tag, id, (const struct ns2__ObtenerSaldoDiarioRetiroParcial *)ptr, "ns2:ObtenerSaldoDiarioRetiroParcial");
	case SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcialResponse:
		return soap_out_ns2__ObtenerSaldoDiarioRetiroParcialResponse(soap, tag, id, (const struct ns2__ObtenerSaldoDiarioRetiroParcialResponse *)ptr, "ns2:ObtenerSaldoDiarioRetiroParcialResponse");
	case SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativa:
		return soap_out_ns2__ValidarConvivenciaMarcaOperativa(soap, tag, id, (const struct ns2__ValidarConvivenciaMarcaOperativa *)ptr, "ns2:ValidarConvivenciaMarcaOperativa");
	case SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativaResponse:
		return soap_out_ns2__ValidarConvivenciaMarcaOperativaResponse(soap, tag, id, (const struct ns2__ValidarConvivenciaMarcaOperativaResponse *)ptr, "ns2:ValidarConvivenciaMarcaOperativaResponse");
	case SOAP_TYPE_ns2__ObtenerFolioServicio:
		return soap_out_ns2__ObtenerFolioServicio(soap, tag, id, (const struct ns2__ObtenerFolioServicio *)ptr, "ns2:ObtenerFolioServicio");
	case SOAP_TYPE_ns2__ObtenerFolioServicioResponse:
		return soap_out_ns2__ObtenerFolioServicioResponse(soap, tag, id, (const struct ns2__ObtenerFolioServicioResponse *)ptr, "ns2:ObtenerFolioServicioResponse");
	case SOAP_TYPE_ns2__consultarSaldos:
		return soap_out_ns2__consultarSaldos(soap, tag, id, (const struct ns2__consultarSaldos *)ptr, "ns2:consultarSaldos");
	case SOAP_TYPE_ns2__consultarSaldosResponse:
		return soap_out_ns2__consultarSaldosResponse(soap, tag, id, (const struct ns2__consultarSaldosResponse *)ptr, "ns2:consultarSaldosResponse");
	case SOAP_TYPE_ns2__consultarAfiliado:
		return soap_out_ns2__consultarAfiliado(soap, tag, id, (const struct ns2__consultarAfiliado *)ptr, "ns2:consultarAfiliado");
	case SOAP_TYPE_ns2__consultarAfiliadoResponse:
		return soap_out_ns2__consultarAfiliadoResponse(soap, tag, id, (const struct ns2__consultarAfiliadoResponse *)ptr, "ns2:consultarAfiliadoResponse");
	case SOAP_TYPE_PointerTons2__RespuestaMensualidad:
		return soap_out_PointerTons2__RespuestaMensualidad(soap, tag, id, (ns2__RespuestaMensualidad *const*)ptr, "ns2:RespuestaMensualidad");
	case SOAP_TYPE_PointerTons2__RespuestaFechaLiquida:
		return soap_out_PointerTons2__RespuestaFechaLiquida(soap, tag, id, (ns2__RespuestaFechaLiquida *const*)ptr, "ns2:RespuestaFechaLiquida");
	case SOAP_TYPE_PointerTons2__RespuestaSaldoRecuperar:
		return soap_out_PointerTons2__RespuestaSaldoRecuperar(soap, tag, id, (ns2__RespuestaSaldoRecuperar *const*)ptr, "ns2:RespuestaSaldoRecuperar");
	case SOAP_TYPE_PointerTons2__ParametroCurpNss:
		return soap_out_PointerTons2__ParametroCurpNss(soap, tag, id, (ns2__ParametroCurpNss *const*)ptr, "ns2:ParametroCurpNss");
	case SOAP_TYPE_PointerTons2__RespuestaTipoSolicitante:
		return soap_out_PointerTons2__RespuestaTipoSolicitante(soap, tag, id, (ns2__RespuestaTipoSolicitante *const*)ptr, "ns2:RespuestaTipoSolicitante");
	case SOAP_TYPE_PointerTons2__ParametroAportacionesPost:
		return soap_out_PointerTons2__ParametroAportacionesPost(soap, tag, id, (ns2__ParametroAportacionesPost *const*)ptr, "ns2:ParametroAportacionesPost");
	case SOAP_TYPE_PointerTons2__ParamConsultaSaldoVivienda:
		return soap_out_PointerTons2__ParamConsultaSaldoVivienda(soap, tag, id, (ns2__ParamConsultaSaldoVivienda *const*)ptr, "ns2:ParamConsultaSaldoVivienda");
	case SOAP_TYPE_PointerTons2__RespuestaConsultaSaldoVivienda:
		return soap_out_PointerTons2__RespuestaConsultaSaldoVivienda(soap, tag, id, (ns2__RespuestaConsultaSaldoVivienda *const*)ptr, "ns2:RespuestaConsultaSaldoVivienda");
	case SOAP_TYPE_PointerTons2__RespuestaCtaSaldoVol:
		return soap_out_PointerTons2__RespuestaCtaSaldoVol(soap, tag, id, (ns2__RespuestaCtaSaldoVol *const*)ptr, "ns2:RespuestaCtaSaldoVol");
	case SOAP_TYPE_PointerTons2__ParamNssCtaRegimen:
		return soap_out_PointerTons2__ParamNssCtaRegimen(soap, tag, id, (ns2__ParamNssCtaRegimen *const*)ptr, "ns2:ParamNssCtaRegimen");
	case SOAP_TYPE_PointerTons2__RespuestaSieforeCtaRegimen:
		return soap_out_PointerTons2__RespuestaSieforeCtaRegimen(soap, tag, id, (ns2__RespuestaSieforeCtaRegimen *const*)ptr, "ns2:RespuestaSieforeCtaRegimen");
	case SOAP_TYPE_PointerTons2__ParamResolucionTotalImssRI:
		return soap_out_PointerTons2__ParamResolucionTotalImssRI(soap, tag, id, (ns2__ParamResolucionTotalImssRI *const*)ptr, "ns2:ParamResolucionTotalImssRI");
	case SOAP_TYPE_PointerTons2__ParamAportacionesPosteriores:
		return soap_out_PointerTons2__ParamAportacionesPosteriores(soap, tag, id, (ns2__ParamAportacionesPosteriores *const*)ptr, "ns2:ParamAportacionesPosteriores");
	case SOAP_TYPE_PointerTons2__RespuestaAportacionesPosteriores:
		return soap_out_PointerTons2__RespuestaAportacionesPosteriores(soap, tag, id, (ns2__RespuestaAportacionesPosteriores *const*)ptr, "ns2:RespuestaAportacionesPosteriores");
	case SOAP_TYPE_PointerTons2__ParametroSaldoPmg:
		return soap_out_PointerTons2__ParametroSaldoPmg(soap, tag, id, (ns2__ParametroSaldoPmg *const*)ptr, "ns2:ParametroSaldoPmg");
	case SOAP_TYPE_PointerTons2__SaldoPorSubcuentaPmg:
		return soap_out_PointerTons2__SaldoPorSubcuentaPmg(soap, tag, id, (ns2__SaldoPorSubcuentaPmg *const*)ptr, "ns2:SaldoPorSubcuentaPmg");
	case SOAP_TYPE_PointerTons2__ParamResolucionTotalIssste:
		return soap_out_PointerTons2__ParamResolucionTotalIssste(soap, tag, id, (ns2__ParamResolucionTotalIssste *const*)ptr, "ns2:ParamResolucionTotalIssste");
	case SOAP_TYPE_PointerTons2__RespuestaResolucionTotalIssste:
		return soap_out_PointerTons2__RespuestaResolucionTotalIssste(soap, tag, id, (ns2__RespuestaResolucionTotalIssste *const*)ptr, "ns2:RespuestaResolucionTotalIssste");
	case SOAP_TYPE_PointerTons2__ParamMovimientosCuentas:
		return soap_out_PointerTons2__ParamMovimientosCuentas(soap, tag, id, (ns2__ParamMovimientosCuentas *const*)ptr, "ns2:ParamMovimientosCuentas");
	case SOAP_TYPE_PointerTons2__RespuestaMovimientosCuentas:
		return soap_out_PointerTons2__RespuestaMovimientosCuentas(soap, tag, id, (ns2__RespuestaMovimientosCuentas *const*)ptr, "ns2:RespuestaMovimientosCuentas");
	case SOAP_TYPE_PointerTons2__ParamOperacionPmgImss:
		return soap_out_PointerTons2__ParamOperacionPmgImss(soap, tag, id, (ns2__ParamOperacionPmgImss *const*)ptr, "ns2:ParamOperacionPmgImss");
	case SOAP_TYPE_PointerTons2__RespuestaCOperacionesPmgImss:
		return soap_out_PointerTons2__RespuestaCOperacionesPmgImss(soap, tag, id, (ns2__RespuestaCOperacionesPmgImss *const*)ptr, "ns2:RespuestaCOperacionesPmgImss");
	case SOAP_TYPE_PointerTons2__ParamResolucionTotalImss:
		return soap_out_PointerTons2__ParamResolucionTotalImss(soap, tag, id, (ns2__ParamResolucionTotalImss *const*)ptr, "ns2:ParamResolucionTotalImss");
	case SOAP_TYPE_PointerTons2__RespuestaResolucionTotalImss:
		return soap_out_PointerTons2__RespuestaResolucionTotalImss(soap, tag, id, (ns2__RespuestaResolucionTotalImss *const*)ptr, "ns2:RespuestaResolucionTotalImss");
	case SOAP_TYPE_PointerTons2__RespuestaComplementoResolucion:
		return soap_out_PointerTons2__RespuestaComplementoResolucion(soap, tag, id, (ns2__RespuestaComplementoResolucion *const*)ptr, "ns2:RespuestaComplementoResolucion");
	case SOAP_TYPE_PointerTons2__RespuestaDatosResolucion:
		return soap_out_PointerTons2__RespuestaDatosResolucion(soap, tag, id, (ns2__RespuestaDatosResolucion *const*)ptr, "ns2:RespuestaDatosResolucion");
	case SOAP_TYPE_PointerTons2__RespuestaMontosFechasDatamart:
		return soap_out_PointerTons2__RespuestaMontosFechasDatamart(soap, tag, id, (ns2__RespuestaMontosFechasDatamart *const*)ptr, "ns2:RespuestaMontosFechasDatamart");
	case SOAP_TYPE_PointerTons2__ParametroNssTipoRetiro:
		return soap_out_PointerTons2__ParametroNssTipoRetiro(soap, tag, id, (ns2__ParametroNssTipoRetiro *const*)ptr, "ns2:ParametroNssTipoRetiro");
	case SOAP_TYPE_PointerTons2__RespuestaValidarResolucionImss:
		return soap_out_PointerTons2__RespuestaValidarResolucionImss(soap, tag, id, (ns2__RespuestaValidarResolucionImss *const*)ptr, "ns2:RespuestaValidarResolucionImss");
	case SOAP_TYPE_PointerTons2__ConsultaSaldoDiarioRetiroParcial:
		return soap_out_PointerTons2__ConsultaSaldoDiarioRetiroParcial(soap, tag, id, (ns2__ConsultaSaldoDiarioRetiroParcial *const*)ptr, "ns2:ConsultaSaldoDiarioRetiroParcial");
	case SOAP_TYPE_PointerTons2__SaldoDiarioRetiroParcial:
		return soap_out_PointerTons2__SaldoDiarioRetiroParcial(soap, tag, id, (ns2__SaldoDiarioRetiroParcial *const*)ptr, "ns2:SaldoDiarioRetiroParcial");
	case SOAP_TYPE_PointerTons2__ConvivenciaMarcas:
		return soap_out_PointerTons2__ConvivenciaMarcas(soap, tag, id, (ns2__ConvivenciaMarcas *const*)ptr, "ns2:ConvivenciaMarcas");
	case SOAP_TYPE_PointerTons2__RespuestaConvivenciaMarca:
		return soap_out_PointerTons2__RespuestaConvivenciaMarca(soap, tag, id, (ns2__RespuestaConvivenciaMarca *const*)ptr, "ns2:RespuestaConvivenciaMarca");
	case SOAP_TYPE_PointerTons2__FoliadorServicio:
		return soap_out_PointerTons2__FoliadorServicio(soap, tag, id, (ns2__FoliadorServicio *const*)ptr, "ns2:FoliadorServicio");
	case SOAP_TYPE_PointerTons2__FolioServicio:
		return soap_out_PointerTons2__FolioServicio(soap, tag, id, (ns2__FolioServicio *const*)ptr, "ns2:FolioServicio");
	case SOAP_TYPE_PointerTons2__ParametroNss:
		return soap_out_PointerTons2__ParametroNss(soap, tag, id, (ns2__ParametroNss *const*)ptr, "ns2:ParametroNss");
	case SOAP_TYPE_PointerTons2__SaldoPorSubcuenta:
		return soap_out_PointerTons2__SaldoPorSubcuenta(soap, tag, id, (ns2__SaldoPorSubcuenta *const*)ptr, "ns2:SaldoPorSubcuenta");
	case SOAP_TYPE_PointerTons2__ParamConsultarAfiliado:
		return soap_out_PointerTons2__ParamConsultarAfiliado(soap, tag, id, (ns2__ParamConsultarAfiliado *const*)ptr, "ns2:ParamConsultarAfiliado");
	case SOAP_TYPE_PointerTons2__RespConsultarAfiliado:
		return soap_out_PointerTons2__RespConsultarAfiliado(soap, tag, id, (ns2__RespConsultarAfiliado *const*)ptr, "ns2:RespConsultarAfiliado");
	case SOAP_TYPE_PointerToPointerTons2__DatosCtaSaldoVol:
		return soap_out_PointerToPointerTons2__DatosCtaSaldoVol(soap, tag, id, (ns2__DatosCtaSaldoVol **const*)ptr, "ns2:DatosCtaSaldoVol");
	case SOAP_TYPE_PointerTons2__DatosCtaSaldoVol:
		return soap_out_PointerTons2__DatosCtaSaldoVol(soap, tag, id, (ns2__DatosCtaSaldoVol *const*)ptr, "ns2:DatosCtaSaldoVol");
	case SOAP_TYPE_PointerToPointerTons2__SieforeCtaRegimen:
		return soap_out_PointerToPointerTons2__SieforeCtaRegimen(soap, tag, id, (ns2__SieforeCtaRegimen **const*)ptr, "ns2:SieforeCtaRegimen");
	case SOAP_TYPE_PointerTons2__SieforeCtaRegimen:
		return soap_out_PointerTons2__SieforeCtaRegimen(soap, tag, id, (ns2__SieforeCtaRegimen *const*)ptr, "ns2:SieforeCtaRegimen");
	case SOAP_TYPE_PointerToPointerTons2__SaldoSubCuenta:
		return soap_out_PointerToPointerTons2__SaldoSubCuenta(soap, tag, id, (ns2__SaldoSubCuenta **const*)ptr, "ns2:SaldoSubCuenta");
	case SOAP_TYPE_PointerTons2__SaldoSubCuenta:
		return soap_out_PointerTons2__SaldoSubCuenta(soap, tag, id, (ns2__SaldoSubCuenta *const*)ptr, "ns2:SaldoSubCuenta");
	case SOAP_TYPE_PointerTons2__NumMensualidad:
		return soap_out_PointerTons2__NumMensualidad(soap, tag, id, (ns2__NumMensualidad *const*)ptr, "ns2:NumMensualidad");
	case SOAP_TYPE_PointerTons2__FechaLiquida:
		return soap_out_PointerTons2__FechaLiquida(soap, tag, id, (ns2__FechaLiquida *const*)ptr, "ns2:FechaLiquida");
	case SOAP_TYPE_PointerTons2__SaldoRecuperar:
		return soap_out_PointerTons2__SaldoRecuperar(soap, tag, id, (ns2__SaldoRecuperar *const*)ptr, "ns2:SaldoRecuperar");
	case SOAP_TYPE_PointerTons2__ConsultarSaldoVivienda:
		return soap_out_PointerTons2__ConsultarSaldoVivienda(soap, tag, id, (ns2__ConsultarSaldoVivienda *const*)ptr, "ns2:ConsultarSaldoVivienda");
	case SOAP_TYPE_PointerToArrayOfDatosCtaSaldoVol:
		return soap_out_PointerToArrayOfDatosCtaSaldoVol(soap, tag, id, (ArrayOfDatosCtaSaldoVol *const*)ptr, "ns2:DatosCtaSaldoVol");
	case SOAP_TYPE_PointerToArrayOfSieforeCtaRegimen:
		return soap_out_PointerToArrayOfSieforeCtaRegimen(soap, tag, id, (ArrayOfSieforeCtaRegimen *const*)ptr, "ns2:SieforeCtaRegimen");
	case SOAP_TYPE_PointerTons2__AportacionesPosteriores:
		return soap_out_PointerTons2__AportacionesPosteriores(soap, tag, id, (ns2__AportacionesPosteriores *const*)ptr, "ns2:AportacionesPosteriores");
	case SOAP_TYPE_PointerTons2__ResolucionTotalIssste:
		return soap_out_PointerTons2__ResolucionTotalIssste(soap, tag, id, (ns2__ResolucionTotalIssste *const*)ptr, "ns2:ResolucionTotalIssste");
	case SOAP_TYPE_PointerTons2__MovimientosCuentas:
		return soap_out_PointerTons2__MovimientosCuentas(soap, tag, id, (ns2__MovimientosCuentas *const*)ptr, "ns2:MovimientosCuentas");
	case SOAP_TYPE_PointerTons2__ResolucionOperacionPmg:
		return soap_out_PointerTons2__ResolucionOperacionPmg(soap, tag, id, (ns2__ResolucionOperacionPmg *const*)ptr, "ns2:ResolucionOperacionPmg");
	case SOAP_TYPE_PointerTons2__ResolucionTotalImss:
		return soap_out_PointerTons2__ResolucionTotalImss(soap, tag, id, (ns2__ResolucionTotalImss *const*)ptr, "ns2:ResolucionTotalImss");
	case SOAP_TYPE_PointerTons2__ComplementoResolucion:
		return soap_out_PointerTons2__ComplementoResolucion(soap, tag, id, (ns2__ComplementoResolucion *const*)ptr, "ns2:ComplementoResolucion");
	case SOAP_TYPE_PointerTons2__DatosResolucion:
		return soap_out_PointerTons2__DatosResolucion(soap, tag, id, (ns2__DatosResolucion *const*)ptr, "ns2:DatosResolucion");
	case SOAP_TYPE_PointerTons2__MontosFechasDatamart:
		return soap_out_PointerTons2__MontosFechasDatamart(soap, tag, id, (ns2__MontosFechasDatamart *const*)ptr, "ns2:MontosFechasDatamart");
	case SOAP_TYPE_PointerTons2__ValidarResolucionImss:
		return soap_out_PointerTons2__ValidarResolucionImss(soap, tag, id, (ns2__ValidarResolucionImss *const*)ptr, "ns2:ValidarResolucionImss");
	case SOAP_TYPE_PointerTons2__TipoSolicitante:
		return soap_out_PointerTons2__TipoSolicitante(soap, tag, id, (ns2__TipoSolicitante *const*)ptr, "ns2:TipoSolicitante");
	case SOAP_TYPE_PointerTons2__ValidaConvivenciaMarcas:
		return soap_out_PointerTons2__ValidaConvivenciaMarcas(soap, tag, id, (ns2__ValidaConvivenciaMarcas *const*)ptr, "ns2:ValidaConvivenciaMarcas");
	case SOAP_TYPE_PointerTons2__SaldosCuentasPmg:
		return soap_out_PointerTons2__SaldosCuentasPmg(soap, tag, id, (ns2__SaldosCuentasPmg *const*)ptr, "ns2:SaldosCuentasPmg");
	case SOAP_TYPE_PointerToArrayOfSaldoSubCuenta:
		return soap_out_PointerToArrayOfSaldoSubCuenta(soap, tag, id, (ArrayOfSaldoSubCuenta *const*)ptr, "ns2:SaldoSubCuenta");
	case SOAP_TYPE_PointerTons2__EstadoProceso:
		return soap_out_PointerTons2__EstadoProceso(soap, tag, id, (ns2__EstadoProceso *const*)ptr, "ns2:EstadoProceso");
	case SOAP_TYPE_PointerTons2__Afiliado:
		return soap_out_PointerTons2__Afiliado(soap, tag, id, (ns2__Afiliado *const*)ptr, "ns2:Afiliado");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns2__RespuestaMensualidad:
		((ns2__RespuestaMensualidad *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__NumMensualidad:
		((ns2__NumMensualidad *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaFechaLiquida:
		((ns2__RespuestaFechaLiquida *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FechaLiquida:
		((ns2__FechaLiquida *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaSaldoRecuperar:
		((ns2__RespuestaSaldoRecuperar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SaldoRecuperar:
		((ns2__SaldoRecuperar *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParametroCurpNss:
		((ns2__ParametroCurpNss *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParametroAportacionesPost:
		((ns2__ParametroAportacionesPost *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda:
		((ns2__RespuestaConsultaSaldoVivienda *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ConsultarSaldoVivienda:
		((ns2__ConsultarSaldoVivienda *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParamConsultaSaldoVivienda:
		((ns2__ParamConsultaSaldoVivienda *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaCtaSaldoVol:
		((ns2__RespuestaCtaSaldoVol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfDatosCtaSaldoVol:
		((ArrayOfDatosCtaSaldoVol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DatosCtaSaldoVol:
		((ns2__DatosCtaSaldoVol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParamNssCtaSaldoVol:
		((ns2__ParamNssCtaSaldoVol *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen:
		((ns2__RespuestaSieforeCtaRegimen *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfSieforeCtaRegimen:
		((ArrayOfSieforeCtaRegimen *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SieforeCtaRegimen:
		((ns2__SieforeCtaRegimen *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParamNssCtaRegimen:
		((ns2__ParamNssCtaRegimen *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaAportacionesPosteriores:
		((ns2__RespuestaAportacionesPosteriores *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__AportacionesPosteriores:
		((ns2__AportacionesPosteriores *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParamAportacionesPosteriores:
		((ns2__ParamAportacionesPosteriores *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaResolucionTotalIssste:
		((ns2__RespuestaResolucionTotalIssste *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ResolucionTotalIssste:
		((ns2__ResolucionTotalIssste *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParamResolucionTotalIssste:
		((ns2__ParamResolucionTotalIssste *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaMovimientosCuentas:
		((ns2__RespuestaMovimientosCuentas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MovimientosCuentas:
		((ns2__MovimientosCuentas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParamMovimientosCuentas:
		((ns2__ParamMovimientosCuentas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss:
		((ns2__RespuestaCOperacionesPmgImss *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ResolucionOperacionPmg:
		((ns2__ResolucionOperacionPmg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParamOperacionPmgImss:
		((ns2__ParamOperacionPmgImss *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaResolucionTotalImss:
		((ns2__RespuestaResolucionTotalImss *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ResolucionTotalImss:
		((ns2__ResolucionTotalImss *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParamResolucionTotalImssRI:
		((ns2__ParamResolucionTotalImssRI *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParamResolucionTotalImss:
		((ns2__ParamResolucionTotalImss *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaComplementoResolucion:
		((ns2__RespuestaComplementoResolucion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ComplementoResolucion:
		((ns2__ComplementoResolucion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaDatosResolucion:
		((ns2__RespuestaDatosResolucion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__DatosResolucion:
		((ns2__DatosResolucion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaMontosFechasDatamart:
		((ns2__RespuestaMontosFechasDatamart *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__MontosFechasDatamart:
		((ns2__MontosFechasDatamart *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaValidarResolucionImss:
		((ns2__RespuestaValidarResolucionImss *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ValidarResolucionImss:
		((ns2__ValidarResolucionImss *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SaldoDiarioRetiroParcial:
		((ns2__SaldoDiarioRetiroParcial *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial:
		((ns2__ConsultaSaldoDiarioRetiroParcial *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaTipoSolicitante:
		((ns2__RespuestaTipoSolicitante *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__TipoSolicitante:
		((ns2__TipoSolicitante *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespuestaConvivenciaMarca:
		((ns2__RespuestaConvivenciaMarca *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ValidaConvivenciaMarcas:
		((ns2__ValidaConvivenciaMarcas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ConvivenciaMarcas:
		((ns2__ConvivenciaMarcas *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FolioServicio:
		((ns2__FolioServicio *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__FoliadorServicio:
		((ns2__FoliadorServicio *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SaldoPorSubcuentaPmg:
		((ns2__SaldoPorSubcuentaPmg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SaldosCuentasPmg:
		((ns2__SaldosCuentasPmg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SaldoPorSubcuenta:
		((ns2__SaldoPorSubcuenta *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfSaldoSubCuenta:
		((ArrayOfSaldoSubCuenta *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__SaldoSubCuenta:
		((ns2__SaldoSubCuenta *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__RespConsultarAfiliado:
		((ns2__RespConsultarAfiliado *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__Afiliado:
		((ns2__Afiliado *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParametroNssTipoRetiro:
		((ns2__ParametroNssTipoRetiro *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParametroSaldoPmg:
		((ns2__ParametroSaldoPmg *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParametroNss:
		((ns2__ParametroNss *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__ParamConsultarAfiliado:
		((ns2__ParamConsultarAfiliado *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__EstadoProceso:
		((ns2__EstadoProceso *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns2__consultarSaldosPenMinGar:
		soap_serialize_ns2__consultarSaldosPenMinGar(soap, (const struct ns2__consultarSaldosPenMinGar *)ptr);
		break;
	case SOAP_TYPE_ns2__consultarSaldosPenMinGarResponse:
		soap_serialize_ns2__consultarSaldosPenMinGarResponse(soap, (const struct ns2__consultarSaldosPenMinGarResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarNumMensualidad:
		soap_serialize_ns2__CConsultarNumMensualidad(soap, (const struct ns2__CConsultarNumMensualidad *)ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarNumMensualidadResponse:
		soap_serialize_ns2__CConsultarNumMensualidadResponse(soap, (const struct ns2__CConsultarNumMensualidadResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarFechaLiquida:
		soap_serialize_ns2__CConsultarFechaLiquida(soap, (const struct ns2__CConsultarFechaLiquida *)ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarFechaLiquidaResponse:
		soap_serialize_ns2__CConsultarFechaLiquidaResponse(soap, (const struct ns2__CConsultarFechaLiquidaResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarSaldoRecuperar:
		soap_serialize_ns2__CConsultarSaldoRecuperar(soap, (const struct ns2__CConsultarSaldoRecuperar *)ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarSaldoRecuperarResponse:
		soap_serialize_ns2__CConsultarSaldoRecuperarResponse(soap, (const struct ns2__CConsultarSaldoRecuperarResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarResolusionRetAportaciones:
		soap_serialize_ns2__CConsultarResolusionRetAportaciones(soap, (const struct ns2__CConsultarResolusionRetAportaciones *)ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarResolusionRetAportacionesResponse:
		soap_serialize_ns2__CConsultarResolusionRetAportacionesResponse(soap, (const struct ns2__CConsultarResolusionRetAportacionesResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultaAportacionesPosteriores:
		soap_serialize_ns2__ConsultaAportacionesPosteriores(soap, (const struct ns2__ConsultaAportacionesPosteriores *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultaAportacionesPosterioresResponse:
		soap_serialize_ns2__ConsultaAportacionesPosterioresResponse(soap, (const struct ns2__ConsultaAportacionesPosterioresResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultaSaldoVivienda:
		soap_serialize_ns2__ConsultaSaldoVivienda(soap, (const struct ns2__ConsultaSaldoVivienda *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultaSaldoViviendaResponse:
		soap_serialize_ns2__ConsultaSaldoViviendaResponse(soap, (const struct ns2__ConsultaSaldoViviendaResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarSaldoVol:
		soap_serialize_ns2__ConsultarSaldoVol(soap, (const struct ns2__ConsultarSaldoVol *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarSaldoVolResponse:
		soap_serialize_ns2__ConsultarSaldoVolResponse(soap, (const struct ns2__ConsultarSaldoVolResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarSieforeCtaRegimen:
		soap_serialize_ns2__ConsultarSieforeCtaRegimen(soap, (const struct ns2__ConsultarSieforeCtaRegimen *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarSieforeCtaRegimenResponse:
		soap_serialize_ns2__ConsultarSieforeCtaRegimenResponse(soap, (const struct ns2__ConsultarSieforeCtaRegimenResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssRI:
		soap_serialize_ns2__ConsultarResolucionTotalImssRI(soap, (const struct ns2__ConsultarResolucionTotalImssRI *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssRIResponse:
		soap_serialize_ns2__ConsultarResolucionTotalImssRIResponse(soap, (const struct ns2__ConsultarResolucionTotalImssRIResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__consultarAportaciones:
		soap_serialize_ns2__consultarAportaciones(soap, (const struct ns2__consultarAportaciones *)ptr);
		break;
	case SOAP_TYPE_ns2__consultarAportacionesResponse:
		soap_serialize_ns2__consultarAportacionesResponse(soap, (const struct ns2__consultarAportacionesResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__consultarSaldosPmg:
		soap_serialize_ns2__consultarSaldosPmg(soap, (const struct ns2__consultarSaldosPmg *)ptr);
		break;
	case SOAP_TYPE_ns2__consultarSaldosPmgResponse:
		soap_serialize_ns2__consultarSaldosPmgResponse(soap, (const struct ns2__consultarSaldosPmgResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarResolucionTotalIssste:
		soap_serialize_ns2__ConsultarResolucionTotalIssste(soap, (const struct ns2__ConsultarResolucionTotalIssste *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarResolucionTotalIsssteResponse:
		soap_serialize_ns2__ConsultarResolucionTotalIsssteResponse(soap, (const struct ns2__ConsultarResolucionTotalIsssteResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__movimientosCuentas:
		soap_serialize_ns2__movimientosCuentas(soap, (const struct ns2__movimientosCuentas *)ptr);
		break;
	case SOAP_TYPE_ns2__movimientosCuentasResponse:
		soap_serialize_ns2__movimientosCuentasResponse(soap, (const struct ns2__movimientosCuentasResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__COperacionesPmg:
		soap_serialize_ns2__COperacionesPmg(soap, (const struct ns2__COperacionesPmg *)ptr);
		break;
	case SOAP_TYPE_ns2__COperacionesPmgResponse:
		soap_serialize_ns2__COperacionesPmgResponse(soap, (const struct ns2__COperacionesPmgResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImss:
		soap_serialize_ns2__ConsultarResolucionTotalImss(soap, (const struct ns2__ConsultarResolucionTotalImss *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssResponse:
		soap_serialize_ns2__ConsultarResolucionTotalImssResponse(soap, (const struct ns2__ConsultarResolucionTotalImssResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarComplementoResolucion:
		soap_serialize_ns2__ConsultarComplementoResolucion(soap, (const struct ns2__ConsultarComplementoResolucion *)ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarComplementoResolucionResponse:
		soap_serialize_ns2__ConsultarComplementoResolucionResponse(soap, (const struct ns2__ConsultarComplementoResolucionResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__consultarResolucion:
		soap_serialize_ns2__consultarResolucion(soap, (const struct ns2__consultarResolucion *)ptr);
		break;
	case SOAP_TYPE_ns2__consultarResolucionResponse:
		soap_serialize_ns2__consultarResolucionResponse(soap, (const struct ns2__consultarResolucionResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__MontosFechasDatamart_:
		soap_serialize_ns2__MontosFechasDatamart_(soap, (const struct ns2__MontosFechasDatamart_ *)ptr);
		break;
	case SOAP_TYPE_ns2__MontosFechasDatamartResponse:
		soap_serialize_ns2__MontosFechasDatamartResponse(soap, (const struct ns2__MontosFechasDatamartResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__ValidarResolucionImss_:
		soap_serialize_ns2__ValidarResolucionImss_(soap, (const struct ns2__ValidarResolucionImss_ *)ptr);
		break;
	case SOAP_TYPE_ns2__ValidarResolucionImssResponse:
		soap_serialize_ns2__ValidarResolucionImssResponse(soap, (const struct ns2__ValidarResolucionImssResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcial:
		soap_serialize_ns2__ObtenerSaldoDiarioRetiroParcial(soap, (const struct ns2__ObtenerSaldoDiarioRetiroParcial *)ptr);
		break;
	case SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcialResponse:
		soap_serialize_ns2__ObtenerSaldoDiarioRetiroParcialResponse(soap, (const struct ns2__ObtenerSaldoDiarioRetiroParcialResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativa:
		soap_serialize_ns2__ValidarConvivenciaMarcaOperativa(soap, (const struct ns2__ValidarConvivenciaMarcaOperativa *)ptr);
		break;
	case SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativaResponse:
		soap_serialize_ns2__ValidarConvivenciaMarcaOperativaResponse(soap, (const struct ns2__ValidarConvivenciaMarcaOperativaResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__ObtenerFolioServicio:
		soap_serialize_ns2__ObtenerFolioServicio(soap, (const struct ns2__ObtenerFolioServicio *)ptr);
		break;
	case SOAP_TYPE_ns2__ObtenerFolioServicioResponse:
		soap_serialize_ns2__ObtenerFolioServicioResponse(soap, (const struct ns2__ObtenerFolioServicioResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__consultarSaldos:
		soap_serialize_ns2__consultarSaldos(soap, (const struct ns2__consultarSaldos *)ptr);
		break;
	case SOAP_TYPE_ns2__consultarSaldosResponse:
		soap_serialize_ns2__consultarSaldosResponse(soap, (const struct ns2__consultarSaldosResponse *)ptr);
		break;
	case SOAP_TYPE_ns2__consultarAfiliado:
		soap_serialize_ns2__consultarAfiliado(soap, (const struct ns2__consultarAfiliado *)ptr);
		break;
	case SOAP_TYPE_ns2__consultarAfiliadoResponse:
		soap_serialize_ns2__consultarAfiliadoResponse(soap, (const struct ns2__consultarAfiliadoResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaMensualidad:
		soap_serialize_PointerTons2__RespuestaMensualidad(soap, (ns2__RespuestaMensualidad *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaFechaLiquida:
		soap_serialize_PointerTons2__RespuestaFechaLiquida(soap, (ns2__RespuestaFechaLiquida *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaSaldoRecuperar:
		soap_serialize_PointerTons2__RespuestaSaldoRecuperar(soap, (ns2__RespuestaSaldoRecuperar *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParametroCurpNss:
		soap_serialize_PointerTons2__ParametroCurpNss(soap, (ns2__ParametroCurpNss *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaTipoSolicitante:
		soap_serialize_PointerTons2__RespuestaTipoSolicitante(soap, (ns2__RespuestaTipoSolicitante *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParametroAportacionesPost:
		soap_serialize_PointerTons2__ParametroAportacionesPost(soap, (ns2__ParametroAportacionesPost *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParamConsultaSaldoVivienda:
		soap_serialize_PointerTons2__ParamConsultaSaldoVivienda(soap, (ns2__ParamConsultaSaldoVivienda *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaConsultaSaldoVivienda:
		soap_serialize_PointerTons2__RespuestaConsultaSaldoVivienda(soap, (ns2__RespuestaConsultaSaldoVivienda *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaCtaSaldoVol:
		soap_serialize_PointerTons2__RespuestaCtaSaldoVol(soap, (ns2__RespuestaCtaSaldoVol *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParamNssCtaRegimen:
		soap_serialize_PointerTons2__ParamNssCtaRegimen(soap, (ns2__ParamNssCtaRegimen *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaSieforeCtaRegimen:
		soap_serialize_PointerTons2__RespuestaSieforeCtaRegimen(soap, (ns2__RespuestaSieforeCtaRegimen *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParamResolucionTotalImssRI:
		soap_serialize_PointerTons2__ParamResolucionTotalImssRI(soap, (ns2__ParamResolucionTotalImssRI *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParamAportacionesPosteriores:
		soap_serialize_PointerTons2__ParamAportacionesPosteriores(soap, (ns2__ParamAportacionesPosteriores *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaAportacionesPosteriores:
		soap_serialize_PointerTons2__RespuestaAportacionesPosteriores(soap, (ns2__RespuestaAportacionesPosteriores *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParametroSaldoPmg:
		soap_serialize_PointerTons2__ParametroSaldoPmg(soap, (ns2__ParametroSaldoPmg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SaldoPorSubcuentaPmg:
		soap_serialize_PointerTons2__SaldoPorSubcuentaPmg(soap, (ns2__SaldoPorSubcuentaPmg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParamResolucionTotalIssste:
		soap_serialize_PointerTons2__ParamResolucionTotalIssste(soap, (ns2__ParamResolucionTotalIssste *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaResolucionTotalIssste:
		soap_serialize_PointerTons2__RespuestaResolucionTotalIssste(soap, (ns2__RespuestaResolucionTotalIssste *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParamMovimientosCuentas:
		soap_serialize_PointerTons2__ParamMovimientosCuentas(soap, (ns2__ParamMovimientosCuentas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaMovimientosCuentas:
		soap_serialize_PointerTons2__RespuestaMovimientosCuentas(soap, (ns2__RespuestaMovimientosCuentas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParamOperacionPmgImss:
		soap_serialize_PointerTons2__ParamOperacionPmgImss(soap, (ns2__ParamOperacionPmgImss *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaCOperacionesPmgImss:
		soap_serialize_PointerTons2__RespuestaCOperacionesPmgImss(soap, (ns2__RespuestaCOperacionesPmgImss *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParamResolucionTotalImss:
		soap_serialize_PointerTons2__ParamResolucionTotalImss(soap, (ns2__ParamResolucionTotalImss *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaResolucionTotalImss:
		soap_serialize_PointerTons2__RespuestaResolucionTotalImss(soap, (ns2__RespuestaResolucionTotalImss *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaComplementoResolucion:
		soap_serialize_PointerTons2__RespuestaComplementoResolucion(soap, (ns2__RespuestaComplementoResolucion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaDatosResolucion:
		soap_serialize_PointerTons2__RespuestaDatosResolucion(soap, (ns2__RespuestaDatosResolucion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaMontosFechasDatamart:
		soap_serialize_PointerTons2__RespuestaMontosFechasDatamart(soap, (ns2__RespuestaMontosFechasDatamart *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParametroNssTipoRetiro:
		soap_serialize_PointerTons2__ParametroNssTipoRetiro(soap, (ns2__ParametroNssTipoRetiro *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaValidarResolucionImss:
		soap_serialize_PointerTons2__RespuestaValidarResolucionImss(soap, (ns2__RespuestaValidarResolucionImss *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ConsultaSaldoDiarioRetiroParcial:
		soap_serialize_PointerTons2__ConsultaSaldoDiarioRetiroParcial(soap, (ns2__ConsultaSaldoDiarioRetiroParcial *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SaldoDiarioRetiroParcial:
		soap_serialize_PointerTons2__SaldoDiarioRetiroParcial(soap, (ns2__SaldoDiarioRetiroParcial *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ConvivenciaMarcas:
		soap_serialize_PointerTons2__ConvivenciaMarcas(soap, (ns2__ConvivenciaMarcas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespuestaConvivenciaMarca:
		soap_serialize_PointerTons2__RespuestaConvivenciaMarca(soap, (ns2__RespuestaConvivenciaMarca *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FoliadorServicio:
		soap_serialize_PointerTons2__FoliadorServicio(soap, (ns2__FoliadorServicio *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FolioServicio:
		soap_serialize_PointerTons2__FolioServicio(soap, (ns2__FolioServicio *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParametroNss:
		soap_serialize_PointerTons2__ParametroNss(soap, (ns2__ParametroNss *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SaldoPorSubcuenta:
		soap_serialize_PointerTons2__SaldoPorSubcuenta(soap, (ns2__SaldoPorSubcuenta *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ParamConsultarAfiliado:
		soap_serialize_PointerTons2__ParamConsultarAfiliado(soap, (ns2__ParamConsultarAfiliado *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__RespConsultarAfiliado:
		soap_serialize_PointerTons2__RespConsultarAfiliado(soap, (ns2__RespConsultarAfiliado *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__DatosCtaSaldoVol:
		soap_serialize_PointerToPointerTons2__DatosCtaSaldoVol(soap, (ns2__DatosCtaSaldoVol **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DatosCtaSaldoVol:
		soap_serialize_PointerTons2__DatosCtaSaldoVol(soap, (ns2__DatosCtaSaldoVol *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__SieforeCtaRegimen:
		soap_serialize_PointerToPointerTons2__SieforeCtaRegimen(soap, (ns2__SieforeCtaRegimen **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SieforeCtaRegimen:
		soap_serialize_PointerTons2__SieforeCtaRegimen(soap, (ns2__SieforeCtaRegimen *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons2__SaldoSubCuenta:
		soap_serialize_PointerToPointerTons2__SaldoSubCuenta(soap, (ns2__SaldoSubCuenta **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SaldoSubCuenta:
		soap_serialize_PointerTons2__SaldoSubCuenta(soap, (ns2__SaldoSubCuenta *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__NumMensualidad:
		soap_serialize_PointerTons2__NumMensualidad(soap, (ns2__NumMensualidad *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__FechaLiquida:
		soap_serialize_PointerTons2__FechaLiquida(soap, (ns2__FechaLiquida *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SaldoRecuperar:
		soap_serialize_PointerTons2__SaldoRecuperar(soap, (ns2__SaldoRecuperar *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ConsultarSaldoVivienda:
		soap_serialize_PointerTons2__ConsultarSaldoVivienda(soap, (ns2__ConsultarSaldoVivienda *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfDatosCtaSaldoVol:
		soap_serialize_PointerToArrayOfDatosCtaSaldoVol(soap, (ArrayOfDatosCtaSaldoVol *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfSieforeCtaRegimen:
		soap_serialize_PointerToArrayOfSieforeCtaRegimen(soap, (ArrayOfSieforeCtaRegimen *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__AportacionesPosteriores:
		soap_serialize_PointerTons2__AportacionesPosteriores(soap, (ns2__AportacionesPosteriores *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ResolucionTotalIssste:
		soap_serialize_PointerTons2__ResolucionTotalIssste(soap, (ns2__ResolucionTotalIssste *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MovimientosCuentas:
		soap_serialize_PointerTons2__MovimientosCuentas(soap, (ns2__MovimientosCuentas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ResolucionOperacionPmg:
		soap_serialize_PointerTons2__ResolucionOperacionPmg(soap, (ns2__ResolucionOperacionPmg *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ResolucionTotalImss:
		soap_serialize_PointerTons2__ResolucionTotalImss(soap, (ns2__ResolucionTotalImss *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ComplementoResolucion:
		soap_serialize_PointerTons2__ComplementoResolucion(soap, (ns2__ComplementoResolucion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__DatosResolucion:
		soap_serialize_PointerTons2__DatosResolucion(soap, (ns2__DatosResolucion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__MontosFechasDatamart:
		soap_serialize_PointerTons2__MontosFechasDatamart(soap, (ns2__MontosFechasDatamart *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ValidarResolucionImss:
		soap_serialize_PointerTons2__ValidarResolucionImss(soap, (ns2__ValidarResolucionImss *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__TipoSolicitante:
		soap_serialize_PointerTons2__TipoSolicitante(soap, (ns2__TipoSolicitante *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__ValidaConvivenciaMarcas:
		soap_serialize_PointerTons2__ValidaConvivenciaMarcas(soap, (ns2__ValidaConvivenciaMarcas *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__SaldosCuentasPmg:
		soap_serialize_PointerTons2__SaldosCuentasPmg(soap, (ns2__SaldosCuentasPmg *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfSaldoSubCuenta:
		soap_serialize_PointerToArrayOfSaldoSubCuenta(soap, (ArrayOfSaldoSubCuenta *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__EstadoProceso:
		soap_serialize_PointerTons2__EstadoProceso(soap, (ns2__EstadoProceso *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons2__Afiliado:
		soap_serialize_PointerTons2__Afiliado(soap, (ns2__Afiliado *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_ns2__EstadoProceso:
		return (void*)soap_instantiate_ns2__EstadoProceso(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParamConsultarAfiliado:
		return (void*)soap_instantiate_ns2__ParamConsultarAfiliado(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParametroNss:
		return (void*)soap_instantiate_ns2__ParametroNss(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParametroSaldoPmg:
		return (void*)soap_instantiate_ns2__ParametroSaldoPmg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParametroNssTipoRetiro:
		return (void*)soap_instantiate_ns2__ParametroNssTipoRetiro(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__Afiliado:
		return (void*)soap_instantiate_ns2__Afiliado(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespConsultarAfiliado:
		return (void*)soap_instantiate_ns2__RespConsultarAfiliado(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SaldoSubCuenta:
		return (void*)soap_instantiate_ns2__SaldoSubCuenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SaldoPorSubcuenta:
		return (void*)soap_instantiate_ns2__SaldoPorSubcuenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SaldosCuentasPmg:
		return (void*)soap_instantiate_ns2__SaldosCuentasPmg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SaldoPorSubcuentaPmg:
		return (void*)soap_instantiate_ns2__SaldoPorSubcuentaPmg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FoliadorServicio:
		return (void*)soap_instantiate_ns2__FoliadorServicio(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FolioServicio:
		return (void*)soap_instantiate_ns2__FolioServicio(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConvivenciaMarcas:
		return (void*)soap_instantiate_ns2__ConvivenciaMarcas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValidaConvivenciaMarcas:
		return (void*)soap_instantiate_ns2__ValidaConvivenciaMarcas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaConvivenciaMarca:
		return (void*)soap_instantiate_ns2__RespuestaConvivenciaMarca(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__TipoSolicitante:
		return (void*)soap_instantiate_ns2__TipoSolicitante(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaTipoSolicitante:
		return (void*)soap_instantiate_ns2__RespuestaTipoSolicitante(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial:
		return (void*)soap_instantiate_ns2__ConsultaSaldoDiarioRetiroParcial(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SaldoDiarioRetiroParcial:
		return (void*)soap_instantiate_ns2__SaldoDiarioRetiroParcial(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValidarResolucionImss:
		return (void*)soap_instantiate_ns2__ValidarResolucionImss(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaValidarResolucionImss:
		return (void*)soap_instantiate_ns2__RespuestaValidarResolucionImss(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MontosFechasDatamart:
		return (void*)soap_instantiate_ns2__MontosFechasDatamart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaMontosFechasDatamart:
		return (void*)soap_instantiate_ns2__RespuestaMontosFechasDatamart(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DatosResolucion:
		return (void*)soap_instantiate_ns2__DatosResolucion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaDatosResolucion:
		return (void*)soap_instantiate_ns2__RespuestaDatosResolucion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ComplementoResolucion:
		return (void*)soap_instantiate_ns2__ComplementoResolucion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaComplementoResolucion:
		return (void*)soap_instantiate_ns2__RespuestaComplementoResolucion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParamResolucionTotalImss:
		return (void*)soap_instantiate_ns2__ParamResolucionTotalImss(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParamResolucionTotalImssRI:
		return (void*)soap_instantiate_ns2__ParamResolucionTotalImssRI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ResolucionTotalImss:
		return (void*)soap_instantiate_ns2__ResolucionTotalImss(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaResolucionTotalImss:
		return (void*)soap_instantiate_ns2__RespuestaResolucionTotalImss(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParamOperacionPmgImss:
		return (void*)soap_instantiate_ns2__ParamOperacionPmgImss(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ResolucionOperacionPmg:
		return (void*)soap_instantiate_ns2__ResolucionOperacionPmg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss:
		return (void*)soap_instantiate_ns2__RespuestaCOperacionesPmgImss(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParamMovimientosCuentas:
		return (void*)soap_instantiate_ns2__ParamMovimientosCuentas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MovimientosCuentas:
		return (void*)soap_instantiate_ns2__MovimientosCuentas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaMovimientosCuentas:
		return (void*)soap_instantiate_ns2__RespuestaMovimientosCuentas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParamResolucionTotalIssste:
		return (void*)soap_instantiate_ns2__ParamResolucionTotalIssste(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ResolucionTotalIssste:
		return (void*)soap_instantiate_ns2__ResolucionTotalIssste(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaResolucionTotalIssste:
		return (void*)soap_instantiate_ns2__RespuestaResolucionTotalIssste(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParamAportacionesPosteriores:
		return (void*)soap_instantiate_ns2__ParamAportacionesPosteriores(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__AportacionesPosteriores:
		return (void*)soap_instantiate_ns2__AportacionesPosteriores(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaAportacionesPosteriores:
		return (void*)soap_instantiate_ns2__RespuestaAportacionesPosteriores(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParamNssCtaRegimen:
		return (void*)soap_instantiate_ns2__ParamNssCtaRegimen(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SieforeCtaRegimen:
		return (void*)soap_instantiate_ns2__SieforeCtaRegimen(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen:
		return (void*)soap_instantiate_ns2__RespuestaSieforeCtaRegimen(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParamNssCtaSaldoVol:
		return (void*)soap_instantiate_ns2__ParamNssCtaSaldoVol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__DatosCtaSaldoVol:
		return (void*)soap_instantiate_ns2__DatosCtaSaldoVol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaCtaSaldoVol:
		return (void*)soap_instantiate_ns2__RespuestaCtaSaldoVol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParamConsultaSaldoVivienda:
		return (void*)soap_instantiate_ns2__ParamConsultaSaldoVivienda(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarSaldoVivienda:
		return (void*)soap_instantiate_ns2__ConsultarSaldoVivienda(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda:
		return (void*)soap_instantiate_ns2__RespuestaConsultaSaldoVivienda(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParametroAportacionesPost:
		return (void*)soap_instantiate_ns2__ParametroAportacionesPost(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ParametroCurpNss:
		return (void*)soap_instantiate_ns2__ParametroCurpNss(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__SaldoRecuperar:
		return (void*)soap_instantiate_ns2__SaldoRecuperar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaSaldoRecuperar:
		return (void*)soap_instantiate_ns2__RespuestaSaldoRecuperar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__FechaLiquida:
		return (void*)soap_instantiate_ns2__FechaLiquida(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaFechaLiquida:
		return (void*)soap_instantiate_ns2__RespuestaFechaLiquida(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__NumMensualidad:
		return (void*)soap_instantiate_ns2__NumMensualidad(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__RespuestaMensualidad:
		return (void*)soap_instantiate_ns2__RespuestaMensualidad(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfSaldoSubCuenta:
		return (void*)soap_instantiate_ArrayOfSaldoSubCuenta(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfSieforeCtaRegimen:
		return (void*)soap_instantiate_ArrayOfSieforeCtaRegimen(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfDatosCtaSaldoVol:
		return (void*)soap_instantiate_ArrayOfDatosCtaSaldoVol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__consultarAfiliadoResponse:
		return (void*)soap_instantiate_ns2__consultarAfiliadoResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__consultarAfiliado:
		return (void*)soap_instantiate_ns2__consultarAfiliado(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__consultarSaldosResponse:
		return (void*)soap_instantiate_ns2__consultarSaldosResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__consultarSaldos:
		return (void*)soap_instantiate_ns2__consultarSaldos(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ObtenerFolioServicioResponse:
		return (void*)soap_instantiate_ns2__ObtenerFolioServicioResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ObtenerFolioServicio:
		return (void*)soap_instantiate_ns2__ObtenerFolioServicio(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativaResponse:
		return (void*)soap_instantiate_ns2__ValidarConvivenciaMarcaOperativaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativa:
		return (void*)soap_instantiate_ns2__ValidarConvivenciaMarcaOperativa(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcialResponse:
		return (void*)soap_instantiate_ns2__ObtenerSaldoDiarioRetiroParcialResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcial:
		return (void*)soap_instantiate_ns2__ObtenerSaldoDiarioRetiroParcial(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValidarResolucionImssResponse:
		return (void*)soap_instantiate_ns2__ValidarResolucionImssResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ValidarResolucionImss_:
		return (void*)soap_instantiate_ns2__ValidarResolucionImss_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MontosFechasDatamartResponse:
		return (void*)soap_instantiate_ns2__MontosFechasDatamartResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__MontosFechasDatamart_:
		return (void*)soap_instantiate_ns2__MontosFechasDatamart_(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__consultarResolucionResponse:
		return (void*)soap_instantiate_ns2__consultarResolucionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__consultarResolucion:
		return (void*)soap_instantiate_ns2__consultarResolucion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarComplementoResolucionResponse:
		return (void*)soap_instantiate_ns2__ConsultarComplementoResolucionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarComplementoResolucion:
		return (void*)soap_instantiate_ns2__ConsultarComplementoResolucion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssResponse:
		return (void*)soap_instantiate_ns2__ConsultarResolucionTotalImssResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImss:
		return (void*)soap_instantiate_ns2__ConsultarResolucionTotalImss(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__COperacionesPmgResponse:
		return (void*)soap_instantiate_ns2__COperacionesPmgResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__COperacionesPmg:
		return (void*)soap_instantiate_ns2__COperacionesPmg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__movimientosCuentasResponse:
		return (void*)soap_instantiate_ns2__movimientosCuentasResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__movimientosCuentas:
		return (void*)soap_instantiate_ns2__movimientosCuentas(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarResolucionTotalIsssteResponse:
		return (void*)soap_instantiate_ns2__ConsultarResolucionTotalIsssteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarResolucionTotalIssste:
		return (void*)soap_instantiate_ns2__ConsultarResolucionTotalIssste(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__consultarSaldosPmgResponse:
		return (void*)soap_instantiate_ns2__consultarSaldosPmgResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__consultarSaldosPmg:
		return (void*)soap_instantiate_ns2__consultarSaldosPmg(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__consultarAportacionesResponse:
		return (void*)soap_instantiate_ns2__consultarAportacionesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__consultarAportaciones:
		return (void*)soap_instantiate_ns2__consultarAportaciones(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssRIResponse:
		return (void*)soap_instantiate_ns2__ConsultarResolucionTotalImssRIResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssRI:
		return (void*)soap_instantiate_ns2__ConsultarResolucionTotalImssRI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarSieforeCtaRegimenResponse:
		return (void*)soap_instantiate_ns2__ConsultarSieforeCtaRegimenResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarSieforeCtaRegimen:
		return (void*)soap_instantiate_ns2__ConsultarSieforeCtaRegimen(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarSaldoVolResponse:
		return (void*)soap_instantiate_ns2__ConsultarSaldoVolResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultarSaldoVol:
		return (void*)soap_instantiate_ns2__ConsultarSaldoVol(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultaSaldoViviendaResponse:
		return (void*)soap_instantiate_ns2__ConsultaSaldoViviendaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultaSaldoVivienda:
		return (void*)soap_instantiate_ns2__ConsultaSaldoVivienda(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultaAportacionesPosterioresResponse:
		return (void*)soap_instantiate_ns2__ConsultaAportacionesPosterioresResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__ConsultaAportacionesPosteriores:
		return (void*)soap_instantiate_ns2__ConsultaAportacionesPosteriores(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CConsultarResolusionRetAportacionesResponse:
		return (void*)soap_instantiate_ns2__CConsultarResolusionRetAportacionesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CConsultarResolusionRetAportaciones:
		return (void*)soap_instantiate_ns2__CConsultarResolusionRetAportaciones(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CConsultarSaldoRecuperarResponse:
		return (void*)soap_instantiate_ns2__CConsultarSaldoRecuperarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CConsultarSaldoRecuperar:
		return (void*)soap_instantiate_ns2__CConsultarSaldoRecuperar(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CConsultarFechaLiquidaResponse:
		return (void*)soap_instantiate_ns2__CConsultarFechaLiquidaResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CConsultarFechaLiquida:
		return (void*)soap_instantiate_ns2__CConsultarFechaLiquida(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CConsultarNumMensualidadResponse:
		return (void*)soap_instantiate_ns2__CConsultarNumMensualidadResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__CConsultarNumMensualidad:
		return (void*)soap_instantiate_ns2__CConsultarNumMensualidad(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__consultarSaldosPenMinGarResponse:
		return (void*)soap_instantiate_ns2__consultarSaldosPenMinGarResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns2__consultarSaldosPenMinGar:
		return (void*)soap_instantiate_ns2__consultarSaldosPenMinGar(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns2__EstadoProceso:
		if (p->size < 0)
			SOAP_DELETE((ns2__EstadoProceso*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__EstadoProceso*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParamConsultarAfiliado:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParamConsultarAfiliado*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParamConsultarAfiliado*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParametroNss:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParametroNss*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParametroNss*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParametroSaldoPmg:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParametroSaldoPmg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParametroSaldoPmg*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParametroNssTipoRetiro:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParametroNssTipoRetiro*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParametroNssTipoRetiro*)p->ptr);
		break;
	case SOAP_TYPE_ns2__Afiliado:
		if (p->size < 0)
			SOAP_DELETE((ns2__Afiliado*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__Afiliado*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespConsultarAfiliado:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespConsultarAfiliado*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespConsultarAfiliado*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SaldoSubCuenta:
		if (p->size < 0)
			SOAP_DELETE((ns2__SaldoSubCuenta*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SaldoSubCuenta*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SaldoPorSubcuenta:
		if (p->size < 0)
			SOAP_DELETE((ns2__SaldoPorSubcuenta*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SaldoPorSubcuenta*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SaldosCuentasPmg:
		if (p->size < 0)
			SOAP_DELETE((ns2__SaldosCuentasPmg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SaldosCuentasPmg*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SaldoPorSubcuentaPmg:
		if (p->size < 0)
			SOAP_DELETE((ns2__SaldoPorSubcuentaPmg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SaldoPorSubcuentaPmg*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FoliadorServicio:
		if (p->size < 0)
			SOAP_DELETE((ns2__FoliadorServicio*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FoliadorServicio*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FolioServicio:
		if (p->size < 0)
			SOAP_DELETE((ns2__FolioServicio*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FolioServicio*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConvivenciaMarcas:
		if (p->size < 0)
			SOAP_DELETE((ns2__ConvivenciaMarcas*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ConvivenciaMarcas*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValidaConvivenciaMarcas:
		if (p->size < 0)
			SOAP_DELETE((ns2__ValidaConvivenciaMarcas*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ValidaConvivenciaMarcas*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaConvivenciaMarca:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaConvivenciaMarca*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaConvivenciaMarca*)p->ptr);
		break;
	case SOAP_TYPE_ns2__TipoSolicitante:
		if (p->size < 0)
			SOAP_DELETE((ns2__TipoSolicitante*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__TipoSolicitante*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaTipoSolicitante:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaTipoSolicitante*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaTipoSolicitante*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial:
		if (p->size < 0)
			SOAP_DELETE((ns2__ConsultaSaldoDiarioRetiroParcial*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ConsultaSaldoDiarioRetiroParcial*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SaldoDiarioRetiroParcial:
		if (p->size < 0)
			SOAP_DELETE((ns2__SaldoDiarioRetiroParcial*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SaldoDiarioRetiroParcial*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValidarResolucionImss:
		if (p->size < 0)
			SOAP_DELETE((ns2__ValidarResolucionImss*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ValidarResolucionImss*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaValidarResolucionImss:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaValidarResolucionImss*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaValidarResolucionImss*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MontosFechasDatamart:
		if (p->size < 0)
			SOAP_DELETE((ns2__MontosFechasDatamart*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MontosFechasDatamart*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaMontosFechasDatamart:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaMontosFechasDatamart*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaMontosFechasDatamart*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DatosResolucion:
		if (p->size < 0)
			SOAP_DELETE((ns2__DatosResolucion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DatosResolucion*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaDatosResolucion:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaDatosResolucion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaDatosResolucion*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ComplementoResolucion:
		if (p->size < 0)
			SOAP_DELETE((ns2__ComplementoResolucion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ComplementoResolucion*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaComplementoResolucion:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaComplementoResolucion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaComplementoResolucion*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParamResolucionTotalImss:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParamResolucionTotalImss*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParamResolucionTotalImss*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParamResolucionTotalImssRI:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParamResolucionTotalImssRI*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParamResolucionTotalImssRI*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ResolucionTotalImss:
		if (p->size < 0)
			SOAP_DELETE((ns2__ResolucionTotalImss*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ResolucionTotalImss*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaResolucionTotalImss:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaResolucionTotalImss*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaResolucionTotalImss*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParamOperacionPmgImss:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParamOperacionPmgImss*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParamOperacionPmgImss*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ResolucionOperacionPmg:
		if (p->size < 0)
			SOAP_DELETE((ns2__ResolucionOperacionPmg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ResolucionOperacionPmg*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaCOperacionesPmgImss*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaCOperacionesPmgImss*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParamMovimientosCuentas:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParamMovimientosCuentas*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParamMovimientosCuentas*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MovimientosCuentas:
		if (p->size < 0)
			SOAP_DELETE((ns2__MovimientosCuentas*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__MovimientosCuentas*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaMovimientosCuentas:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaMovimientosCuentas*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaMovimientosCuentas*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParamResolucionTotalIssste:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParamResolucionTotalIssste*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParamResolucionTotalIssste*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ResolucionTotalIssste:
		if (p->size < 0)
			SOAP_DELETE((ns2__ResolucionTotalIssste*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ResolucionTotalIssste*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaResolucionTotalIssste:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaResolucionTotalIssste*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaResolucionTotalIssste*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParamAportacionesPosteriores:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParamAportacionesPosteriores*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParamAportacionesPosteriores*)p->ptr);
		break;
	case SOAP_TYPE_ns2__AportacionesPosteriores:
		if (p->size < 0)
			SOAP_DELETE((ns2__AportacionesPosteriores*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__AportacionesPosteriores*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaAportacionesPosteriores:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaAportacionesPosteriores*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaAportacionesPosteriores*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParamNssCtaRegimen:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParamNssCtaRegimen*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParamNssCtaRegimen*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SieforeCtaRegimen:
		if (p->size < 0)
			SOAP_DELETE((ns2__SieforeCtaRegimen*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SieforeCtaRegimen*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaSieforeCtaRegimen*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaSieforeCtaRegimen*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParamNssCtaSaldoVol:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParamNssCtaSaldoVol*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParamNssCtaSaldoVol*)p->ptr);
		break;
	case SOAP_TYPE_ns2__DatosCtaSaldoVol:
		if (p->size < 0)
			SOAP_DELETE((ns2__DatosCtaSaldoVol*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__DatosCtaSaldoVol*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaCtaSaldoVol:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaCtaSaldoVol*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaCtaSaldoVol*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParamConsultaSaldoVivienda:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParamConsultaSaldoVivienda*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParamConsultaSaldoVivienda*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarSaldoVivienda:
		if (p->size < 0)
			SOAP_DELETE((ns2__ConsultarSaldoVivienda*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ConsultarSaldoVivienda*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaConsultaSaldoVivienda*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaConsultaSaldoVivienda*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParametroAportacionesPost:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParametroAportacionesPost*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParametroAportacionesPost*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ParametroCurpNss:
		if (p->size < 0)
			SOAP_DELETE((ns2__ParametroCurpNss*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__ParametroCurpNss*)p->ptr);
		break;
	case SOAP_TYPE_ns2__SaldoRecuperar:
		if (p->size < 0)
			SOAP_DELETE((ns2__SaldoRecuperar*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__SaldoRecuperar*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaSaldoRecuperar:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaSaldoRecuperar*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaSaldoRecuperar*)p->ptr);
		break;
	case SOAP_TYPE_ns2__FechaLiquida:
		if (p->size < 0)
			SOAP_DELETE((ns2__FechaLiquida*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__FechaLiquida*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaFechaLiquida:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaFechaLiquida*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaFechaLiquida*)p->ptr);
		break;
	case SOAP_TYPE_ns2__NumMensualidad:
		if (p->size < 0)
			SOAP_DELETE((ns2__NumMensualidad*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__NumMensualidad*)p->ptr);
		break;
	case SOAP_TYPE_ns2__RespuestaMensualidad:
		if (p->size < 0)
			SOAP_DELETE((ns2__RespuestaMensualidad*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns2__RespuestaMensualidad*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfSaldoSubCuenta:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfSaldoSubCuenta*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfSaldoSubCuenta*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfSieforeCtaRegimen:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfSieforeCtaRegimen*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfSieforeCtaRegimen*)p->ptr);
		break;
	case SOAP_TYPE_ArrayOfDatosCtaSaldoVol:
		if (p->size < 0)
			SOAP_DELETE((ArrayOfDatosCtaSaldoVol*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ArrayOfDatosCtaSaldoVol*)p->ptr);
		break;
	case SOAP_TYPE_ns2__consultarAfiliadoResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__consultarAfiliadoResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__consultarAfiliadoResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__consultarAfiliado:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__consultarAfiliado*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__consultarAfiliado*)p->ptr);
		break;
	case SOAP_TYPE_ns2__consultarSaldosResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__consultarSaldosResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__consultarSaldosResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__consultarSaldos:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__consultarSaldos*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__consultarSaldos*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ObtenerFolioServicioResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ObtenerFolioServicioResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ObtenerFolioServicioResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ObtenerFolioServicio:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ObtenerFolioServicio*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ObtenerFolioServicio*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativaResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ValidarConvivenciaMarcaOperativaResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ValidarConvivenciaMarcaOperativaResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativa:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ValidarConvivenciaMarcaOperativa*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ValidarConvivenciaMarcaOperativa*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcialResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ObtenerSaldoDiarioRetiroParcialResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ObtenerSaldoDiarioRetiroParcialResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcial:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ObtenerSaldoDiarioRetiroParcial*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ObtenerSaldoDiarioRetiroParcial*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValidarResolucionImssResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ValidarResolucionImssResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ValidarResolucionImssResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ValidarResolucionImss_:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ValidarResolucionImss_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ValidarResolucionImss_*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MontosFechasDatamartResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__MontosFechasDatamartResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__MontosFechasDatamartResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__MontosFechasDatamart_:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__MontosFechasDatamart_*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__MontosFechasDatamart_*)p->ptr);
		break;
	case SOAP_TYPE_ns2__consultarResolucionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__consultarResolucionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__consultarResolucionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__consultarResolucion:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__consultarResolucion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__consultarResolucion*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarComplementoResolucionResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultarComplementoResolucionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultarComplementoResolucionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarComplementoResolucion:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultarComplementoResolucion*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultarComplementoResolucion*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultarResolucionTotalImssResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultarResolucionTotalImssResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImss:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultarResolucionTotalImss*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultarResolucionTotalImss*)p->ptr);
		break;
	case SOAP_TYPE_ns2__COperacionesPmgResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__COperacionesPmgResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__COperacionesPmgResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__COperacionesPmg:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__COperacionesPmg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__COperacionesPmg*)p->ptr);
		break;
	case SOAP_TYPE_ns2__movimientosCuentasResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__movimientosCuentasResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__movimientosCuentasResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__movimientosCuentas:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__movimientosCuentas*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__movimientosCuentas*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarResolucionTotalIsssteResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultarResolucionTotalIsssteResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultarResolucionTotalIsssteResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarResolucionTotalIssste:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultarResolucionTotalIssste*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultarResolucionTotalIssste*)p->ptr);
		break;
	case SOAP_TYPE_ns2__consultarSaldosPmgResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__consultarSaldosPmgResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__consultarSaldosPmgResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__consultarSaldosPmg:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__consultarSaldosPmg*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__consultarSaldosPmg*)p->ptr);
		break;
	case SOAP_TYPE_ns2__consultarAportacionesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__consultarAportacionesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__consultarAportacionesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__consultarAportaciones:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__consultarAportaciones*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__consultarAportaciones*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssRIResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultarResolucionTotalImssRIResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultarResolucionTotalImssRIResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarResolucionTotalImssRI:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultarResolucionTotalImssRI*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultarResolucionTotalImssRI*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarSieforeCtaRegimenResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultarSieforeCtaRegimenResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultarSieforeCtaRegimenResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarSieforeCtaRegimen:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultarSieforeCtaRegimen*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultarSieforeCtaRegimen*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarSaldoVolResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultarSaldoVolResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultarSaldoVolResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultarSaldoVol:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultarSaldoVol*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultarSaldoVol*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultaSaldoViviendaResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultaSaldoViviendaResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultaSaldoViviendaResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultaSaldoVivienda:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultaSaldoVivienda*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultaSaldoVivienda*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultaAportacionesPosterioresResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultaAportacionesPosterioresResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultaAportacionesPosterioresResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__ConsultaAportacionesPosteriores:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__ConsultaAportacionesPosteriores*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__ConsultaAportacionesPosteriores*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarResolusionRetAportacionesResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__CConsultarResolusionRetAportacionesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__CConsultarResolusionRetAportacionesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarResolusionRetAportaciones:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__CConsultarResolusionRetAportaciones*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__CConsultarResolusionRetAportaciones*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarSaldoRecuperarResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__CConsultarSaldoRecuperarResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__CConsultarSaldoRecuperarResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarSaldoRecuperar:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__CConsultarSaldoRecuperar*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__CConsultarSaldoRecuperar*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarFechaLiquidaResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__CConsultarFechaLiquidaResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__CConsultarFechaLiquidaResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarFechaLiquida:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__CConsultarFechaLiquida*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__CConsultarFechaLiquida*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarNumMensualidadResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__CConsultarNumMensualidadResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__CConsultarNumMensualidadResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__CConsultarNumMensualidad:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__CConsultarNumMensualidad*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__CConsultarNumMensualidad*)p->ptr);
		break;
	case SOAP_TYPE_ns2__consultarSaldosPenMinGarResponse:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__consultarSaldosPenMinGarResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__consultarSaldosPenMinGarResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns2__consultarSaldosPenMinGar:
		if (p->size < 0)
			SOAP_DELETE((struct ns2__consultarSaldosPenMinGar*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct ns2__consultarSaldosPenMinGar*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{	short *p;
	p = soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag?tag:"short", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TipoRetiroParcial(struct soap *soap, enum ns2__TipoRetiroParcial *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__TipoRetiroParcial
	*a = SOAP_DEFAULT_ns2__TipoRetiroParcial;
#else
	*a = (enum ns2__TipoRetiroParcial)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__TipoRetiroParcial[] =
{	{ (long)ns2__TipoRetiroParcial__Desempleo, "Desempleo" },
	{ (long)ns2__TipoRetiroParcial__Matrimonio, "Matrimonio" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__TipoRetiroParcial2s(struct soap *soap, enum ns2__TipoRetiroParcial n)
{	const char *s = soap_code_str(soap_codes_ns2__TipoRetiroParcial, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TipoRetiroParcial(struct soap *soap, const char *tag, int id, const enum ns2__TipoRetiroParcial *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TipoRetiroParcial), type) || soap_send(soap, soap_ns2__TipoRetiroParcial2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__TipoRetiroParcial(struct soap *soap, const char *s, enum ns2__TipoRetiroParcial *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__TipoRetiroParcial, s);
	if (map)
		*a = (enum ns2__TipoRetiroParcial)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__TipoRetiroParcial)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__TipoRetiroParcial * SOAP_FMAC4 soap_in_ns2__TipoRetiroParcial(struct soap *soap, const char *tag, enum ns2__TipoRetiroParcial *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__TipoRetiroParcial *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TipoRetiroParcial, sizeof(enum ns2__TipoRetiroParcial), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__TipoRetiroParcial(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__TipoRetiroParcial *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TipoRetiroParcial, 0, sizeof(enum ns2__TipoRetiroParcial), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TipoRetiroParcial(struct soap *soap, const enum ns2__TipoRetiroParcial *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__TipoRetiroParcial);
	if (soap_out_ns2__TipoRetiroParcial(soap, tag?tag:"ns2:TipoRetiroParcial", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__TipoRetiroParcial * SOAP_FMAC4 soap_get_ns2__TipoRetiroParcial(struct soap *soap, enum ns2__TipoRetiroParcial *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TipoRetiroParcial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__TipoTrabajador(struct soap *soap, enum ns2__TipoTrabajador *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__TipoTrabajador
	*a = SOAP_DEFAULT_ns2__TipoTrabajador;
#else
	*a = (enum ns2__TipoTrabajador)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__TipoTrabajador[] =
{	{ (long)ns2__TipoTrabajador__Imss, "Imss" },
	{ (long)ns2__TipoTrabajador__Issste, "Issste" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__TipoTrabajador2s(struct soap *soap, enum ns2__TipoTrabajador n)
{	const char *s = soap_code_str(soap_codes_ns2__TipoTrabajador, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TipoTrabajador(struct soap *soap, const char *tag, int id, const enum ns2__TipoTrabajador *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TipoTrabajador), type) || soap_send(soap, soap_ns2__TipoTrabajador2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__TipoTrabajador(struct soap *soap, const char *s, enum ns2__TipoTrabajador *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__TipoTrabajador, s);
	if (map)
		*a = (enum ns2__TipoTrabajador)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__TipoTrabajador)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__TipoTrabajador * SOAP_FMAC4 soap_in_ns2__TipoTrabajador(struct soap *soap, const char *tag, enum ns2__TipoTrabajador *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__TipoTrabajador *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TipoTrabajador, sizeof(enum ns2__TipoTrabajador), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__TipoTrabajador(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__TipoTrabajador *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TipoTrabajador, 0, sizeof(enum ns2__TipoTrabajador), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__TipoTrabajador(struct soap *soap, const enum ns2__TipoTrabajador *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__TipoTrabajador);
	if (soap_out_ns2__TipoTrabajador(soap, tag?tag:"ns2:TipoTrabajador", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__TipoTrabajador * SOAP_FMAC4 soap_get_ns2__TipoTrabajador(struct soap *soap, enum ns2__TipoTrabajador *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TipoTrabajador(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ClasificacionServicio(struct soap *soap, enum ns2__ClasificacionServicio *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns2__ClasificacionServicio
	*a = SOAP_DEFAULT_ns2__ClasificacionServicio;
#else
	*a = (enum ns2__ClasificacionServicio)0;
#endif
}

static const struct soap_code_map soap_codes_ns2__ClasificacionServicio[] =
{	{ (long)ns2__ClasificacionServicio__O, "O" },
	{ (long)ns2__ClasificacionServicio__A, "A" },
	{ (long)ns2__ClasificacionServicio__C, "C" },
	{ (long)ns2__ClasificacionServicio__N, "N" },
	{ (long)ns2__ClasificacionServicio__P, "P" },
	{ (long)ns2__ClasificacionServicio__Q, "Q" },
	{ (long)ns2__ClasificacionServicio__S, "S" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns2__ClasificacionServicio2s(struct soap *soap, enum ns2__ClasificacionServicio n)
{	const char *s = soap_code_str(soap_codes_ns2__ClasificacionServicio, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ClasificacionServicio(struct soap *soap, const char *tag, int id, const enum ns2__ClasificacionServicio *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ClasificacionServicio), type) || soap_send(soap, soap_ns2__ClasificacionServicio2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns2__ClasificacionServicio(struct soap *soap, const char *s, enum ns2__ClasificacionServicio *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns2__ClasificacionServicio, s);
	if (map)
		*a = (enum ns2__ClasificacionServicio)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns2__ClasificacionServicio)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns2__ClasificacionServicio * SOAP_FMAC4 soap_in_ns2__ClasificacionServicio(struct soap *soap, const char *tag, enum ns2__ClasificacionServicio *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns2__ClasificacionServicio *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ClasificacionServicio, sizeof(enum ns2__ClasificacionServicio), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns2__ClasificacionServicio(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns2__ClasificacionServicio *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ClasificacionServicio, 0, sizeof(enum ns2__ClasificacionServicio), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ClasificacionServicio(struct soap *soap, const enum ns2__ClasificacionServicio *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ClasificacionServicio);
	if (soap_out_ns2__ClasificacionServicio(soap, tag?tag:"ns2:ClasificacionServicio", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns2__ClasificacionServicio * SOAP_FMAC4 soap_get_ns2__ClasificacionServicio(struct soap *soap, enum ns2__ClasificacionServicio *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ClasificacionServicio(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns2__RespuestaMensualidad::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaMensualidad::EstadoProc = NULL;
	this->ns2__RespuestaMensualidad::Mensualidad = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaMensualidad::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaMensualidad::EstadoProc);
	soap_serialize_PointerTons2__NumMensualidad(soap, &this->ns2__RespuestaMensualidad::Mensualidad);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaMensualidad::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaMensualidad(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaMensualidad(struct soap *soap, const char *tag, int id, const ns2__RespuestaMensualidad *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaMensualidad), type))
		return soap->error;
	if (a->ns2__RespuestaMensualidad::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaMensualidad::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaMensualidad::Mensualidad)
	{	if (soap_out_PointerTons2__NumMensualidad(soap, "Mensualidad", -1, &a->ns2__RespuestaMensualidad::Mensualidad, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Mensualidad"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaMensualidad::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaMensualidad(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaMensualidad * SOAP_FMAC4 soap_in_ns2__RespuestaMensualidad(struct soap *soap, const char *tag, ns2__RespuestaMensualidad *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaMensualidad *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaMensualidad, sizeof(ns2__RespuestaMensualidad), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaMensualidad)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaMensualidad *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_Mensualidad1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaMensualidad::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_Mensualidad1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__NumMensualidad(soap, "Mensualidad", &(a->ns2__RespuestaMensualidad::Mensualidad), "ns2:NumMensualidad"))
				{	soap_flag_Mensualidad1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaMensualidad *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaMensualidad, 0, sizeof(ns2__RespuestaMensualidad), 0, soap_copy_ns2__RespuestaMensualidad);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_Mensualidad1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaMensualidad::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaMensualidad);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaMensualidad", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaMensualidad::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaMensualidad(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaMensualidad * SOAP_FMAC4 soap_get_ns2__RespuestaMensualidad(struct soap *soap, ns2__RespuestaMensualidad *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaMensualidad(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaMensualidad * SOAP_FMAC2 soap_instantiate_ns2__RespuestaMensualidad(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaMensualidad(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaMensualidad, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaMensualidad);
		if (size)
			*size = sizeof(ns2__RespuestaMensualidad);
		((ns2__RespuestaMensualidad*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaMensualidad, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaMensualidad);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaMensualidad*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaMensualidad*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaMensualidad(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaMensualidad %p -> %p\n", q, p));
	*(ns2__RespuestaMensualidad*)p = *(ns2__RespuestaMensualidad*)q;
}

void ns2__NumMensualidad::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__NumMensualidad::iRespuestaMensualidad);
	/* transient soap skipped */
}

void ns2__NumMensualidad::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns2__NumMensualidad::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__NumMensualidad(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__NumMensualidad(struct soap *soap, const char *tag, int id, const ns2__NumMensualidad *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__NumMensualidad), type))
		return soap->error;
	if (soap_out_int(soap, "iRespuestaMensualidad", -1, &(a->ns2__NumMensualidad::iRespuestaMensualidad), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__NumMensualidad::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__NumMensualidad(soap, tag, this, type);
}

SOAP_FMAC3 ns2__NumMensualidad * SOAP_FMAC4 soap_in_ns2__NumMensualidad(struct soap *soap, const char *tag, ns2__NumMensualidad *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__NumMensualidad *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__NumMensualidad, sizeof(ns2__NumMensualidad), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__NumMensualidad)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__NumMensualidad *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_iRespuestaMensualidad1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_iRespuestaMensualidad1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iRespuestaMensualidad", &(a->ns2__NumMensualidad::iRespuestaMensualidad), "xsd:int"))
				{	soap_flag_iRespuestaMensualidad1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__NumMensualidad *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__NumMensualidad, 0, sizeof(ns2__NumMensualidad), 0, soap_copy_ns2__NumMensualidad);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_iRespuestaMensualidad1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__NumMensualidad::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__NumMensualidad);
	if (this->soap_out(soap, tag?tag:"ns2:NumMensualidad", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__NumMensualidad::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__NumMensualidad(soap, this, tag, type);
}

SOAP_FMAC3 ns2__NumMensualidad * SOAP_FMAC4 soap_get_ns2__NumMensualidad(struct soap *soap, ns2__NumMensualidad *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__NumMensualidad(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__NumMensualidad * SOAP_FMAC2 soap_instantiate_ns2__NumMensualidad(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__NumMensualidad(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__NumMensualidad, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__NumMensualidad);
		if (size)
			*size = sizeof(ns2__NumMensualidad);
		((ns2__NumMensualidad*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__NumMensualidad, n);
		if (size)
			*size = n * sizeof(ns2__NumMensualidad);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__NumMensualidad*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__NumMensualidad*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__NumMensualidad(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__NumMensualidad %p -> %p\n", q, p));
	*(ns2__NumMensualidad*)p = *(ns2__NumMensualidad*)q;
}

void ns2__RespuestaFechaLiquida::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaFechaLiquida::EstadoProc = NULL;
	this->ns2__RespuestaFechaLiquida::Fecha = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaFechaLiquida::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaFechaLiquida::EstadoProc);
	soap_serialize_PointerTons2__FechaLiquida(soap, &this->ns2__RespuestaFechaLiquida::Fecha);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaFechaLiquida::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaFechaLiquida(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaFechaLiquida(struct soap *soap, const char *tag, int id, const ns2__RespuestaFechaLiquida *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaFechaLiquida), type))
		return soap->error;
	if (a->ns2__RespuestaFechaLiquida::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaFechaLiquida::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaFechaLiquida::Fecha)
	{	if (soap_out_PointerTons2__FechaLiquida(soap, "Fecha", -1, &a->ns2__RespuestaFechaLiquida::Fecha, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Fecha"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaFechaLiquida::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaFechaLiquida(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaFechaLiquida * SOAP_FMAC4 soap_in_ns2__RespuestaFechaLiquida(struct soap *soap, const char *tag, ns2__RespuestaFechaLiquida *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaFechaLiquida *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaFechaLiquida, sizeof(ns2__RespuestaFechaLiquida), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaFechaLiquida)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaFechaLiquida *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_Fecha1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaFechaLiquida::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_Fecha1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FechaLiquida(soap, "Fecha", &(a->ns2__RespuestaFechaLiquida::Fecha), "ns2:FechaLiquida"))
				{	soap_flag_Fecha1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaFechaLiquida *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaFechaLiquida, 0, sizeof(ns2__RespuestaFechaLiquida), 0, soap_copy_ns2__RespuestaFechaLiquida);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_Fecha1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaFechaLiquida::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaFechaLiquida);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaFechaLiquida", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaFechaLiquida::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaFechaLiquida(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaFechaLiquida * SOAP_FMAC4 soap_get_ns2__RespuestaFechaLiquida(struct soap *soap, ns2__RespuestaFechaLiquida *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaFechaLiquida(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaFechaLiquida * SOAP_FMAC2 soap_instantiate_ns2__RespuestaFechaLiquida(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaFechaLiquida(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaFechaLiquida, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaFechaLiquida);
		if (size)
			*size = sizeof(ns2__RespuestaFechaLiquida);
		((ns2__RespuestaFechaLiquida*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaFechaLiquida, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaFechaLiquida);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaFechaLiquida*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaFechaLiquida*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaFechaLiquida(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaFechaLiquida %p -> %p\n", q, p));
	*(ns2__RespuestaFechaLiquida*)p = *(ns2__RespuestaFechaLiquida*)q;
}

void ns2__FechaLiquida::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__FechaLiquida::cFechaLiquida);
	/* transient soap skipped */
}

void ns2__FechaLiquida::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__FechaLiquida::cFechaLiquida);
	/* transient soap skipped */
#endif
}

int ns2__FechaLiquida::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FechaLiquida(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FechaLiquida(struct soap *soap, const char *tag, int id, const ns2__FechaLiquida *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FechaLiquida), type))
		return soap->error;
	if (soap_out_string(soap, "cFechaLiquida", -1, &(a->ns2__FechaLiquida::cFechaLiquida), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__FechaLiquida::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FechaLiquida(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FechaLiquida * SOAP_FMAC4 soap_in_ns2__FechaLiquida(struct soap *soap, const char *tag, ns2__FechaLiquida *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FechaLiquida *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FechaLiquida, sizeof(ns2__FechaLiquida), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FechaLiquida)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FechaLiquida *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cFechaLiquida1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cFechaLiquida1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cFechaLiquida", &(a->ns2__FechaLiquida::cFechaLiquida), "xsd:string"))
				{	soap_flag_cFechaLiquida1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FechaLiquida *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FechaLiquida, 0, sizeof(ns2__FechaLiquida), 0, soap_copy_ns2__FechaLiquida);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__FechaLiquida::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FechaLiquida);
	if (this->soap_out(soap, tag?tag:"ns2:FechaLiquida", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FechaLiquida::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FechaLiquida(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FechaLiquida * SOAP_FMAC4 soap_get_ns2__FechaLiquida(struct soap *soap, ns2__FechaLiquida *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FechaLiquida(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FechaLiquida * SOAP_FMAC2 soap_instantiate_ns2__FechaLiquida(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FechaLiquida(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FechaLiquida, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FechaLiquida);
		if (size)
			*size = sizeof(ns2__FechaLiquida);
		((ns2__FechaLiquida*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__FechaLiquida, n);
		if (size)
			*size = n * sizeof(ns2__FechaLiquida);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__FechaLiquida*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__FechaLiquida*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FechaLiquida(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FechaLiquida %p -> %p\n", q, p));
	*(ns2__FechaLiquida*)p = *(ns2__FechaLiquida*)q;
}

void ns2__RespuestaSaldoRecuperar::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaSaldoRecuperar::EstadoProc = NULL;
	this->ns2__RespuestaSaldoRecuperar::Saldo = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaSaldoRecuperar::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaSaldoRecuperar::EstadoProc);
	soap_serialize_PointerTons2__SaldoRecuperar(soap, &this->ns2__RespuestaSaldoRecuperar::Saldo);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaSaldoRecuperar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaSaldoRecuperar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaSaldoRecuperar(struct soap *soap, const char *tag, int id, const ns2__RespuestaSaldoRecuperar *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaSaldoRecuperar), type))
		return soap->error;
	if (a->ns2__RespuestaSaldoRecuperar::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaSaldoRecuperar::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaSaldoRecuperar::Saldo)
	{	if (soap_out_PointerTons2__SaldoRecuperar(soap, "Saldo", -1, &a->ns2__RespuestaSaldoRecuperar::Saldo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Saldo"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaSaldoRecuperar::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaSaldoRecuperar(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaSaldoRecuperar * SOAP_FMAC4 soap_in_ns2__RespuestaSaldoRecuperar(struct soap *soap, const char *tag, ns2__RespuestaSaldoRecuperar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaSaldoRecuperar *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaSaldoRecuperar, sizeof(ns2__RespuestaSaldoRecuperar), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaSaldoRecuperar)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaSaldoRecuperar *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_Saldo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaSaldoRecuperar::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_Saldo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SaldoRecuperar(soap, "Saldo", &(a->ns2__RespuestaSaldoRecuperar::Saldo), "ns2:SaldoRecuperar"))
				{	soap_flag_Saldo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaSaldoRecuperar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaSaldoRecuperar, 0, sizeof(ns2__RespuestaSaldoRecuperar), 0, soap_copy_ns2__RespuestaSaldoRecuperar);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_Saldo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaSaldoRecuperar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaSaldoRecuperar);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaSaldoRecuperar", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaSaldoRecuperar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaSaldoRecuperar(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaSaldoRecuperar * SOAP_FMAC4 soap_get_ns2__RespuestaSaldoRecuperar(struct soap *soap, ns2__RespuestaSaldoRecuperar *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaSaldoRecuperar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaSaldoRecuperar * SOAP_FMAC2 soap_instantiate_ns2__RespuestaSaldoRecuperar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaSaldoRecuperar(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaSaldoRecuperar, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaSaldoRecuperar);
		if (size)
			*size = sizeof(ns2__RespuestaSaldoRecuperar);
		((ns2__RespuestaSaldoRecuperar*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaSaldoRecuperar, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaSaldoRecuperar);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaSaldoRecuperar*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaSaldoRecuperar*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaSaldoRecuperar(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaSaldoRecuperar %p -> %p\n", q, p));
	*(ns2__RespuestaSaldoRecuperar*)p = *(ns2__RespuestaSaldoRecuperar*)q;
}

void ns2__SaldoRecuperar::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__SaldoRecuperar::iRespuestaSaldo);
	/* transient soap skipped */
}

void ns2__SaldoRecuperar::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns2__SaldoRecuperar::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SaldoRecuperar(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SaldoRecuperar(struct soap *soap, const char *tag, int id, const ns2__SaldoRecuperar *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SaldoRecuperar), type))
		return soap->error;
	if (soap_out_int(soap, "iRespuestaSaldo", -1, &(a->ns2__SaldoRecuperar::iRespuestaSaldo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SaldoRecuperar::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SaldoRecuperar(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SaldoRecuperar * SOAP_FMAC4 soap_in_ns2__SaldoRecuperar(struct soap *soap, const char *tag, ns2__SaldoRecuperar *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SaldoRecuperar *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SaldoRecuperar, sizeof(ns2__SaldoRecuperar), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SaldoRecuperar)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SaldoRecuperar *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_iRespuestaSaldo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_iRespuestaSaldo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iRespuestaSaldo", &(a->ns2__SaldoRecuperar::iRespuestaSaldo), "xsd:int"))
				{	soap_flag_iRespuestaSaldo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SaldoRecuperar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SaldoRecuperar, 0, sizeof(ns2__SaldoRecuperar), 0, soap_copy_ns2__SaldoRecuperar);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_iRespuestaSaldo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SaldoRecuperar::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SaldoRecuperar);
	if (this->soap_out(soap, tag?tag:"ns2:SaldoRecuperar", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SaldoRecuperar::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SaldoRecuperar(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SaldoRecuperar * SOAP_FMAC4 soap_get_ns2__SaldoRecuperar(struct soap *soap, ns2__SaldoRecuperar *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SaldoRecuperar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SaldoRecuperar * SOAP_FMAC2 soap_instantiate_ns2__SaldoRecuperar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SaldoRecuperar(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SaldoRecuperar, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SaldoRecuperar);
		if (size)
			*size = sizeof(ns2__SaldoRecuperar);
		((ns2__SaldoRecuperar*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__SaldoRecuperar, n);
		if (size)
			*size = n * sizeof(ns2__SaldoRecuperar);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__SaldoRecuperar*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__SaldoRecuperar*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SaldoRecuperar(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SaldoRecuperar %p -> %p\n", q, p));
	*(ns2__SaldoRecuperar*)p = *(ns2__SaldoRecuperar*)q;
}

void ns2__ParametroCurpNss::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ParametroCurpNss::Curp);
	soap_default_string(soap, &this->ns2__ParametroCurpNss::Nss);
	/* transient soap skipped */
}

void ns2__ParametroCurpNss::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParametroCurpNss::Curp);
	soap_serialize_string(soap, &this->ns2__ParametroCurpNss::Nss);
	/* transient soap skipped */
#endif
}

int ns2__ParametroCurpNss::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParametroCurpNss(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParametroCurpNss(struct soap *soap, const char *tag, int id, const ns2__ParametroCurpNss *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParametroCurpNss), type))
		return soap->error;
	if (soap_out_string(soap, "Curp", -1, &(a->ns2__ParametroCurpNss::Curp), ""))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ParametroCurpNss::Nss), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParametroCurpNss::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParametroCurpNss(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParametroCurpNss * SOAP_FMAC4 soap_in_ns2__ParametroCurpNss(struct soap *soap, const char *tag, ns2__ParametroCurpNss *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParametroCurpNss *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParametroCurpNss, sizeof(ns2__ParametroCurpNss), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParametroCurpNss)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParametroCurpNss *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Curp1 = 1;
	size_t soap_flag_Nss1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Curp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Curp", &(a->ns2__ParametroCurpNss::Curp), "xsd:string"))
				{	soap_flag_Curp1--;
					continue;
				}
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ParametroCurpNss::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParametroCurpNss *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParametroCurpNss, 0, sizeof(ns2__ParametroCurpNss), 0, soap_copy_ns2__ParametroCurpNss);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ParametroCurpNss::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParametroCurpNss);
	if (this->soap_out(soap, tag?tag:"ns2:ParametroCurpNss", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParametroCurpNss::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParametroCurpNss(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParametroCurpNss * SOAP_FMAC4 soap_get_ns2__ParametroCurpNss(struct soap *soap, ns2__ParametroCurpNss *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParametroCurpNss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParametroCurpNss * SOAP_FMAC2 soap_instantiate_ns2__ParametroCurpNss(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParametroCurpNss(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParametroCurpNss, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParametroCurpNss);
		if (size)
			*size = sizeof(ns2__ParametroCurpNss);
		((ns2__ParametroCurpNss*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParametroCurpNss, n);
		if (size)
			*size = n * sizeof(ns2__ParametroCurpNss);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParametroCurpNss*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParametroCurpNss*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParametroCurpNss(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParametroCurpNss %p -> %p\n", q, p));
	*(ns2__ParametroCurpNss*)p = *(ns2__ParametroCurpNss*)q;
}

void ns2__ParametroAportacionesPost::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__ParametroAportacionesPost::iOpcion);
	soap_default_string(soap, &this->ns2__ParametroAportacionesPost::Nss);
	soap_default_string(soap, &this->ns2__ParametroAportacionesPost::FechaIniPension);
	soap_default_int(soap, &this->ns2__ParametroAportacionesPost::iGrupo);
	/* transient soap skipped */
}

void ns2__ParametroAportacionesPost::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParametroAportacionesPost::Nss);
	soap_serialize_string(soap, &this->ns2__ParametroAportacionesPost::FechaIniPension);
	/* transient soap skipped */
#endif
}

int ns2__ParametroAportacionesPost::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParametroAportacionesPost(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParametroAportacionesPost(struct soap *soap, const char *tag, int id, const ns2__ParametroAportacionesPost *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParametroAportacionesPost), type))
		return soap->error;
	if (soap_out_int(soap, "iOpcion", -1, &(a->ns2__ParametroAportacionesPost::iOpcion), ""))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ParametroAportacionesPost::Nss), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaIniPension", -1, &(a->ns2__ParametroAportacionesPost::FechaIniPension), ""))
		return soap->error;
	if (soap_out_int(soap, "iGrupo", -1, &(a->ns2__ParametroAportacionesPost::iGrupo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParametroAportacionesPost::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParametroAportacionesPost(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParametroAportacionesPost * SOAP_FMAC4 soap_in_ns2__ParametroAportacionesPost(struct soap *soap, const char *tag, ns2__ParametroAportacionesPost *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParametroAportacionesPost *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParametroAportacionesPost, sizeof(ns2__ParametroAportacionesPost), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParametroAportacionesPost)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParametroAportacionesPost *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_iOpcion1 = 1;
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_FechaIniPension1 = 1;
	size_t soap_flag_iGrupo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_iOpcion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iOpcion", &(a->ns2__ParametroAportacionesPost::iOpcion), "xsd:int"))
				{	soap_flag_iOpcion1--;
					continue;
				}
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ParametroAportacionesPost::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_FechaIniPension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaIniPension", &(a->ns2__ParametroAportacionesPost::FechaIniPension), "xsd:string"))
				{	soap_flag_FechaIniPension1--;
					continue;
				}
			if (soap_flag_iGrupo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iGrupo", &(a->ns2__ParametroAportacionesPost::iGrupo), "xsd:int"))
				{	soap_flag_iGrupo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParametroAportacionesPost *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParametroAportacionesPost, 0, sizeof(ns2__ParametroAportacionesPost), 0, soap_copy_ns2__ParametroAportacionesPost);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_iOpcion1 > 0 || soap_flag_iGrupo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ParametroAportacionesPost::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParametroAportacionesPost);
	if (this->soap_out(soap, tag?tag:"ns2:ParametroAportacionesPost", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParametroAportacionesPost::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParametroAportacionesPost(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParametroAportacionesPost * SOAP_FMAC4 soap_get_ns2__ParametroAportacionesPost(struct soap *soap, ns2__ParametroAportacionesPost *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParametroAportacionesPost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParametroAportacionesPost * SOAP_FMAC2 soap_instantiate_ns2__ParametroAportacionesPost(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParametroAportacionesPost(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParametroAportacionesPost, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParametroAportacionesPost);
		if (size)
			*size = sizeof(ns2__ParametroAportacionesPost);
		((ns2__ParametroAportacionesPost*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParametroAportacionesPost, n);
		if (size)
			*size = n * sizeof(ns2__ParametroAportacionesPost);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParametroAportacionesPost*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParametroAportacionesPost*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParametroAportacionesPost(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParametroAportacionesPost %p -> %p\n", q, p));
	*(ns2__ParametroAportacionesPost*)p = *(ns2__ParametroAportacionesPost*)q;
}

void ns2__RespuestaConsultaSaldoVivienda::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaConsultaSaldoVivienda::EstadoProc = NULL;
	this->ns2__RespuestaConsultaSaldoVivienda::ConsultarSaldoViv = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaConsultaSaldoVivienda::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaConsultaSaldoVivienda::EstadoProc);
	soap_serialize_PointerTons2__ConsultarSaldoVivienda(soap, &this->ns2__RespuestaConsultaSaldoVivienda::ConsultarSaldoViv);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaConsultaSaldoVivienda::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaConsultaSaldoVivienda(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaConsultaSaldoVivienda(struct soap *soap, const char *tag, int id, const ns2__RespuestaConsultaSaldoVivienda *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda), type))
		return soap->error;
	if (a->ns2__RespuestaConsultaSaldoVivienda::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaConsultaSaldoVivienda::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaConsultaSaldoVivienda::ConsultarSaldoViv)
	{	if (soap_out_PointerTons2__ConsultarSaldoVivienda(soap, "ConsultarSaldoViv", -1, &a->ns2__RespuestaConsultaSaldoVivienda::ConsultarSaldoViv, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ConsultarSaldoViv"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaConsultaSaldoVivienda::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaConsultaSaldoVivienda(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaConsultaSaldoVivienda * SOAP_FMAC4 soap_in_ns2__RespuestaConsultaSaldoVivienda(struct soap *soap, const char *tag, ns2__RespuestaConsultaSaldoVivienda *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaConsultaSaldoVivienda *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda, sizeof(ns2__RespuestaConsultaSaldoVivienda), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaConsultaSaldoVivienda *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_ConsultarSaldoViv1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaConsultaSaldoVivienda::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_ConsultarSaldoViv1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ConsultarSaldoVivienda(soap, "ConsultarSaldoViv", &(a->ns2__RespuestaConsultaSaldoVivienda::ConsultarSaldoViv), "ns2:ConsultarSaldoVivienda"))
				{	soap_flag_ConsultarSaldoViv1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaConsultaSaldoVivienda *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda, 0, sizeof(ns2__RespuestaConsultaSaldoVivienda), 0, soap_copy_ns2__RespuestaConsultaSaldoVivienda);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_ConsultarSaldoViv1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaConsultaSaldoVivienda::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaConsultaSaldoVivienda", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaConsultaSaldoVivienda::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaConsultaSaldoVivienda(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaConsultaSaldoVivienda * SOAP_FMAC4 soap_get_ns2__RespuestaConsultaSaldoVivienda(struct soap *soap, ns2__RespuestaConsultaSaldoVivienda *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaConsultaSaldoVivienda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaConsultaSaldoVivienda * SOAP_FMAC2 soap_instantiate_ns2__RespuestaConsultaSaldoVivienda(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaConsultaSaldoVivienda(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaConsultaSaldoVivienda);
		if (size)
			*size = sizeof(ns2__RespuestaConsultaSaldoVivienda);
		((ns2__RespuestaConsultaSaldoVivienda*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaConsultaSaldoVivienda, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaConsultaSaldoVivienda);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaConsultaSaldoVivienda*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaConsultaSaldoVivienda*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaConsultaSaldoVivienda(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaConsultaSaldoVivienda %p -> %p\n", q, p));
	*(ns2__RespuestaConsultaSaldoVivienda*)p = *(ns2__RespuestaConsultaSaldoVivienda*)q;
}

void ns2__ConsultarSaldoVivienda::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ConsultarSaldoVivienda::sNss);
	soap_default_string(soap, &this->ns2__ConsultarSaldoVivienda::dMontoAccionViv);
	soap_default_string(soap, &this->ns2__ConsultarSaldoVivienda::dMontoPesosViv);
	/* transient soap skipped */
}

void ns2__ConsultarSaldoVivienda::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ConsultarSaldoVivienda::sNss);
	soap_serialize_string(soap, &this->ns2__ConsultarSaldoVivienda::dMontoAccionViv);
	soap_serialize_string(soap, &this->ns2__ConsultarSaldoVivienda::dMontoPesosViv);
	/* transient soap skipped */
#endif
}

int ns2__ConsultarSaldoVivienda::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ConsultarSaldoVivienda(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarSaldoVivienda(struct soap *soap, const char *tag, int id, const ns2__ConsultarSaldoVivienda *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarSaldoVivienda), type))
		return soap->error;
	if (soap_out_string(soap, "sNss", -1, &(a->ns2__ConsultarSaldoVivienda::sNss), ""))
		return soap->error;
	if (soap_out_string(soap, "dMontoAccionViv", -1, &(a->ns2__ConsultarSaldoVivienda::dMontoAccionViv), ""))
		return soap->error;
	if (soap_out_string(soap, "dMontoPesosViv", -1, &(a->ns2__ConsultarSaldoVivienda::dMontoPesosViv), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ConsultarSaldoVivienda::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ConsultarSaldoVivienda(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ConsultarSaldoVivienda * SOAP_FMAC4 soap_in_ns2__ConsultarSaldoVivienda(struct soap *soap, const char *tag, ns2__ConsultarSaldoVivienda *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ConsultarSaldoVivienda *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarSaldoVivienda, sizeof(ns2__ConsultarSaldoVivienda), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ConsultarSaldoVivienda)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ConsultarSaldoVivienda *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sNss1 = 1;
	size_t soap_flag_dMontoAccionViv1 = 1;
	size_t soap_flag_dMontoPesosViv1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sNss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sNss", &(a->ns2__ConsultarSaldoVivienda::sNss), "xsd:string"))
				{	soap_flag_sNss1--;
					continue;
				}
			if (soap_flag_dMontoAccionViv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dMontoAccionViv", &(a->ns2__ConsultarSaldoVivienda::dMontoAccionViv), "xsd:string"))
				{	soap_flag_dMontoAccionViv1--;
					continue;
				}
			if (soap_flag_dMontoPesosViv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "dMontoPesosViv", &(a->ns2__ConsultarSaldoVivienda::dMontoPesosViv), "xsd:string"))
				{	soap_flag_dMontoPesosViv1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ConsultarSaldoVivienda *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarSaldoVivienda, 0, sizeof(ns2__ConsultarSaldoVivienda), 0, soap_copy_ns2__ConsultarSaldoVivienda);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ConsultarSaldoVivienda::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarSaldoVivienda);
	if (this->soap_out(soap, tag?tag:"ns2:ConsultarSaldoVivienda", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ConsultarSaldoVivienda::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ConsultarSaldoVivienda(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ConsultarSaldoVivienda * SOAP_FMAC4 soap_get_ns2__ConsultarSaldoVivienda(struct soap *soap, ns2__ConsultarSaldoVivienda *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarSaldoVivienda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ConsultarSaldoVivienda * SOAP_FMAC2 soap_instantiate_ns2__ConsultarSaldoVivienda(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarSaldoVivienda(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarSaldoVivienda, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ConsultarSaldoVivienda);
		if (size)
			*size = sizeof(ns2__ConsultarSaldoVivienda);
		((ns2__ConsultarSaldoVivienda*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ConsultarSaldoVivienda, n);
		if (size)
			*size = n * sizeof(ns2__ConsultarSaldoVivienda);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ConsultarSaldoVivienda*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ConsultarSaldoVivienda*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarSaldoVivienda(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ConsultarSaldoVivienda %p -> %p\n", q, p));
	*(ns2__ConsultarSaldoVivienda*)p = *(ns2__ConsultarSaldoVivienda*)q;
}

void ns2__ParamConsultaSaldoVivienda::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ParamConsultaSaldoVivienda::sNss);
	soap_default_string(soap, &this->ns2__ParamConsultaSaldoVivienda::sFechaSolicitud);
	soap_default_string(soap, &this->ns2__ParamConsultaSaldoVivienda::sFechaIncioPension);
	/* transient soap skipped */
}

void ns2__ParamConsultaSaldoVivienda::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParamConsultaSaldoVivienda::sNss);
	soap_serialize_string(soap, &this->ns2__ParamConsultaSaldoVivienda::sFechaSolicitud);
	soap_serialize_string(soap, &this->ns2__ParamConsultaSaldoVivienda::sFechaIncioPension);
	/* transient soap skipped */
#endif
}

int ns2__ParamConsultaSaldoVivienda::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParamConsultaSaldoVivienda(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParamConsultaSaldoVivienda(struct soap *soap, const char *tag, int id, const ns2__ParamConsultaSaldoVivienda *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParamConsultaSaldoVivienda), type))
		return soap->error;
	if (soap_out_string(soap, "sNss", -1, &(a->ns2__ParamConsultaSaldoVivienda::sNss), ""))
		return soap->error;
	if (soap_out_string(soap, "sFechaSolicitud", -1, &(a->ns2__ParamConsultaSaldoVivienda::sFechaSolicitud), ""))
		return soap->error;
	if (soap_out_string(soap, "sFechaIncioPension", -1, &(a->ns2__ParamConsultaSaldoVivienda::sFechaIncioPension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParamConsultaSaldoVivienda::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParamConsultaSaldoVivienda(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParamConsultaSaldoVivienda * SOAP_FMAC4 soap_in_ns2__ParamConsultaSaldoVivienda(struct soap *soap, const char *tag, ns2__ParamConsultaSaldoVivienda *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParamConsultaSaldoVivienda *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParamConsultaSaldoVivienda, sizeof(ns2__ParamConsultaSaldoVivienda), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParamConsultaSaldoVivienda)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParamConsultaSaldoVivienda *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sNss1 = 1;
	size_t soap_flag_sFechaSolicitud1 = 1;
	size_t soap_flag_sFechaIncioPension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sNss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sNss", &(a->ns2__ParamConsultaSaldoVivienda::sNss), "xsd:string"))
				{	soap_flag_sNss1--;
					continue;
				}
			if (soap_flag_sFechaSolicitud1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sFechaSolicitud", &(a->ns2__ParamConsultaSaldoVivienda::sFechaSolicitud), "xsd:string"))
				{	soap_flag_sFechaSolicitud1--;
					continue;
				}
			if (soap_flag_sFechaIncioPension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "sFechaIncioPension", &(a->ns2__ParamConsultaSaldoVivienda::sFechaIncioPension), "xsd:string"))
				{	soap_flag_sFechaIncioPension1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParamConsultaSaldoVivienda *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParamConsultaSaldoVivienda, 0, sizeof(ns2__ParamConsultaSaldoVivienda), 0, soap_copy_ns2__ParamConsultaSaldoVivienda);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ParamConsultaSaldoVivienda::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParamConsultaSaldoVivienda);
	if (this->soap_out(soap, tag?tag:"ns2:ParamConsultaSaldoVivienda", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParamConsultaSaldoVivienda::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParamConsultaSaldoVivienda(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParamConsultaSaldoVivienda * SOAP_FMAC4 soap_get_ns2__ParamConsultaSaldoVivienda(struct soap *soap, ns2__ParamConsultaSaldoVivienda *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParamConsultaSaldoVivienda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParamConsultaSaldoVivienda * SOAP_FMAC2 soap_instantiate_ns2__ParamConsultaSaldoVivienda(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParamConsultaSaldoVivienda(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParamConsultaSaldoVivienda, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParamConsultaSaldoVivienda);
		if (size)
			*size = sizeof(ns2__ParamConsultaSaldoVivienda);
		((ns2__ParamConsultaSaldoVivienda*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParamConsultaSaldoVivienda, n);
		if (size)
			*size = n * sizeof(ns2__ParamConsultaSaldoVivienda);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParamConsultaSaldoVivienda*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParamConsultaSaldoVivienda*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParamConsultaSaldoVivienda(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParamConsultaSaldoVivienda %p -> %p\n", q, p));
	*(ns2__ParamConsultaSaldoVivienda*)p = *(ns2__ParamConsultaSaldoVivienda*)q;
}

void ns2__RespuestaCtaSaldoVol::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaCtaSaldoVol::EstadoProc = NULL;
	this->ns2__RespuestaCtaSaldoVol::ListaSaldoVol = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaCtaSaldoVol::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaCtaSaldoVol::EstadoProc);
	soap_serialize_PointerToArrayOfDatosCtaSaldoVol(soap, &this->ns2__RespuestaCtaSaldoVol::ListaSaldoVol);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaCtaSaldoVol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaCtaSaldoVol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaCtaSaldoVol(struct soap *soap, const char *tag, int id, const ns2__RespuestaCtaSaldoVol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaCtaSaldoVol), type))
		return soap->error;
	if (a->ns2__RespuestaCtaSaldoVol::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaCtaSaldoVol::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (soap_out_PointerToArrayOfDatosCtaSaldoVol(soap, "ListaSaldoVol", -1, &(a->ns2__RespuestaCtaSaldoVol::ListaSaldoVol), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaCtaSaldoVol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaCtaSaldoVol(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaCtaSaldoVol * SOAP_FMAC4 soap_in_ns2__RespuestaCtaSaldoVol(struct soap *soap, const char *tag, ns2__RespuestaCtaSaldoVol *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaCtaSaldoVol *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaCtaSaldoVol, sizeof(ns2__RespuestaCtaSaldoVol), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaCtaSaldoVol)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaCtaSaldoVol *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_ListaSaldoVol1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaCtaSaldoVol::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_ListaSaldoVol1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfDatosCtaSaldoVol(soap, "ListaSaldoVol", &(a->ns2__RespuestaCtaSaldoVol::ListaSaldoVol), "ns2:DatosCtaSaldoVol"))
				{	soap_flag_ListaSaldoVol1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaCtaSaldoVol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaCtaSaldoVol, 0, sizeof(ns2__RespuestaCtaSaldoVol), 0, soap_copy_ns2__RespuestaCtaSaldoVol);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaCtaSaldoVol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaCtaSaldoVol);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaCtaSaldoVol", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaCtaSaldoVol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaCtaSaldoVol(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaCtaSaldoVol * SOAP_FMAC4 soap_get_ns2__RespuestaCtaSaldoVol(struct soap *soap, ns2__RespuestaCtaSaldoVol *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaCtaSaldoVol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaCtaSaldoVol * SOAP_FMAC2 soap_instantiate_ns2__RespuestaCtaSaldoVol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaCtaSaldoVol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaCtaSaldoVol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaCtaSaldoVol);
		if (size)
			*size = sizeof(ns2__RespuestaCtaSaldoVol);
		((ns2__RespuestaCtaSaldoVol*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaCtaSaldoVol, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaCtaSaldoVol);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaCtaSaldoVol*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaCtaSaldoVol*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaCtaSaldoVol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaCtaSaldoVol %p -> %p\n", q, p));
	*(ns2__RespuestaCtaSaldoVol*)p = *(ns2__RespuestaCtaSaldoVol*)q;
}

void ArrayOfDatosCtaSaldoVol::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptrSaldovol = NULL;
}

void ArrayOfDatosCtaSaldoVol::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptrSaldovol && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptrSaldovol, 1, SOAP_TYPE_ArrayOfDatosCtaSaldoVol))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons2__DatosCtaSaldoVol(soap, this->__ptrSaldovol + i);
		}
#endif
}

int ArrayOfDatosCtaSaldoVol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfDatosCtaSaldoVol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfDatosCtaSaldoVol(struct soap *soap, const char *tag, int id, const ArrayOfDatosCtaSaldoVol *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrSaldovol ? soap_putsize(soap, "ns2:DatosCtaSaldoVol", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptrSaldovol, 1, type, SOAP_TYPE_ArrayOfDatosCtaSaldoVol);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons2__DatosCtaSaldoVol(soap, "Saldovol", -1, &a->__ptrSaldovol[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfDatosCtaSaldoVol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfDatosCtaSaldoVol(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfDatosCtaSaldoVol * SOAP_FMAC4 soap_in_ArrayOfDatosCtaSaldoVol(struct soap *soap, const char *tag, ArrayOfDatosCtaSaldoVol *a, const char *type)
{	int i, j;
	ns2__DatosCtaSaldoVol **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfDatosCtaSaldoVol *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfDatosCtaSaldoVol, sizeof(ArrayOfDatosCtaSaldoVol), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptrSaldovol = (ns2__DatosCtaSaldoVol **)soap_malloc(soap, sizeof(ns2__DatosCtaSaldoVol *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrSaldovol[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons2__DatosCtaSaldoVol(soap, NULL, a->__ptrSaldovol + i, "ns2:DatosCtaSaldoVol"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns2__DatosCtaSaldoVol **)soap_push_block(soap, NULL, sizeof(ns2__DatosCtaSaldoVol *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons2__DatosCtaSaldoVol(soap, NULL, p, "ns2:DatosCtaSaldoVol"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptrSaldovol = (ns2__DatosCtaSaldoVol **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptrSaldovol, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfDatosCtaSaldoVol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfDatosCtaSaldoVol, 0, sizeof(ArrayOfDatosCtaSaldoVol), 0, soap_copy_ArrayOfDatosCtaSaldoVol);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfDatosCtaSaldoVol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptrSaldovol, 1, tag, SOAP_TYPE_ArrayOfDatosCtaSaldoVol);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfDatosCtaSaldoVol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfDatosCtaSaldoVol(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfDatosCtaSaldoVol * SOAP_FMAC4 soap_get_ArrayOfDatosCtaSaldoVol(struct soap *soap, ArrayOfDatosCtaSaldoVol *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfDatosCtaSaldoVol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfDatosCtaSaldoVol * SOAP_FMAC2 soap_instantiate_ArrayOfDatosCtaSaldoVol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfDatosCtaSaldoVol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfDatosCtaSaldoVol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfDatosCtaSaldoVol);
		if (size)
			*size = sizeof(ArrayOfDatosCtaSaldoVol);
		((ArrayOfDatosCtaSaldoVol*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfDatosCtaSaldoVol, n);
		if (size)
			*size = n * sizeof(ArrayOfDatosCtaSaldoVol);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfDatosCtaSaldoVol*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfDatosCtaSaldoVol*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfDatosCtaSaldoVol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfDatosCtaSaldoVol %p -> %p\n", q, p));
	*(ArrayOfDatosCtaSaldoVol*)p = *(ArrayOfDatosCtaSaldoVol*)q;
}

void ns2__DatosCtaSaldoVol::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__DatosCtaSaldoVol::iFolio);
	soap_default_int(soap, &this->ns2__DatosCtaSaldoVol::iConsecutivoLote);
	soap_default_string(soap, &this->ns2__DatosCtaSaldoVol::cNss);
	soap_default_int(soap, &this->ns2__DatosCtaSaldoVol::iSiefore);
	soap_default_int(soap, &this->ns2__DatosCtaSaldoVol::iSubCuenta);
	soap_default_string(soap, &this->ns2__DatosCtaSaldoVol::cFechaValor);
	soap_default_string(soap, &this->ns2__DatosCtaSaldoVol::cFechaConversion);
	soap_default_string(soap, &this->ns2__DatosCtaSaldoVol::iMontoEnPesos);
	soap_default_string(soap, &this->ns2__DatosCtaSaldoVol::iMontoEnAcciones);
	soap_default_string(soap, &this->ns2__DatosCtaSaldoVol::iSaldoAcciones);
	soap_default_string(soap, &this->ns2__DatosCtaSaldoVol::cFechaSaldo);
	soap_default_string(soap, &this->ns2__DatosCtaSaldoVol::cUsuario);
	/* transient soap skipped */
}

void ns2__DatosCtaSaldoVol::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__DatosCtaSaldoVol::cNss);
	soap_serialize_string(soap, &this->ns2__DatosCtaSaldoVol::cFechaValor);
	soap_serialize_string(soap, &this->ns2__DatosCtaSaldoVol::cFechaConversion);
	soap_serialize_string(soap, &this->ns2__DatosCtaSaldoVol::iMontoEnPesos);
	soap_serialize_string(soap, &this->ns2__DatosCtaSaldoVol::iMontoEnAcciones);
	soap_serialize_string(soap, &this->ns2__DatosCtaSaldoVol::iSaldoAcciones);
	soap_serialize_string(soap, &this->ns2__DatosCtaSaldoVol::cFechaSaldo);
	soap_serialize_string(soap, &this->ns2__DatosCtaSaldoVol::cUsuario);
	/* transient soap skipped */
#endif
}

int ns2__DatosCtaSaldoVol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DatosCtaSaldoVol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DatosCtaSaldoVol(struct soap *soap, const char *tag, int id, const ns2__DatosCtaSaldoVol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DatosCtaSaldoVol), type))
		return soap->error;
	if (soap_out_int(soap, "iFolio", -1, &(a->ns2__DatosCtaSaldoVol::iFolio), ""))
		return soap->error;
	if (soap_out_int(soap, "iConsecutivoLote", -1, &(a->ns2__DatosCtaSaldoVol::iConsecutivoLote), ""))
		return soap->error;
	if (soap_out_string(soap, "cNss", -1, &(a->ns2__DatosCtaSaldoVol::cNss), ""))
		return soap->error;
	if (soap_out_int(soap, "iSiefore", -1, &(a->ns2__DatosCtaSaldoVol::iSiefore), ""))
		return soap->error;
	if (soap_out_int(soap, "iSubCuenta", -1, &(a->ns2__DatosCtaSaldoVol::iSubCuenta), ""))
		return soap->error;
	if (soap_out_string(soap, "cFechaValor", -1, &(a->ns2__DatosCtaSaldoVol::cFechaValor), ""))
		return soap->error;
	if (soap_out_string(soap, "cFechaConversion", -1, &(a->ns2__DatosCtaSaldoVol::cFechaConversion), ""))
		return soap->error;
	if (soap_out_string(soap, "iMontoEnPesos", -1, &(a->ns2__DatosCtaSaldoVol::iMontoEnPesos), ""))
		return soap->error;
	if (soap_out_string(soap, "iMontoEnAcciones", -1, &(a->ns2__DatosCtaSaldoVol::iMontoEnAcciones), ""))
		return soap->error;
	if (soap_out_string(soap, "iSaldoAcciones", -1, &(a->ns2__DatosCtaSaldoVol::iSaldoAcciones), ""))
		return soap->error;
	if (soap_out_string(soap, "cFechaSaldo", -1, &(a->ns2__DatosCtaSaldoVol::cFechaSaldo), ""))
		return soap->error;
	if (soap_out_string(soap, "cUsuario", -1, &(a->ns2__DatosCtaSaldoVol::cUsuario), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DatosCtaSaldoVol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DatosCtaSaldoVol(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DatosCtaSaldoVol * SOAP_FMAC4 soap_in_ns2__DatosCtaSaldoVol(struct soap *soap, const char *tag, ns2__DatosCtaSaldoVol *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DatosCtaSaldoVol *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DatosCtaSaldoVol, sizeof(ns2__DatosCtaSaldoVol), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DatosCtaSaldoVol)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DatosCtaSaldoVol *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_iFolio1 = 1;
	size_t soap_flag_iConsecutivoLote1 = 1;
	size_t soap_flag_cNss1 = 1;
	size_t soap_flag_iSiefore1 = 1;
	size_t soap_flag_iSubCuenta1 = 1;
	size_t soap_flag_cFechaValor1 = 1;
	size_t soap_flag_cFechaConversion1 = 1;
	size_t soap_flag_iMontoEnPesos1 = 1;
	size_t soap_flag_iMontoEnAcciones1 = 1;
	size_t soap_flag_iSaldoAcciones1 = 1;
	size_t soap_flag_cFechaSaldo1 = 1;
	size_t soap_flag_cUsuario1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_iFolio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iFolio", &(a->ns2__DatosCtaSaldoVol::iFolio), "xsd:int"))
				{	soap_flag_iFolio1--;
					continue;
				}
			if (soap_flag_iConsecutivoLote1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iConsecutivoLote", &(a->ns2__DatosCtaSaldoVol::iConsecutivoLote), "xsd:int"))
				{	soap_flag_iConsecutivoLote1--;
					continue;
				}
			if (soap_flag_cNss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cNss", &(a->ns2__DatosCtaSaldoVol::cNss), "xsd:string"))
				{	soap_flag_cNss1--;
					continue;
				}
			if (soap_flag_iSiefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iSiefore", &(a->ns2__DatosCtaSaldoVol::iSiefore), "xsd:int"))
				{	soap_flag_iSiefore1--;
					continue;
				}
			if (soap_flag_iSubCuenta1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iSubCuenta", &(a->ns2__DatosCtaSaldoVol::iSubCuenta), "xsd:int"))
				{	soap_flag_iSubCuenta1--;
					continue;
				}
			if (soap_flag_cFechaValor1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cFechaValor", &(a->ns2__DatosCtaSaldoVol::cFechaValor), "xsd:string"))
				{	soap_flag_cFechaValor1--;
					continue;
				}
			if (soap_flag_cFechaConversion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cFechaConversion", &(a->ns2__DatosCtaSaldoVol::cFechaConversion), "xsd:string"))
				{	soap_flag_cFechaConversion1--;
					continue;
				}
			if (soap_flag_iMontoEnPesos1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "iMontoEnPesos", &(a->ns2__DatosCtaSaldoVol::iMontoEnPesos), "xsd:string"))
				{	soap_flag_iMontoEnPesos1--;
					continue;
				}
			if (soap_flag_iMontoEnAcciones1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "iMontoEnAcciones", &(a->ns2__DatosCtaSaldoVol::iMontoEnAcciones), "xsd:string"))
				{	soap_flag_iMontoEnAcciones1--;
					continue;
				}
			if (soap_flag_iSaldoAcciones1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "iSaldoAcciones", &(a->ns2__DatosCtaSaldoVol::iSaldoAcciones), "xsd:string"))
				{	soap_flag_iSaldoAcciones1--;
					continue;
				}
			if (soap_flag_cFechaSaldo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cFechaSaldo", &(a->ns2__DatosCtaSaldoVol::cFechaSaldo), "xsd:string"))
				{	soap_flag_cFechaSaldo1--;
					continue;
				}
			if (soap_flag_cUsuario1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cUsuario", &(a->ns2__DatosCtaSaldoVol::cUsuario), "xsd:string"))
				{	soap_flag_cUsuario1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DatosCtaSaldoVol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DatosCtaSaldoVol, 0, sizeof(ns2__DatosCtaSaldoVol), 0, soap_copy_ns2__DatosCtaSaldoVol);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_iFolio1 > 0 || soap_flag_iConsecutivoLote1 > 0 || soap_flag_iSiefore1 > 0 || soap_flag_iSubCuenta1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__DatosCtaSaldoVol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DatosCtaSaldoVol);
	if (this->soap_out(soap, tag?tag:"ns2:DatosCtaSaldoVol", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DatosCtaSaldoVol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DatosCtaSaldoVol(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DatosCtaSaldoVol * SOAP_FMAC4 soap_get_ns2__DatosCtaSaldoVol(struct soap *soap, ns2__DatosCtaSaldoVol *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DatosCtaSaldoVol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DatosCtaSaldoVol * SOAP_FMAC2 soap_instantiate_ns2__DatosCtaSaldoVol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DatosCtaSaldoVol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DatosCtaSaldoVol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DatosCtaSaldoVol);
		if (size)
			*size = sizeof(ns2__DatosCtaSaldoVol);
		((ns2__DatosCtaSaldoVol*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__DatosCtaSaldoVol, n);
		if (size)
			*size = n * sizeof(ns2__DatosCtaSaldoVol);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__DatosCtaSaldoVol*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__DatosCtaSaldoVol*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DatosCtaSaldoVol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DatosCtaSaldoVol %p -> %p\n", q, p));
	*(ns2__DatosCtaSaldoVol*)p = *(ns2__DatosCtaSaldoVol*)q;
}

void ns2__ParamNssCtaSaldoVol::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ParamNssCtaSaldoVol::Nss);
	/* transient soap skipped */
}

void ns2__ParamNssCtaSaldoVol::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParamNssCtaSaldoVol::Nss);
	/* transient soap skipped */
#endif
}

int ns2__ParamNssCtaSaldoVol::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParamNssCtaSaldoVol(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParamNssCtaSaldoVol(struct soap *soap, const char *tag, int id, const ns2__ParamNssCtaSaldoVol *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParamNssCtaSaldoVol), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ParamNssCtaSaldoVol::Nss), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParamNssCtaSaldoVol::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParamNssCtaSaldoVol(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParamNssCtaSaldoVol * SOAP_FMAC4 soap_in_ns2__ParamNssCtaSaldoVol(struct soap *soap, const char *tag, ns2__ParamNssCtaSaldoVol *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParamNssCtaSaldoVol *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParamNssCtaSaldoVol, sizeof(ns2__ParamNssCtaSaldoVol), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParamNssCtaSaldoVol)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParamNssCtaSaldoVol *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ParamNssCtaSaldoVol::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParamNssCtaSaldoVol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParamNssCtaSaldoVol, 0, sizeof(ns2__ParamNssCtaSaldoVol), 0, soap_copy_ns2__ParamNssCtaSaldoVol);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ParamNssCtaSaldoVol::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParamNssCtaSaldoVol);
	if (this->soap_out(soap, tag?tag:"ns2:ParamNssCtaSaldoVol", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParamNssCtaSaldoVol::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParamNssCtaSaldoVol(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParamNssCtaSaldoVol * SOAP_FMAC4 soap_get_ns2__ParamNssCtaSaldoVol(struct soap *soap, ns2__ParamNssCtaSaldoVol *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParamNssCtaSaldoVol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParamNssCtaSaldoVol * SOAP_FMAC2 soap_instantiate_ns2__ParamNssCtaSaldoVol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParamNssCtaSaldoVol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParamNssCtaSaldoVol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParamNssCtaSaldoVol);
		if (size)
			*size = sizeof(ns2__ParamNssCtaSaldoVol);
		((ns2__ParamNssCtaSaldoVol*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParamNssCtaSaldoVol, n);
		if (size)
			*size = n * sizeof(ns2__ParamNssCtaSaldoVol);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParamNssCtaSaldoVol*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParamNssCtaSaldoVol*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParamNssCtaSaldoVol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParamNssCtaSaldoVol %p -> %p\n", q, p));
	*(ns2__ParamNssCtaSaldoVol*)p = *(ns2__ParamNssCtaSaldoVol*)q;
}

void ns2__RespuestaSieforeCtaRegimen::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaSieforeCtaRegimen::EstadoProc = NULL;
	this->ns2__RespuestaSieforeCtaRegimen::ListaSiefore = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaSieforeCtaRegimen::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaSieforeCtaRegimen::EstadoProc);
	soap_serialize_PointerToArrayOfSieforeCtaRegimen(soap, &this->ns2__RespuestaSieforeCtaRegimen::ListaSiefore);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaSieforeCtaRegimen::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaSieforeCtaRegimen(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaSieforeCtaRegimen(struct soap *soap, const char *tag, int id, const ns2__RespuestaSieforeCtaRegimen *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen), type))
		return soap->error;
	if (a->ns2__RespuestaSieforeCtaRegimen::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaSieforeCtaRegimen::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (soap_out_PointerToArrayOfSieforeCtaRegimen(soap, "ListaSiefore", -1, &(a->ns2__RespuestaSieforeCtaRegimen::ListaSiefore), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaSieforeCtaRegimen::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaSieforeCtaRegimen(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaSieforeCtaRegimen * SOAP_FMAC4 soap_in_ns2__RespuestaSieforeCtaRegimen(struct soap *soap, const char *tag, ns2__RespuestaSieforeCtaRegimen *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaSieforeCtaRegimen *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen, sizeof(ns2__RespuestaSieforeCtaRegimen), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaSieforeCtaRegimen *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_ListaSiefore1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaSieforeCtaRegimen::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_ListaSiefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfSieforeCtaRegimen(soap, "ListaSiefore", &(a->ns2__RespuestaSieforeCtaRegimen::ListaSiefore), "ns2:SieforeCtaRegimen"))
				{	soap_flag_ListaSiefore1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaSieforeCtaRegimen *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen, 0, sizeof(ns2__RespuestaSieforeCtaRegimen), 0, soap_copy_ns2__RespuestaSieforeCtaRegimen);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaSieforeCtaRegimen::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaSieforeCtaRegimen", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaSieforeCtaRegimen::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaSieforeCtaRegimen(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaSieforeCtaRegimen * SOAP_FMAC4 soap_get_ns2__RespuestaSieforeCtaRegimen(struct soap *soap, ns2__RespuestaSieforeCtaRegimen *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaSieforeCtaRegimen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaSieforeCtaRegimen * SOAP_FMAC2 soap_instantiate_ns2__RespuestaSieforeCtaRegimen(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaSieforeCtaRegimen(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaSieforeCtaRegimen);
		if (size)
			*size = sizeof(ns2__RespuestaSieforeCtaRegimen);
		((ns2__RespuestaSieforeCtaRegimen*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaSieforeCtaRegimen, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaSieforeCtaRegimen);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaSieforeCtaRegimen*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaSieforeCtaRegimen*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaSieforeCtaRegimen(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaSieforeCtaRegimen %p -> %p\n", q, p));
	*(ns2__RespuestaSieforeCtaRegimen*)p = *(ns2__RespuestaSieforeCtaRegimen*)q;
}

void ArrayOfSieforeCtaRegimen::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptrSiefore = NULL;
}

void ArrayOfSieforeCtaRegimen::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptrSiefore && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptrSiefore, 1, SOAP_TYPE_ArrayOfSieforeCtaRegimen))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons2__SieforeCtaRegimen(soap, this->__ptrSiefore + i);
		}
#endif
}

int ArrayOfSieforeCtaRegimen::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfSieforeCtaRegimen(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfSieforeCtaRegimen(struct soap *soap, const char *tag, int id, const ArrayOfSieforeCtaRegimen *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrSiefore ? soap_putsize(soap, "ns2:SieforeCtaRegimen", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptrSiefore, 1, type, SOAP_TYPE_ArrayOfSieforeCtaRegimen);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons2__SieforeCtaRegimen(soap, "Siefore", -1, &a->__ptrSiefore[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfSieforeCtaRegimen::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfSieforeCtaRegimen(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfSieforeCtaRegimen * SOAP_FMAC4 soap_in_ArrayOfSieforeCtaRegimen(struct soap *soap, const char *tag, ArrayOfSieforeCtaRegimen *a, const char *type)
{	int i, j;
	ns2__SieforeCtaRegimen **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfSieforeCtaRegimen *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfSieforeCtaRegimen, sizeof(ArrayOfSieforeCtaRegimen), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptrSiefore = (ns2__SieforeCtaRegimen **)soap_malloc(soap, sizeof(ns2__SieforeCtaRegimen *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrSiefore[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons2__SieforeCtaRegimen(soap, NULL, a->__ptrSiefore + i, "ns2:SieforeCtaRegimen"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns2__SieforeCtaRegimen **)soap_push_block(soap, NULL, sizeof(ns2__SieforeCtaRegimen *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons2__SieforeCtaRegimen(soap, NULL, p, "ns2:SieforeCtaRegimen"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptrSiefore = (ns2__SieforeCtaRegimen **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptrSiefore, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfSieforeCtaRegimen *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfSieforeCtaRegimen, 0, sizeof(ArrayOfSieforeCtaRegimen), 0, soap_copy_ArrayOfSieforeCtaRegimen);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfSieforeCtaRegimen::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptrSiefore, 1, tag, SOAP_TYPE_ArrayOfSieforeCtaRegimen);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfSieforeCtaRegimen::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfSieforeCtaRegimen(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfSieforeCtaRegimen * SOAP_FMAC4 soap_get_ArrayOfSieforeCtaRegimen(struct soap *soap, ArrayOfSieforeCtaRegimen *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfSieforeCtaRegimen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfSieforeCtaRegimen * SOAP_FMAC2 soap_instantiate_ArrayOfSieforeCtaRegimen(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfSieforeCtaRegimen(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfSieforeCtaRegimen, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfSieforeCtaRegimen);
		if (size)
			*size = sizeof(ArrayOfSieforeCtaRegimen);
		((ArrayOfSieforeCtaRegimen*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfSieforeCtaRegimen, n);
		if (size)
			*size = n * sizeof(ArrayOfSieforeCtaRegimen);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfSieforeCtaRegimen*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfSieforeCtaRegimen*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfSieforeCtaRegimen(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfSieforeCtaRegimen %p -> %p\n", q, p));
	*(ArrayOfSieforeCtaRegimen*)p = *(ArrayOfSieforeCtaRegimen*)q;
}

void ns2__SieforeCtaRegimen::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__SieforeCtaRegimen::Nss);
	soap_default_int(soap, &this->ns2__SieforeCtaRegimen::subCuenta);
	soap_default_int(soap, &this->ns2__SieforeCtaRegimen::Siefore);
	/* transient soap skipped */
}

void ns2__SieforeCtaRegimen::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__SieforeCtaRegimen::Nss);
	/* transient soap skipped */
#endif
}

int ns2__SieforeCtaRegimen::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SieforeCtaRegimen(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SieforeCtaRegimen(struct soap *soap, const char *tag, int id, const ns2__SieforeCtaRegimen *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SieforeCtaRegimen), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__SieforeCtaRegimen::Nss), ""))
		return soap->error;
	if (soap_out_int(soap, "subCuenta", -1, &(a->ns2__SieforeCtaRegimen::subCuenta), ""))
		return soap->error;
	if (soap_out_int(soap, "Siefore", -1, &(a->ns2__SieforeCtaRegimen::Siefore), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SieforeCtaRegimen::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SieforeCtaRegimen(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SieforeCtaRegimen * SOAP_FMAC4 soap_in_ns2__SieforeCtaRegimen(struct soap *soap, const char *tag, ns2__SieforeCtaRegimen *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SieforeCtaRegimen *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SieforeCtaRegimen, sizeof(ns2__SieforeCtaRegimen), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SieforeCtaRegimen)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SieforeCtaRegimen *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_subCuenta1 = 1;
	size_t soap_flag_Siefore1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__SieforeCtaRegimen::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_subCuenta1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "subCuenta", &(a->ns2__SieforeCtaRegimen::subCuenta), "xsd:int"))
				{	soap_flag_subCuenta1--;
					continue;
				}
			if (soap_flag_Siefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Siefore", &(a->ns2__SieforeCtaRegimen::Siefore), "xsd:int"))
				{	soap_flag_Siefore1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SieforeCtaRegimen *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SieforeCtaRegimen, 0, sizeof(ns2__SieforeCtaRegimen), 0, soap_copy_ns2__SieforeCtaRegimen);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_subCuenta1 > 0 || soap_flag_Siefore1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SieforeCtaRegimen::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SieforeCtaRegimen);
	if (this->soap_out(soap, tag?tag:"ns2:SieforeCtaRegimen", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SieforeCtaRegimen::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SieforeCtaRegimen(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SieforeCtaRegimen * SOAP_FMAC4 soap_get_ns2__SieforeCtaRegimen(struct soap *soap, ns2__SieforeCtaRegimen *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SieforeCtaRegimen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SieforeCtaRegimen * SOAP_FMAC2 soap_instantiate_ns2__SieforeCtaRegimen(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SieforeCtaRegimen(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SieforeCtaRegimen, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SieforeCtaRegimen);
		if (size)
			*size = sizeof(ns2__SieforeCtaRegimen);
		((ns2__SieforeCtaRegimen*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__SieforeCtaRegimen, n);
		if (size)
			*size = n * sizeof(ns2__SieforeCtaRegimen);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__SieforeCtaRegimen*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__SieforeCtaRegimen*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SieforeCtaRegimen(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SieforeCtaRegimen %p -> %p\n", q, p));
	*(ns2__SieforeCtaRegimen*)p = *(ns2__SieforeCtaRegimen*)q;
}

void ns2__ParamNssCtaRegimen::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ParamNssCtaRegimen::Nss);
	/* transient soap skipped */
}

void ns2__ParamNssCtaRegimen::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParamNssCtaRegimen::Nss);
	/* transient soap skipped */
#endif
}

int ns2__ParamNssCtaRegimen::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParamNssCtaRegimen(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParamNssCtaRegimen(struct soap *soap, const char *tag, int id, const ns2__ParamNssCtaRegimen *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParamNssCtaRegimen), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ParamNssCtaRegimen::Nss), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParamNssCtaRegimen::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParamNssCtaRegimen(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParamNssCtaRegimen * SOAP_FMAC4 soap_in_ns2__ParamNssCtaRegimen(struct soap *soap, const char *tag, ns2__ParamNssCtaRegimen *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParamNssCtaRegimen *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParamNssCtaRegimen, sizeof(ns2__ParamNssCtaRegimen), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParamNssCtaRegimen)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParamNssCtaRegimen *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ParamNssCtaRegimen::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParamNssCtaRegimen *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParamNssCtaRegimen, 0, sizeof(ns2__ParamNssCtaRegimen), 0, soap_copy_ns2__ParamNssCtaRegimen);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ParamNssCtaRegimen::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParamNssCtaRegimen);
	if (this->soap_out(soap, tag?tag:"ns2:ParamNssCtaRegimen", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParamNssCtaRegimen::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParamNssCtaRegimen(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParamNssCtaRegimen * SOAP_FMAC4 soap_get_ns2__ParamNssCtaRegimen(struct soap *soap, ns2__ParamNssCtaRegimen *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParamNssCtaRegimen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParamNssCtaRegimen * SOAP_FMAC2 soap_instantiate_ns2__ParamNssCtaRegimen(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParamNssCtaRegimen(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParamNssCtaRegimen, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParamNssCtaRegimen);
		if (size)
			*size = sizeof(ns2__ParamNssCtaRegimen);
		((ns2__ParamNssCtaRegimen*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParamNssCtaRegimen, n);
		if (size)
			*size = n * sizeof(ns2__ParamNssCtaRegimen);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParamNssCtaRegimen*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParamNssCtaRegimen*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParamNssCtaRegimen(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParamNssCtaRegimen %p -> %p\n", q, p));
	*(ns2__ParamNssCtaRegimen*)p = *(ns2__ParamNssCtaRegimen*)q;
}

void ns2__RespuestaAportacionesPosteriores::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaAportacionesPosteriores::EstadoProc = NULL;
	this->ns2__RespuestaAportacionesPosteriores::RespAportacionesPosteriores = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaAportacionesPosteriores::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaAportacionesPosteriores::EstadoProc);
	soap_serialize_PointerTons2__AportacionesPosteriores(soap, &this->ns2__RespuestaAportacionesPosteriores::RespAportacionesPosteriores);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaAportacionesPosteriores::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaAportacionesPosteriores(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaAportacionesPosteriores(struct soap *soap, const char *tag, int id, const ns2__RespuestaAportacionesPosteriores *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaAportacionesPosteriores), type))
		return soap->error;
	if (a->ns2__RespuestaAportacionesPosteriores::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaAportacionesPosteriores::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaAportacionesPosteriores::RespAportacionesPosteriores)
	{	if (soap_out_PointerTons2__AportacionesPosteriores(soap, "RespAportacionesPosteriores", -1, &a->ns2__RespuestaAportacionesPosteriores::RespAportacionesPosteriores, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "RespAportacionesPosteriores"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaAportacionesPosteriores::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaAportacionesPosteriores(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaAportacionesPosteriores * SOAP_FMAC4 soap_in_ns2__RespuestaAportacionesPosteriores(struct soap *soap, const char *tag, ns2__RespuestaAportacionesPosteriores *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaAportacionesPosteriores *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaAportacionesPosteriores, sizeof(ns2__RespuestaAportacionesPosteriores), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaAportacionesPosteriores)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaAportacionesPosteriores *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_RespAportacionesPosteriores1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaAportacionesPosteriores::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_RespAportacionesPosteriores1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__AportacionesPosteriores(soap, "RespAportacionesPosteriores", &(a->ns2__RespuestaAportacionesPosteriores::RespAportacionesPosteriores), "ns2:AportacionesPosteriores"))
				{	soap_flag_RespAportacionesPosteriores1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaAportacionesPosteriores *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaAportacionesPosteriores, 0, sizeof(ns2__RespuestaAportacionesPosteriores), 0, soap_copy_ns2__RespuestaAportacionesPosteriores);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_RespAportacionesPosteriores1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaAportacionesPosteriores::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaAportacionesPosteriores);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaAportacionesPosteriores", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaAportacionesPosteriores::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaAportacionesPosteriores(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaAportacionesPosteriores * SOAP_FMAC4 soap_get_ns2__RespuestaAportacionesPosteriores(struct soap *soap, ns2__RespuestaAportacionesPosteriores *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaAportacionesPosteriores(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaAportacionesPosteriores * SOAP_FMAC2 soap_instantiate_ns2__RespuestaAportacionesPosteriores(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaAportacionesPosteriores(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaAportacionesPosteriores, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaAportacionesPosteriores);
		if (size)
			*size = sizeof(ns2__RespuestaAportacionesPosteriores);
		((ns2__RespuestaAportacionesPosteriores*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaAportacionesPosteriores, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaAportacionesPosteriores);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaAportacionesPosteriores*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaAportacionesPosteriores*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaAportacionesPosteriores(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaAportacionesPosteriores %p -> %p\n", q, p));
	*(ns2__RespuestaAportacionesPosteriores*)p = *(ns2__RespuestaAportacionesPosteriores*)q;
}

void ns2__AportacionesPosteriores::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->ns2__AportacionesPosteriores::Aportacion);
	/* transient soap skipped */
}

void ns2__AportacionesPosteriores::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns2__AportacionesPosteriores::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__AportacionesPosteriores(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__AportacionesPosteriores(struct soap *soap, const char *tag, int id, const ns2__AportacionesPosteriores *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__AportacionesPosteriores), type))
		return soap->error;
	if (soap_out_double(soap, "Aportacion", -1, &(a->ns2__AportacionesPosteriores::Aportacion), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__AportacionesPosteriores::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__AportacionesPosteriores(soap, tag, this, type);
}

SOAP_FMAC3 ns2__AportacionesPosteriores * SOAP_FMAC4 soap_in_ns2__AportacionesPosteriores(struct soap *soap, const char *tag, ns2__AportacionesPosteriores *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__AportacionesPosteriores *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__AportacionesPosteriores, sizeof(ns2__AportacionesPosteriores), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__AportacionesPosteriores)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__AportacionesPosteriores *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Aportacion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Aportacion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Aportacion", &(a->ns2__AportacionesPosteriores::Aportacion), "xsd:double"))
				{	soap_flag_Aportacion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__AportacionesPosteriores *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__AportacionesPosteriores, 0, sizeof(ns2__AportacionesPosteriores), 0, soap_copy_ns2__AportacionesPosteriores);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Aportacion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__AportacionesPosteriores::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__AportacionesPosteriores);
	if (this->soap_out(soap, tag?tag:"ns2:AportacionesPosteriores", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__AportacionesPosteriores::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__AportacionesPosteriores(soap, this, tag, type);
}

SOAP_FMAC3 ns2__AportacionesPosteriores * SOAP_FMAC4 soap_get_ns2__AportacionesPosteriores(struct soap *soap, ns2__AportacionesPosteriores *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__AportacionesPosteriores(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__AportacionesPosteriores * SOAP_FMAC2 soap_instantiate_ns2__AportacionesPosteriores(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__AportacionesPosteriores(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__AportacionesPosteriores, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__AportacionesPosteriores);
		if (size)
			*size = sizeof(ns2__AportacionesPosteriores);
		((ns2__AportacionesPosteriores*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__AportacionesPosteriores, n);
		if (size)
			*size = n * sizeof(ns2__AportacionesPosteriores);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__AportacionesPosteriores*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__AportacionesPosteriores*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__AportacionesPosteriores(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__AportacionesPosteriores %p -> %p\n", q, p));
	*(ns2__AportacionesPosteriores*)p = *(ns2__AportacionesPosteriores*)q;
}

void ns2__ParamAportacionesPosteriores::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ParamAportacionesPosteriores::Nss);
	soap_default_string(soap, &this->ns2__ParamAportacionesPosteriores::FechaIniPension);
	soap_default_int(soap, &this->ns2__ParamAportacionesPosteriores::iOpcion);
	/* transient soap skipped */
}

void ns2__ParamAportacionesPosteriores::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParamAportacionesPosteriores::Nss);
	soap_serialize_string(soap, &this->ns2__ParamAportacionesPosteriores::FechaIniPension);
	/* transient soap skipped */
#endif
}

int ns2__ParamAportacionesPosteriores::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParamAportacionesPosteriores(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParamAportacionesPosteriores(struct soap *soap, const char *tag, int id, const ns2__ParamAportacionesPosteriores *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParamAportacionesPosteriores), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ParamAportacionesPosteriores::Nss), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaIniPension", -1, &(a->ns2__ParamAportacionesPosteriores::FechaIniPension), ""))
		return soap->error;
	if (soap_out_int(soap, "iOpcion", -1, &(a->ns2__ParamAportacionesPosteriores::iOpcion), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParamAportacionesPosteriores::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParamAportacionesPosteriores(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParamAportacionesPosteriores * SOAP_FMAC4 soap_in_ns2__ParamAportacionesPosteriores(struct soap *soap, const char *tag, ns2__ParamAportacionesPosteriores *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParamAportacionesPosteriores *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParamAportacionesPosteriores, sizeof(ns2__ParamAportacionesPosteriores), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParamAportacionesPosteriores)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParamAportacionesPosteriores *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_FechaIniPension1 = 1;
	size_t soap_flag_iOpcion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ParamAportacionesPosteriores::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_FechaIniPension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaIniPension", &(a->ns2__ParamAportacionesPosteriores::FechaIniPension), "xsd:string"))
				{	soap_flag_FechaIniPension1--;
					continue;
				}
			if (soap_flag_iOpcion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iOpcion", &(a->ns2__ParamAportacionesPosteriores::iOpcion), "xsd:int"))
				{	soap_flag_iOpcion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParamAportacionesPosteriores *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParamAportacionesPosteriores, 0, sizeof(ns2__ParamAportacionesPosteriores), 0, soap_copy_ns2__ParamAportacionesPosteriores);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_iOpcion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ParamAportacionesPosteriores::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParamAportacionesPosteriores);
	if (this->soap_out(soap, tag?tag:"ns2:ParamAportacionesPosteriores", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParamAportacionesPosteriores::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParamAportacionesPosteriores(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParamAportacionesPosteriores * SOAP_FMAC4 soap_get_ns2__ParamAportacionesPosteriores(struct soap *soap, ns2__ParamAportacionesPosteriores *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParamAportacionesPosteriores(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParamAportacionesPosteriores * SOAP_FMAC2 soap_instantiate_ns2__ParamAportacionesPosteriores(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParamAportacionesPosteriores(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParamAportacionesPosteriores, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParamAportacionesPosteriores);
		if (size)
			*size = sizeof(ns2__ParamAportacionesPosteriores);
		((ns2__ParamAportacionesPosteriores*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParamAportacionesPosteriores, n);
		if (size)
			*size = n * sizeof(ns2__ParamAportacionesPosteriores);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParamAportacionesPosteriores*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParamAportacionesPosteriores*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParamAportacionesPosteriores(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParamAportacionesPosteriores %p -> %p\n", q, p));
	*(ns2__ParamAportacionesPosteriores*)p = *(ns2__ParamAportacionesPosteriores*)q;
}

void ns2__RespuestaResolucionTotalIssste::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaResolucionTotalIssste::EstadoProc = NULL;
	this->ns2__RespuestaResolucionTotalIssste::RespResolucionTotalIssste = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaResolucionTotalIssste::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaResolucionTotalIssste::EstadoProc);
	soap_serialize_PointerTons2__ResolucionTotalIssste(soap, &this->ns2__RespuestaResolucionTotalIssste::RespResolucionTotalIssste);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaResolucionTotalIssste::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaResolucionTotalIssste(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaResolucionTotalIssste(struct soap *soap, const char *tag, int id, const ns2__RespuestaResolucionTotalIssste *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaResolucionTotalIssste), type))
		return soap->error;
	if (a->ns2__RespuestaResolucionTotalIssste::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaResolucionTotalIssste::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaResolucionTotalIssste::RespResolucionTotalIssste)
	{	if (soap_out_PointerTons2__ResolucionTotalIssste(soap, "RespResolucionTotalIssste", -1, &a->ns2__RespuestaResolucionTotalIssste::RespResolucionTotalIssste, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "RespResolucionTotalIssste"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaResolucionTotalIssste::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaResolucionTotalIssste(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaResolucionTotalIssste * SOAP_FMAC4 soap_in_ns2__RespuestaResolucionTotalIssste(struct soap *soap, const char *tag, ns2__RespuestaResolucionTotalIssste *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaResolucionTotalIssste *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaResolucionTotalIssste, sizeof(ns2__RespuestaResolucionTotalIssste), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaResolucionTotalIssste)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaResolucionTotalIssste *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_RespResolucionTotalIssste1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaResolucionTotalIssste::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_RespResolucionTotalIssste1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ResolucionTotalIssste(soap, "RespResolucionTotalIssste", &(a->ns2__RespuestaResolucionTotalIssste::RespResolucionTotalIssste), "ns2:ResolucionTotalIssste"))
				{	soap_flag_RespResolucionTotalIssste1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaResolucionTotalIssste *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaResolucionTotalIssste, 0, sizeof(ns2__RespuestaResolucionTotalIssste), 0, soap_copy_ns2__RespuestaResolucionTotalIssste);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_RespResolucionTotalIssste1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaResolucionTotalIssste::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaResolucionTotalIssste);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaResolucionTotalIssste", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaResolucionTotalIssste::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaResolucionTotalIssste(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaResolucionTotalIssste * SOAP_FMAC4 soap_get_ns2__RespuestaResolucionTotalIssste(struct soap *soap, ns2__RespuestaResolucionTotalIssste *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaResolucionTotalIssste(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaResolucionTotalIssste * SOAP_FMAC2 soap_instantiate_ns2__RespuestaResolucionTotalIssste(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaResolucionTotalIssste(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaResolucionTotalIssste, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaResolucionTotalIssste);
		if (size)
			*size = sizeof(ns2__RespuestaResolucionTotalIssste);
		((ns2__RespuestaResolucionTotalIssste*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaResolucionTotalIssste, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaResolucionTotalIssste);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaResolucionTotalIssste*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaResolucionTotalIssste*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaResolucionTotalIssste(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaResolucionTotalIssste %p -> %p\n", q, p));
	*(ns2__RespuestaResolucionTotalIssste*)p = *(ns2__RespuestaResolucionTotalIssste*)q;
}

void ns2__ResolucionTotalIssste::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::Nss);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::NssIssste);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::Curp);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::SecPension);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::NombreDatamart);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::PaternoDatamart);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::MaternoDatamart);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::NumConcesion);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::TipoRetiro);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::Regimen);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::TipoSeguro);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::TipoPension);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::CvePension);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::FechaInicioPen);
	soap_default_string(soap, &this->ns2__ResolucionTotalIssste::FechaResolucion);
	soap_default_int(soap, &this->ns2__ResolucionTotalIssste::Delegacion);
	soap_default_int(soap, &this->ns2__ResolucionTotalIssste::TipoMovimiento);
	soap_default_int(soap, &this->ns2__ResolucionTotalIssste::TipoPrestacion);
	soap_default_int(soap, &this->ns2__ResolucionTotalIssste::SemanasCotizadas);
	soap_default_int(soap, &this->ns2__ResolucionTotalIssste::DiagDatamart);
	soap_default_int(soap, &this->ns2__ResolucionTotalIssste::Estadoregistro);
	soap_default_int(soap, &this->ns2__ResolucionTotalIssste::Folio);
	/* transient soap skipped */
}

void ns2__ResolucionTotalIssste::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::Nss);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::NssIssste);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::Curp);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::SecPension);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::NombreDatamart);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::PaternoDatamart);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::MaternoDatamart);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::NumConcesion);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::TipoRetiro);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::Regimen);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::TipoSeguro);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::TipoPension);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::CvePension);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::FechaInicioPen);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalIssste::FechaResolucion);
	/* transient soap skipped */
#endif
}

int ns2__ResolucionTotalIssste::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ResolucionTotalIssste(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ResolucionTotalIssste(struct soap *soap, const char *tag, int id, const ns2__ResolucionTotalIssste *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ResolucionTotalIssste), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ResolucionTotalIssste::Nss), ""))
		return soap->error;
	if (soap_out_string(soap, "NssIssste", -1, &(a->ns2__ResolucionTotalIssste::NssIssste), ""))
		return soap->error;
	if (soap_out_string(soap, "Curp", -1, &(a->ns2__ResolucionTotalIssste::Curp), ""))
		return soap->error;
	if (soap_out_string(soap, "SecPension", -1, &(a->ns2__ResolucionTotalIssste::SecPension), ""))
		return soap->error;
	if (soap_out_string(soap, "NombreDatamart", -1, &(a->ns2__ResolucionTotalIssste::NombreDatamart), ""))
		return soap->error;
	if (soap_out_string(soap, "PaternoDatamart", -1, &(a->ns2__ResolucionTotalIssste::PaternoDatamart), ""))
		return soap->error;
	if (soap_out_string(soap, "MaternoDatamart", -1, &(a->ns2__ResolucionTotalIssste::MaternoDatamart), ""))
		return soap->error;
	if (soap_out_string(soap, "NumConcesion", -1, &(a->ns2__ResolucionTotalIssste::NumConcesion), ""))
		return soap->error;
	if (soap_out_string(soap, "TipoRetiro", -1, &(a->ns2__ResolucionTotalIssste::TipoRetiro), ""))
		return soap->error;
	if (soap_out_string(soap, "Regimen", -1, &(a->ns2__ResolucionTotalIssste::Regimen), ""))
		return soap->error;
	if (soap_out_string(soap, "TipoSeguro", -1, &(a->ns2__ResolucionTotalIssste::TipoSeguro), ""))
		return soap->error;
	if (soap_out_string(soap, "TipoPension", -1, &(a->ns2__ResolucionTotalIssste::TipoPension), ""))
		return soap->error;
	if (soap_out_string(soap, "CvePension", -1, &(a->ns2__ResolucionTotalIssste::CvePension), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaInicioPen", -1, &(a->ns2__ResolucionTotalIssste::FechaInicioPen), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaResolucion", -1, &(a->ns2__ResolucionTotalIssste::FechaResolucion), ""))
		return soap->error;
	if (soap_out_int(soap, "Delegacion", -1, &(a->ns2__ResolucionTotalIssste::Delegacion), ""))
		return soap->error;
	if (soap_out_int(soap, "TipoMovimiento", -1, &(a->ns2__ResolucionTotalIssste::TipoMovimiento), ""))
		return soap->error;
	if (soap_out_int(soap, "TipoPrestacion", -1, &(a->ns2__ResolucionTotalIssste::TipoPrestacion), ""))
		return soap->error;
	if (soap_out_int(soap, "SemanasCotizadas", -1, &(a->ns2__ResolucionTotalIssste::SemanasCotizadas), ""))
		return soap->error;
	if (soap_out_int(soap, "DiagDatamart", -1, &(a->ns2__ResolucionTotalIssste::DiagDatamart), ""))
		return soap->error;
	if (soap_out_int(soap, "Estadoregistro", -1, &(a->ns2__ResolucionTotalIssste::Estadoregistro), ""))
		return soap->error;
	if (soap_out_int(soap, "Folio", -1, &(a->ns2__ResolucionTotalIssste::Folio), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ResolucionTotalIssste::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ResolucionTotalIssste(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ResolucionTotalIssste * SOAP_FMAC4 soap_in_ns2__ResolucionTotalIssste(struct soap *soap, const char *tag, ns2__ResolucionTotalIssste *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ResolucionTotalIssste *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ResolucionTotalIssste, sizeof(ns2__ResolucionTotalIssste), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ResolucionTotalIssste)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ResolucionTotalIssste *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_NssIssste1 = 1;
	size_t soap_flag_Curp1 = 1;
	size_t soap_flag_SecPension1 = 1;
	size_t soap_flag_NombreDatamart1 = 1;
	size_t soap_flag_PaternoDatamart1 = 1;
	size_t soap_flag_MaternoDatamart1 = 1;
	size_t soap_flag_NumConcesion1 = 1;
	size_t soap_flag_TipoRetiro1 = 1;
	size_t soap_flag_Regimen1 = 1;
	size_t soap_flag_TipoSeguro1 = 1;
	size_t soap_flag_TipoPension1 = 1;
	size_t soap_flag_CvePension1 = 1;
	size_t soap_flag_FechaInicioPen1 = 1;
	size_t soap_flag_FechaResolucion1 = 1;
	size_t soap_flag_Delegacion1 = 1;
	size_t soap_flag_TipoMovimiento1 = 1;
	size_t soap_flag_TipoPrestacion1 = 1;
	size_t soap_flag_SemanasCotizadas1 = 1;
	size_t soap_flag_DiagDatamart1 = 1;
	size_t soap_flag_Estadoregistro1 = 1;
	size_t soap_flag_Folio1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ResolucionTotalIssste::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_NssIssste1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "NssIssste", &(a->ns2__ResolucionTotalIssste::NssIssste), "xsd:string"))
				{	soap_flag_NssIssste1--;
					continue;
				}
			if (soap_flag_Curp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Curp", &(a->ns2__ResolucionTotalIssste::Curp), "xsd:string"))
				{	soap_flag_Curp1--;
					continue;
				}
			if (soap_flag_SecPension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SecPension", &(a->ns2__ResolucionTotalIssste::SecPension), "xsd:string"))
				{	soap_flag_SecPension1--;
					continue;
				}
			if (soap_flag_NombreDatamart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "NombreDatamart", &(a->ns2__ResolucionTotalIssste::NombreDatamart), "xsd:string"))
				{	soap_flag_NombreDatamart1--;
					continue;
				}
			if (soap_flag_PaternoDatamart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "PaternoDatamart", &(a->ns2__ResolucionTotalIssste::PaternoDatamart), "xsd:string"))
				{	soap_flag_PaternoDatamart1--;
					continue;
				}
			if (soap_flag_MaternoDatamart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "MaternoDatamart", &(a->ns2__ResolucionTotalIssste::MaternoDatamart), "xsd:string"))
				{	soap_flag_MaternoDatamart1--;
					continue;
				}
			if (soap_flag_NumConcesion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "NumConcesion", &(a->ns2__ResolucionTotalIssste::NumConcesion), "xsd:string"))
				{	soap_flag_NumConcesion1--;
					continue;
				}
			if (soap_flag_TipoRetiro1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "TipoRetiro", &(a->ns2__ResolucionTotalIssste::TipoRetiro), "xsd:string"))
				{	soap_flag_TipoRetiro1--;
					continue;
				}
			if (soap_flag_Regimen1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Regimen", &(a->ns2__ResolucionTotalIssste::Regimen), "xsd:string"))
				{	soap_flag_Regimen1--;
					continue;
				}
			if (soap_flag_TipoSeguro1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "TipoSeguro", &(a->ns2__ResolucionTotalIssste::TipoSeguro), "xsd:string"))
				{	soap_flag_TipoSeguro1--;
					continue;
				}
			if (soap_flag_TipoPension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "TipoPension", &(a->ns2__ResolucionTotalIssste::TipoPension), "xsd:string"))
				{	soap_flag_TipoPension1--;
					continue;
				}
			if (soap_flag_CvePension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "CvePension", &(a->ns2__ResolucionTotalIssste::CvePension), "xsd:string"))
				{	soap_flag_CvePension1--;
					continue;
				}
			if (soap_flag_FechaInicioPen1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaInicioPen", &(a->ns2__ResolucionTotalIssste::FechaInicioPen), "xsd:string"))
				{	soap_flag_FechaInicioPen1--;
					continue;
				}
			if (soap_flag_FechaResolucion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaResolucion", &(a->ns2__ResolucionTotalIssste::FechaResolucion), "xsd:string"))
				{	soap_flag_FechaResolucion1--;
					continue;
				}
			if (soap_flag_Delegacion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Delegacion", &(a->ns2__ResolucionTotalIssste::Delegacion), "xsd:int"))
				{	soap_flag_Delegacion1--;
					continue;
				}
			if (soap_flag_TipoMovimiento1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TipoMovimiento", &(a->ns2__ResolucionTotalIssste::TipoMovimiento), "xsd:int"))
				{	soap_flag_TipoMovimiento1--;
					continue;
				}
			if (soap_flag_TipoPrestacion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TipoPrestacion", &(a->ns2__ResolucionTotalIssste::TipoPrestacion), "xsd:int"))
				{	soap_flag_TipoPrestacion1--;
					continue;
				}
			if (soap_flag_SemanasCotizadas1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "SemanasCotizadas", &(a->ns2__ResolucionTotalIssste::SemanasCotizadas), "xsd:int"))
				{	soap_flag_SemanasCotizadas1--;
					continue;
				}
			if (soap_flag_DiagDatamart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "DiagDatamart", &(a->ns2__ResolucionTotalIssste::DiagDatamart), "xsd:int"))
				{	soap_flag_DiagDatamart1--;
					continue;
				}
			if (soap_flag_Estadoregistro1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Estadoregistro", &(a->ns2__ResolucionTotalIssste::Estadoregistro), "xsd:int"))
				{	soap_flag_Estadoregistro1--;
					continue;
				}
			if (soap_flag_Folio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Folio", &(a->ns2__ResolucionTotalIssste::Folio), "xsd:int"))
				{	soap_flag_Folio1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ResolucionTotalIssste *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ResolucionTotalIssste, 0, sizeof(ns2__ResolucionTotalIssste), 0, soap_copy_ns2__ResolucionTotalIssste);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Delegacion1 > 0 || soap_flag_TipoMovimiento1 > 0 || soap_flag_TipoPrestacion1 > 0 || soap_flag_SemanasCotizadas1 > 0 || soap_flag_DiagDatamart1 > 0 || soap_flag_Estadoregistro1 > 0 || soap_flag_Folio1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ResolucionTotalIssste::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ResolucionTotalIssste);
	if (this->soap_out(soap, tag?tag:"ns2:ResolucionTotalIssste", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ResolucionTotalIssste::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ResolucionTotalIssste(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ResolucionTotalIssste * SOAP_FMAC4 soap_get_ns2__ResolucionTotalIssste(struct soap *soap, ns2__ResolucionTotalIssste *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ResolucionTotalIssste(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ResolucionTotalIssste * SOAP_FMAC2 soap_instantiate_ns2__ResolucionTotalIssste(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ResolucionTotalIssste(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ResolucionTotalIssste, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ResolucionTotalIssste);
		if (size)
			*size = sizeof(ns2__ResolucionTotalIssste);
		((ns2__ResolucionTotalIssste*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ResolucionTotalIssste, n);
		if (size)
			*size = n * sizeof(ns2__ResolucionTotalIssste);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ResolucionTotalIssste*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ResolucionTotalIssste*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ResolucionTotalIssste(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ResolucionTotalIssste %p -> %p\n", q, p));
	*(ns2__ResolucionTotalIssste*)p = *(ns2__ResolucionTotalIssste*)q;
}

void ns2__ParamResolucionTotalIssste::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ParamResolucionTotalIssste::Curp);
	soap_default_string(soap, &this->ns2__ParamResolucionTotalIssste::TipoRetiro);
	/* transient soap skipped */
}

void ns2__ParamResolucionTotalIssste::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParamResolucionTotalIssste::Curp);
	soap_serialize_string(soap, &this->ns2__ParamResolucionTotalIssste::TipoRetiro);
	/* transient soap skipped */
#endif
}

int ns2__ParamResolucionTotalIssste::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParamResolucionTotalIssste(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParamResolucionTotalIssste(struct soap *soap, const char *tag, int id, const ns2__ParamResolucionTotalIssste *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParamResolucionTotalIssste), type))
		return soap->error;
	if (soap_out_string(soap, "Curp", -1, &(a->ns2__ParamResolucionTotalIssste::Curp), ""))
		return soap->error;
	if (soap_out_string(soap, "TipoRetiro", -1, &(a->ns2__ParamResolucionTotalIssste::TipoRetiro), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParamResolucionTotalIssste::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParamResolucionTotalIssste(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParamResolucionTotalIssste * SOAP_FMAC4 soap_in_ns2__ParamResolucionTotalIssste(struct soap *soap, const char *tag, ns2__ParamResolucionTotalIssste *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParamResolucionTotalIssste *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParamResolucionTotalIssste, sizeof(ns2__ParamResolucionTotalIssste), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParamResolucionTotalIssste)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParamResolucionTotalIssste *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Curp1 = 1;
	size_t soap_flag_TipoRetiro1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Curp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Curp", &(a->ns2__ParamResolucionTotalIssste::Curp), "xsd:string"))
				{	soap_flag_Curp1--;
					continue;
				}
			if (soap_flag_TipoRetiro1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "TipoRetiro", &(a->ns2__ParamResolucionTotalIssste::TipoRetiro), "xsd:string"))
				{	soap_flag_TipoRetiro1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParamResolucionTotalIssste *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParamResolucionTotalIssste, 0, sizeof(ns2__ParamResolucionTotalIssste), 0, soap_copy_ns2__ParamResolucionTotalIssste);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ParamResolucionTotalIssste::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParamResolucionTotalIssste);
	if (this->soap_out(soap, tag?tag:"ns2:ParamResolucionTotalIssste", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParamResolucionTotalIssste::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParamResolucionTotalIssste(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParamResolucionTotalIssste * SOAP_FMAC4 soap_get_ns2__ParamResolucionTotalIssste(struct soap *soap, ns2__ParamResolucionTotalIssste *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParamResolucionTotalIssste(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParamResolucionTotalIssste * SOAP_FMAC2 soap_instantiate_ns2__ParamResolucionTotalIssste(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParamResolucionTotalIssste(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParamResolucionTotalIssste, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParamResolucionTotalIssste);
		if (size)
			*size = sizeof(ns2__ParamResolucionTotalIssste);
		((ns2__ParamResolucionTotalIssste*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParamResolucionTotalIssste, n);
		if (size)
			*size = n * sizeof(ns2__ParamResolucionTotalIssste);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParamResolucionTotalIssste*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParamResolucionTotalIssste*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParamResolucionTotalIssste(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParamResolucionTotalIssste %p -> %p\n", q, p));
	*(ns2__ParamResolucionTotalIssste*)p = *(ns2__ParamResolucionTotalIssste*)q;
}

void ns2__RespuestaMovimientosCuentas::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaMovimientosCuentas::EstadoProc = NULL;
	this->ns2__RespuestaMovimientosCuentas::RespMovimientosCuentas = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaMovimientosCuentas::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaMovimientosCuentas::EstadoProc);
	soap_serialize_PointerTons2__MovimientosCuentas(soap, &this->ns2__RespuestaMovimientosCuentas::RespMovimientosCuentas);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaMovimientosCuentas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaMovimientosCuentas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaMovimientosCuentas(struct soap *soap, const char *tag, int id, const ns2__RespuestaMovimientosCuentas *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaMovimientosCuentas), type))
		return soap->error;
	if (a->ns2__RespuestaMovimientosCuentas::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaMovimientosCuentas::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaMovimientosCuentas::RespMovimientosCuentas)
	{	if (soap_out_PointerTons2__MovimientosCuentas(soap, "RespMovimientosCuentas", -1, &a->ns2__RespuestaMovimientosCuentas::RespMovimientosCuentas, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "RespMovimientosCuentas"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaMovimientosCuentas::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaMovimientosCuentas(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaMovimientosCuentas * SOAP_FMAC4 soap_in_ns2__RespuestaMovimientosCuentas(struct soap *soap, const char *tag, ns2__RespuestaMovimientosCuentas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaMovimientosCuentas *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaMovimientosCuentas, sizeof(ns2__RespuestaMovimientosCuentas), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaMovimientosCuentas)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaMovimientosCuentas *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_RespMovimientosCuentas1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaMovimientosCuentas::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_RespMovimientosCuentas1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MovimientosCuentas(soap, "RespMovimientosCuentas", &(a->ns2__RespuestaMovimientosCuentas::RespMovimientosCuentas), "ns2:MovimientosCuentas"))
				{	soap_flag_RespMovimientosCuentas1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaMovimientosCuentas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaMovimientosCuentas, 0, sizeof(ns2__RespuestaMovimientosCuentas), 0, soap_copy_ns2__RespuestaMovimientosCuentas);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_RespMovimientosCuentas1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaMovimientosCuentas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaMovimientosCuentas);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaMovimientosCuentas", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaMovimientosCuentas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaMovimientosCuentas(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaMovimientosCuentas * SOAP_FMAC4 soap_get_ns2__RespuestaMovimientosCuentas(struct soap *soap, ns2__RespuestaMovimientosCuentas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaMovimientosCuentas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaMovimientosCuentas * SOAP_FMAC2 soap_instantiate_ns2__RespuestaMovimientosCuentas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaMovimientosCuentas(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaMovimientosCuentas, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaMovimientosCuentas);
		if (size)
			*size = sizeof(ns2__RespuestaMovimientosCuentas);
		((ns2__RespuestaMovimientosCuentas*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaMovimientosCuentas, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaMovimientosCuentas);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaMovimientosCuentas*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaMovimientosCuentas*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaMovimientosCuentas(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaMovimientosCuentas %p -> %p\n", q, p));
	*(ns2__RespuestaMovimientosCuentas*)p = *(ns2__RespuestaMovimientosCuentas*)q;
}

void ns2__MovimientosCuentas::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__MovimientosCuentas::Movimientos);
	/* transient soap skipped */
}

void ns2__MovimientosCuentas::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns2__MovimientosCuentas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MovimientosCuentas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MovimientosCuentas(struct soap *soap, const char *tag, int id, const ns2__MovimientosCuentas *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MovimientosCuentas), type))
		return soap->error;
	if (soap_out_int(soap, "Movimientos", -1, &(a->ns2__MovimientosCuentas::Movimientos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MovimientosCuentas::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MovimientosCuentas(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MovimientosCuentas * SOAP_FMAC4 soap_in_ns2__MovimientosCuentas(struct soap *soap, const char *tag, ns2__MovimientosCuentas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MovimientosCuentas *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MovimientosCuentas, sizeof(ns2__MovimientosCuentas), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MovimientosCuentas)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MovimientosCuentas *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Movimientos1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Movimientos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Movimientos", &(a->ns2__MovimientosCuentas::Movimientos), "xsd:int"))
				{	soap_flag_Movimientos1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MovimientosCuentas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MovimientosCuentas, 0, sizeof(ns2__MovimientosCuentas), 0, soap_copy_ns2__MovimientosCuentas);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Movimientos1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__MovimientosCuentas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MovimientosCuentas);
	if (this->soap_out(soap, tag?tag:"ns2:MovimientosCuentas", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MovimientosCuentas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MovimientosCuentas(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MovimientosCuentas * SOAP_FMAC4 soap_get_ns2__MovimientosCuentas(struct soap *soap, ns2__MovimientosCuentas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MovimientosCuentas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MovimientosCuentas * SOAP_FMAC2 soap_instantiate_ns2__MovimientosCuentas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MovimientosCuentas(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MovimientosCuentas, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MovimientosCuentas);
		if (size)
			*size = sizeof(ns2__MovimientosCuentas);
		((ns2__MovimientosCuentas*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__MovimientosCuentas, n);
		if (size)
			*size = n * sizeof(ns2__MovimientosCuentas);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__MovimientosCuentas*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__MovimientosCuentas*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MovimientosCuentas(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MovimientosCuentas %p -> %p\n", q, p));
	*(ns2__MovimientosCuentas*)p = *(ns2__MovimientosCuentas*)q;
}

void ns2__ParamMovimientosCuentas::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ParamMovimientosCuentas::Nss);
	/* transient soap skipped */
}

void ns2__ParamMovimientosCuentas::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParamMovimientosCuentas::Nss);
	/* transient soap skipped */
#endif
}

int ns2__ParamMovimientosCuentas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParamMovimientosCuentas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParamMovimientosCuentas(struct soap *soap, const char *tag, int id, const ns2__ParamMovimientosCuentas *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParamMovimientosCuentas), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ParamMovimientosCuentas::Nss), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParamMovimientosCuentas::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParamMovimientosCuentas(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParamMovimientosCuentas * SOAP_FMAC4 soap_in_ns2__ParamMovimientosCuentas(struct soap *soap, const char *tag, ns2__ParamMovimientosCuentas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParamMovimientosCuentas *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParamMovimientosCuentas, sizeof(ns2__ParamMovimientosCuentas), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParamMovimientosCuentas)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParamMovimientosCuentas *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ParamMovimientosCuentas::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParamMovimientosCuentas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParamMovimientosCuentas, 0, sizeof(ns2__ParamMovimientosCuentas), 0, soap_copy_ns2__ParamMovimientosCuentas);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ParamMovimientosCuentas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParamMovimientosCuentas);
	if (this->soap_out(soap, tag?tag:"ns2:ParamMovimientosCuentas", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParamMovimientosCuentas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParamMovimientosCuentas(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParamMovimientosCuentas * SOAP_FMAC4 soap_get_ns2__ParamMovimientosCuentas(struct soap *soap, ns2__ParamMovimientosCuentas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParamMovimientosCuentas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParamMovimientosCuentas * SOAP_FMAC2 soap_instantiate_ns2__ParamMovimientosCuentas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParamMovimientosCuentas(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParamMovimientosCuentas, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParamMovimientosCuentas);
		if (size)
			*size = sizeof(ns2__ParamMovimientosCuentas);
		((ns2__ParamMovimientosCuentas*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParamMovimientosCuentas, n);
		if (size)
			*size = n * sizeof(ns2__ParamMovimientosCuentas);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParamMovimientosCuentas*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParamMovimientosCuentas*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParamMovimientosCuentas(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParamMovimientosCuentas %p -> %p\n", q, p));
	*(ns2__ParamMovimientosCuentas*)p = *(ns2__ParamMovimientosCuentas*)q;
}

void ns2__RespuestaCOperacionesPmgImss::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaCOperacionesPmgImss::EstadoProc = NULL;
	this->ns2__RespuestaCOperacionesPmgImss::ResolOperacionPmg = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaCOperacionesPmgImss::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaCOperacionesPmgImss::EstadoProc);
	soap_serialize_PointerTons2__ResolucionOperacionPmg(soap, &this->ns2__RespuestaCOperacionesPmgImss::ResolOperacionPmg);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaCOperacionesPmgImss::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaCOperacionesPmgImss(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaCOperacionesPmgImss(struct soap *soap, const char *tag, int id, const ns2__RespuestaCOperacionesPmgImss *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss), type))
		return soap->error;
	if (a->ns2__RespuestaCOperacionesPmgImss::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaCOperacionesPmgImss::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaCOperacionesPmgImss::ResolOperacionPmg)
	{	if (soap_out_PointerTons2__ResolucionOperacionPmg(soap, "ResolOperacionPmg", -1, &a->ns2__RespuestaCOperacionesPmgImss::ResolOperacionPmg, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ResolOperacionPmg"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaCOperacionesPmgImss::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaCOperacionesPmgImss(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaCOperacionesPmgImss * SOAP_FMAC4 soap_in_ns2__RespuestaCOperacionesPmgImss(struct soap *soap, const char *tag, ns2__RespuestaCOperacionesPmgImss *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaCOperacionesPmgImss *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss, sizeof(ns2__RespuestaCOperacionesPmgImss), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaCOperacionesPmgImss *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_ResolOperacionPmg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaCOperacionesPmgImss::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_ResolOperacionPmg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ResolucionOperacionPmg(soap, "ResolOperacionPmg", &(a->ns2__RespuestaCOperacionesPmgImss::ResolOperacionPmg), "ns2:ResolucionOperacionPmg"))
				{	soap_flag_ResolOperacionPmg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaCOperacionesPmgImss *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss, 0, sizeof(ns2__RespuestaCOperacionesPmgImss), 0, soap_copy_ns2__RespuestaCOperacionesPmgImss);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_ResolOperacionPmg1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaCOperacionesPmgImss::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaCOperacionesPmgImss", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaCOperacionesPmgImss::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaCOperacionesPmgImss(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaCOperacionesPmgImss * SOAP_FMAC4 soap_get_ns2__RespuestaCOperacionesPmgImss(struct soap *soap, ns2__RespuestaCOperacionesPmgImss *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaCOperacionesPmgImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaCOperacionesPmgImss * SOAP_FMAC2 soap_instantiate_ns2__RespuestaCOperacionesPmgImss(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaCOperacionesPmgImss(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaCOperacionesPmgImss);
		if (size)
			*size = sizeof(ns2__RespuestaCOperacionesPmgImss);
		((ns2__RespuestaCOperacionesPmgImss*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaCOperacionesPmgImss, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaCOperacionesPmgImss);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaCOperacionesPmgImss*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaCOperacionesPmgImss*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaCOperacionesPmgImss(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaCOperacionesPmgImss %p -> %p\n", q, p));
	*(ns2__RespuestaCOperacionesPmgImss*)p = *(ns2__RespuestaCOperacionesPmgImss*)q;
}

void ns2__ResolucionOperacionPmg::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ResolucionOperacionPmg::Mensaje);
	soap_default_int(soap, &this->ns2__ResolucionOperacionPmg::Codigo);
	soap_default_double(soap, &this->ns2__ResolucionOperacionPmg::Importe);
	/* transient soap skipped */
}

void ns2__ResolucionOperacionPmg::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ResolucionOperacionPmg::Mensaje);
	/* transient soap skipped */
#endif
}

int ns2__ResolucionOperacionPmg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ResolucionOperacionPmg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ResolucionOperacionPmg(struct soap *soap, const char *tag, int id, const ns2__ResolucionOperacionPmg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ResolucionOperacionPmg), type))
		return soap->error;
	if (soap_out_string(soap, "Mensaje", -1, &(a->ns2__ResolucionOperacionPmg::Mensaje), ""))
		return soap->error;
	if (soap_out_int(soap, "Codigo", -1, &(a->ns2__ResolucionOperacionPmg::Codigo), ""))
		return soap->error;
	if (soap_out_double(soap, "Importe", -1, &(a->ns2__ResolucionOperacionPmg::Importe), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ResolucionOperacionPmg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ResolucionOperacionPmg(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ResolucionOperacionPmg * SOAP_FMAC4 soap_in_ns2__ResolucionOperacionPmg(struct soap *soap, const char *tag, ns2__ResolucionOperacionPmg *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ResolucionOperacionPmg *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ResolucionOperacionPmg, sizeof(ns2__ResolucionOperacionPmg), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ResolucionOperacionPmg)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ResolucionOperacionPmg *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Mensaje1 = 1;
	size_t soap_flag_Codigo1 = 1;
	size_t soap_flag_Importe1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mensaje1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Mensaje", &(a->ns2__ResolucionOperacionPmg::Mensaje), "xsd:string"))
				{	soap_flag_Mensaje1--;
					continue;
				}
			if (soap_flag_Codigo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Codigo", &(a->ns2__ResolucionOperacionPmg::Codigo), "xsd:int"))
				{	soap_flag_Codigo1--;
					continue;
				}
			if (soap_flag_Importe1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Importe", &(a->ns2__ResolucionOperacionPmg::Importe), "xsd:double"))
				{	soap_flag_Importe1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ResolucionOperacionPmg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ResolucionOperacionPmg, 0, sizeof(ns2__ResolucionOperacionPmg), 0, soap_copy_ns2__ResolucionOperacionPmg);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Codigo1 > 0 || soap_flag_Importe1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ResolucionOperacionPmg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ResolucionOperacionPmg);
	if (this->soap_out(soap, tag?tag:"ns2:ResolucionOperacionPmg", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ResolucionOperacionPmg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ResolucionOperacionPmg(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ResolucionOperacionPmg * SOAP_FMAC4 soap_get_ns2__ResolucionOperacionPmg(struct soap *soap, ns2__ResolucionOperacionPmg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ResolucionOperacionPmg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ResolucionOperacionPmg * SOAP_FMAC2 soap_instantiate_ns2__ResolucionOperacionPmg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ResolucionOperacionPmg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ResolucionOperacionPmg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ResolucionOperacionPmg);
		if (size)
			*size = sizeof(ns2__ResolucionOperacionPmg);
		((ns2__ResolucionOperacionPmg*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ResolucionOperacionPmg, n);
		if (size)
			*size = n * sizeof(ns2__ResolucionOperacionPmg);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ResolucionOperacionPmg*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ResolucionOperacionPmg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ResolucionOperacionPmg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ResolucionOperacionPmg %p -> %p\n", q, p));
	*(ns2__ResolucionOperacionPmg*)p = *(ns2__ResolucionOperacionPmg*)q;
}

void ns2__ParamOperacionPmgImss::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ParamOperacionPmgImss::Nss);
	soap_default_string(soap, &this->ns2__ParamOperacionPmgImss::Secuencia);
	soap_default_int(soap, &this->ns2__ParamOperacionPmgImss::Folio);
	soap_default_int(soap, &this->ns2__ParamOperacionPmgImss::iOpcion);
	/* transient soap skipped */
}

void ns2__ParamOperacionPmgImss::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParamOperacionPmgImss::Nss);
	soap_serialize_string(soap, &this->ns2__ParamOperacionPmgImss::Secuencia);
	/* transient soap skipped */
#endif
}

int ns2__ParamOperacionPmgImss::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParamOperacionPmgImss(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParamOperacionPmgImss(struct soap *soap, const char *tag, int id, const ns2__ParamOperacionPmgImss *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParamOperacionPmgImss), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ParamOperacionPmgImss::Nss), ""))
		return soap->error;
	if (soap_out_string(soap, "Secuencia", -1, &(a->ns2__ParamOperacionPmgImss::Secuencia), ""))
		return soap->error;
	if (soap_out_int(soap, "Folio", -1, &(a->ns2__ParamOperacionPmgImss::Folio), ""))
		return soap->error;
	if (soap_out_int(soap, "iOpcion", -1, &(a->ns2__ParamOperacionPmgImss::iOpcion), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParamOperacionPmgImss::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParamOperacionPmgImss(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParamOperacionPmgImss * SOAP_FMAC4 soap_in_ns2__ParamOperacionPmgImss(struct soap *soap, const char *tag, ns2__ParamOperacionPmgImss *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParamOperacionPmgImss *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParamOperacionPmgImss, sizeof(ns2__ParamOperacionPmgImss), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParamOperacionPmgImss)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParamOperacionPmgImss *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_Secuencia1 = 1;
	size_t soap_flag_Folio1 = 1;
	size_t soap_flag_iOpcion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ParamOperacionPmgImss::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_Secuencia1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Secuencia", &(a->ns2__ParamOperacionPmgImss::Secuencia), "xsd:string"))
				{	soap_flag_Secuencia1--;
					continue;
				}
			if (soap_flag_Folio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Folio", &(a->ns2__ParamOperacionPmgImss::Folio), "xsd:int"))
				{	soap_flag_Folio1--;
					continue;
				}
			if (soap_flag_iOpcion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iOpcion", &(a->ns2__ParamOperacionPmgImss::iOpcion), "xsd:int"))
				{	soap_flag_iOpcion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParamOperacionPmgImss *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParamOperacionPmgImss, 0, sizeof(ns2__ParamOperacionPmgImss), 0, soap_copy_ns2__ParamOperacionPmgImss);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Folio1 > 0 || soap_flag_iOpcion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ParamOperacionPmgImss::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParamOperacionPmgImss);
	if (this->soap_out(soap, tag?tag:"ns2:ParamOperacionPmgImss", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParamOperacionPmgImss::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParamOperacionPmgImss(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParamOperacionPmgImss * SOAP_FMAC4 soap_get_ns2__ParamOperacionPmgImss(struct soap *soap, ns2__ParamOperacionPmgImss *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParamOperacionPmgImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParamOperacionPmgImss * SOAP_FMAC2 soap_instantiate_ns2__ParamOperacionPmgImss(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParamOperacionPmgImss(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParamOperacionPmgImss, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParamOperacionPmgImss);
		if (size)
			*size = sizeof(ns2__ParamOperacionPmgImss);
		((ns2__ParamOperacionPmgImss*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParamOperacionPmgImss, n);
		if (size)
			*size = n * sizeof(ns2__ParamOperacionPmgImss);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParamOperacionPmgImss*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParamOperacionPmgImss*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParamOperacionPmgImss(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParamOperacionPmgImss %p -> %p\n", q, p));
	*(ns2__ParamOperacionPmgImss*)p = *(ns2__ParamOperacionPmgImss*)q;
}

void ns2__RespuestaResolucionTotalImss::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaResolucionTotalImss::EstadoProc = NULL;
	this->ns2__RespuestaResolucionTotalImss::ResolTotalImss = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaResolucionTotalImss::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaResolucionTotalImss::EstadoProc);
	soap_serialize_PointerTons2__ResolucionTotalImss(soap, &this->ns2__RespuestaResolucionTotalImss::ResolTotalImss);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaResolucionTotalImss::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaResolucionTotalImss(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaResolucionTotalImss(struct soap *soap, const char *tag, int id, const ns2__RespuestaResolucionTotalImss *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaResolucionTotalImss), type))
		return soap->error;
	if (a->ns2__RespuestaResolucionTotalImss::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaResolucionTotalImss::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaResolucionTotalImss::ResolTotalImss)
	{	if (soap_out_PointerTons2__ResolucionTotalImss(soap, "ResolTotalImss", -1, &a->ns2__RespuestaResolucionTotalImss::ResolTotalImss, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ResolTotalImss"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaResolucionTotalImss::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaResolucionTotalImss(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaResolucionTotalImss * SOAP_FMAC4 soap_in_ns2__RespuestaResolucionTotalImss(struct soap *soap, const char *tag, ns2__RespuestaResolucionTotalImss *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaResolucionTotalImss *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaResolucionTotalImss, sizeof(ns2__RespuestaResolucionTotalImss), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaResolucionTotalImss)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaResolucionTotalImss *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_ResolTotalImss1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaResolucionTotalImss::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_ResolTotalImss1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ResolucionTotalImss(soap, "ResolTotalImss", &(a->ns2__RespuestaResolucionTotalImss::ResolTotalImss), "ns2:ResolucionTotalImss"))
				{	soap_flag_ResolTotalImss1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaResolucionTotalImss *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaResolucionTotalImss, 0, sizeof(ns2__RespuestaResolucionTotalImss), 0, soap_copy_ns2__RespuestaResolucionTotalImss);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_ResolTotalImss1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaResolucionTotalImss::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaResolucionTotalImss);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaResolucionTotalImss", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaResolucionTotalImss::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaResolucionTotalImss(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaResolucionTotalImss * SOAP_FMAC4 soap_get_ns2__RespuestaResolucionTotalImss(struct soap *soap, ns2__RespuestaResolucionTotalImss *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaResolucionTotalImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaResolucionTotalImss * SOAP_FMAC2 soap_instantiate_ns2__RespuestaResolucionTotalImss(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaResolucionTotalImss(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaResolucionTotalImss, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaResolucionTotalImss);
		if (size)
			*size = sizeof(ns2__RespuestaResolucionTotalImss);
		((ns2__RespuestaResolucionTotalImss*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaResolucionTotalImss, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaResolucionTotalImss);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaResolucionTotalImss*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaResolucionTotalImss*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaResolucionTotalImss(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaResolucionTotalImss %p -> %p\n", q, p));
	*(ns2__RespuestaResolucionTotalImss*)p = *(ns2__RespuestaResolucionTotalImss*)q;
}

void ns2__ResolucionTotalImss::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__ResolucionTotalImss::ExisteResolucion);
	soap_default_int(soap, &this->ns2__ResolucionTotalImss::ExisteAfiliado);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::Regimen);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::TipoSeguro);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::TipoPension);
	soap_default_int(soap, &this->ns2__ResolucionTotalImss::TipoPrestacion);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::NombreDatamart);
	soap_default_int(soap, &this->ns2__ResolucionTotalImss::Folio);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::SecPension);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::FechaInicio);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::FechaPago);
	soap_default_int(soap, &this->ns2__ResolucionTotalImss::SemanasCotizadas);
	soap_default_int(soap, &this->ns2__ResolucionTotalImss::DiagDatamart);
	soap_default_int(soap, &this->ns2__ResolucionTotalImss::EstadoSubViv);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::FechaResolucion);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::DescRegimen);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::DescTipoPension);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::DescTipoPrestacion);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::DescTipoRetiro);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::DescTipoSeguro);
	soap_default_string(soap, &this->ns2__ResolucionTotalImss::DescEdoSubViv);
	soap_default_int(soap, &this->ns2__ResolucionTotalImss::IdMovimiento);
	/* transient soap skipped */
}

void ns2__ResolucionTotalImss::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::Regimen);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::TipoSeguro);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::TipoPension);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::NombreDatamart);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::SecPension);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::FechaInicio);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::FechaPago);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::FechaResolucion);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::DescRegimen);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::DescTipoPension);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::DescTipoPrestacion);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::DescTipoRetiro);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::DescTipoSeguro);
	soap_serialize_string(soap, &this->ns2__ResolucionTotalImss::DescEdoSubViv);
	/* transient soap skipped */
#endif
}

int ns2__ResolucionTotalImss::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ResolucionTotalImss(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ResolucionTotalImss(struct soap *soap, const char *tag, int id, const ns2__ResolucionTotalImss *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ResolucionTotalImss), type))
		return soap->error;
	if (soap_out_int(soap, "ExisteResolucion", -1, &(a->ns2__ResolucionTotalImss::ExisteResolucion), ""))
		return soap->error;
	if (soap_out_int(soap, "ExisteAfiliado", -1, &(a->ns2__ResolucionTotalImss::ExisteAfiliado), ""))
		return soap->error;
	if (soap_out_string(soap, "Regimen", -1, &(a->ns2__ResolucionTotalImss::Regimen), ""))
		return soap->error;
	if (soap_out_string(soap, "TipoSeguro", -1, &(a->ns2__ResolucionTotalImss::TipoSeguro), ""))
		return soap->error;
	if (soap_out_string(soap, "TipoPension", -1, &(a->ns2__ResolucionTotalImss::TipoPension), ""))
		return soap->error;
	if (soap_out_int(soap, "TipoPrestacion", -1, &(a->ns2__ResolucionTotalImss::TipoPrestacion), ""))
		return soap->error;
	if (soap_out_string(soap, "NombreDatamart", -1, &(a->ns2__ResolucionTotalImss::NombreDatamart), ""))
		return soap->error;
	if (soap_out_int(soap, "Folio", -1, &(a->ns2__ResolucionTotalImss::Folio), ""))
		return soap->error;
	if (soap_out_string(soap, "SecPension", -1, &(a->ns2__ResolucionTotalImss::SecPension), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaInicio", -1, &(a->ns2__ResolucionTotalImss::FechaInicio), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaPago", -1, &(a->ns2__ResolucionTotalImss::FechaPago), ""))
		return soap->error;
	if (soap_out_int(soap, "SemanasCotizadas", -1, &(a->ns2__ResolucionTotalImss::SemanasCotizadas), ""))
		return soap->error;
	if (soap_out_int(soap, "DiagDatamart", -1, &(a->ns2__ResolucionTotalImss::DiagDatamart), ""))
		return soap->error;
	if (soap_out_int(soap, "EstadoSubViv", -1, &(a->ns2__ResolucionTotalImss::EstadoSubViv), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaResolucion", -1, &(a->ns2__ResolucionTotalImss::FechaResolucion), ""))
		return soap->error;
	if (soap_out_string(soap, "DescRegimen", -1, &(a->ns2__ResolucionTotalImss::DescRegimen), ""))
		return soap->error;
	if (soap_out_string(soap, "DescTipoPension", -1, &(a->ns2__ResolucionTotalImss::DescTipoPension), ""))
		return soap->error;
	if (soap_out_string(soap, "DescTipoPrestacion", -1, &(a->ns2__ResolucionTotalImss::DescTipoPrestacion), ""))
		return soap->error;
	if (soap_out_string(soap, "DescTipoRetiro", -1, &(a->ns2__ResolucionTotalImss::DescTipoRetiro), ""))
		return soap->error;
	if (soap_out_string(soap, "DescTipoSeguro", -1, &(a->ns2__ResolucionTotalImss::DescTipoSeguro), ""))
		return soap->error;
	if (soap_out_string(soap, "DescEdoSubViv", -1, &(a->ns2__ResolucionTotalImss::DescEdoSubViv), ""))
		return soap->error;
	if (soap_out_int(soap, "IdMovimiento", -1, &(a->ns2__ResolucionTotalImss::IdMovimiento), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ResolucionTotalImss::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ResolucionTotalImss(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ResolucionTotalImss * SOAP_FMAC4 soap_in_ns2__ResolucionTotalImss(struct soap *soap, const char *tag, ns2__ResolucionTotalImss *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ResolucionTotalImss *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ResolucionTotalImss, sizeof(ns2__ResolucionTotalImss), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ResolucionTotalImss)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ResolucionTotalImss *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ExisteResolucion1 = 1;
	size_t soap_flag_ExisteAfiliado1 = 1;
	size_t soap_flag_Regimen1 = 1;
	size_t soap_flag_TipoSeguro1 = 1;
	size_t soap_flag_TipoPension1 = 1;
	size_t soap_flag_TipoPrestacion1 = 1;
	size_t soap_flag_NombreDatamart1 = 1;
	size_t soap_flag_Folio1 = 1;
	size_t soap_flag_SecPension1 = 1;
	size_t soap_flag_FechaInicio1 = 1;
	size_t soap_flag_FechaPago1 = 1;
	size_t soap_flag_SemanasCotizadas1 = 1;
	size_t soap_flag_DiagDatamart1 = 1;
	size_t soap_flag_EstadoSubViv1 = 1;
	size_t soap_flag_FechaResolucion1 = 1;
	size_t soap_flag_DescRegimen1 = 1;
	size_t soap_flag_DescTipoPension1 = 1;
	size_t soap_flag_DescTipoPrestacion1 = 1;
	size_t soap_flag_DescTipoRetiro1 = 1;
	size_t soap_flag_DescTipoSeguro1 = 1;
	size_t soap_flag_DescEdoSubViv1 = 1;
	size_t soap_flag_IdMovimiento1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExisteResolucion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ExisteResolucion", &(a->ns2__ResolucionTotalImss::ExisteResolucion), "xsd:int"))
				{	soap_flag_ExisteResolucion1--;
					continue;
				}
			if (soap_flag_ExisteAfiliado1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ExisteAfiliado", &(a->ns2__ResolucionTotalImss::ExisteAfiliado), "xsd:int"))
				{	soap_flag_ExisteAfiliado1--;
					continue;
				}
			if (soap_flag_Regimen1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Regimen", &(a->ns2__ResolucionTotalImss::Regimen), "xsd:string"))
				{	soap_flag_Regimen1--;
					continue;
				}
			if (soap_flag_TipoSeguro1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "TipoSeguro", &(a->ns2__ResolucionTotalImss::TipoSeguro), "xsd:string"))
				{	soap_flag_TipoSeguro1--;
					continue;
				}
			if (soap_flag_TipoPension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "TipoPension", &(a->ns2__ResolucionTotalImss::TipoPension), "xsd:string"))
				{	soap_flag_TipoPension1--;
					continue;
				}
			if (soap_flag_TipoPrestacion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TipoPrestacion", &(a->ns2__ResolucionTotalImss::TipoPrestacion), "xsd:int"))
				{	soap_flag_TipoPrestacion1--;
					continue;
				}
			if (soap_flag_NombreDatamart1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "NombreDatamart", &(a->ns2__ResolucionTotalImss::NombreDatamart), "xsd:string"))
				{	soap_flag_NombreDatamart1--;
					continue;
				}
			if (soap_flag_Folio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Folio", &(a->ns2__ResolucionTotalImss::Folio), "xsd:int"))
				{	soap_flag_Folio1--;
					continue;
				}
			if (soap_flag_SecPension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SecPension", &(a->ns2__ResolucionTotalImss::SecPension), "xsd:string"))
				{	soap_flag_SecPension1--;
					continue;
				}
			if (soap_flag_FechaInicio1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaInicio", &(a->ns2__ResolucionTotalImss::FechaInicio), "xsd:string"))
				{	soap_flag_FechaInicio1--;
					continue;
				}
			if (soap_flag_FechaPago1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaPago", &(a->ns2__ResolucionTotalImss::FechaPago), "xsd:string"))
				{	soap_flag_FechaPago1--;
					continue;
				}
			if (soap_flag_SemanasCotizadas1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "SemanasCotizadas", &(a->ns2__ResolucionTotalImss::SemanasCotizadas), "xsd:int"))
				{	soap_flag_SemanasCotizadas1--;
					continue;
				}
			if (soap_flag_DiagDatamart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "DiagDatamart", &(a->ns2__ResolucionTotalImss::DiagDatamart), "xsd:int"))
				{	soap_flag_DiagDatamart1--;
					continue;
				}
			if (soap_flag_EstadoSubViv1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "EstadoSubViv", &(a->ns2__ResolucionTotalImss::EstadoSubViv), "xsd:int"))
				{	soap_flag_EstadoSubViv1--;
					continue;
				}
			if (soap_flag_FechaResolucion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaResolucion", &(a->ns2__ResolucionTotalImss::FechaResolucion), "xsd:string"))
				{	soap_flag_FechaResolucion1--;
					continue;
				}
			if (soap_flag_DescRegimen1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "DescRegimen", &(a->ns2__ResolucionTotalImss::DescRegimen), "xsd:string"))
				{	soap_flag_DescRegimen1--;
					continue;
				}
			if (soap_flag_DescTipoPension1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "DescTipoPension", &(a->ns2__ResolucionTotalImss::DescTipoPension), "xsd:string"))
				{	soap_flag_DescTipoPension1--;
					continue;
				}
			if (soap_flag_DescTipoPrestacion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "DescTipoPrestacion", &(a->ns2__ResolucionTotalImss::DescTipoPrestacion), "xsd:string"))
				{	soap_flag_DescTipoPrestacion1--;
					continue;
				}
			if (soap_flag_DescTipoRetiro1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "DescTipoRetiro", &(a->ns2__ResolucionTotalImss::DescTipoRetiro), "xsd:string"))
				{	soap_flag_DescTipoRetiro1--;
					continue;
				}
			if (soap_flag_DescTipoSeguro1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "DescTipoSeguro", &(a->ns2__ResolucionTotalImss::DescTipoSeguro), "xsd:string"))
				{	soap_flag_DescTipoSeguro1--;
					continue;
				}
			if (soap_flag_DescEdoSubViv1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "DescEdoSubViv", &(a->ns2__ResolucionTotalImss::DescEdoSubViv), "xsd:string"))
				{	soap_flag_DescEdoSubViv1--;
					continue;
				}
			if (soap_flag_IdMovimiento1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "IdMovimiento", &(a->ns2__ResolucionTotalImss::IdMovimiento), "xsd:int"))
				{	soap_flag_IdMovimiento1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ResolucionTotalImss *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ResolucionTotalImss, 0, sizeof(ns2__ResolucionTotalImss), 0, soap_copy_ns2__ResolucionTotalImss);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ExisteResolucion1 > 0 || soap_flag_ExisteAfiliado1 > 0 || soap_flag_TipoPrestacion1 > 0 || soap_flag_Folio1 > 0 || soap_flag_SemanasCotizadas1 > 0 || soap_flag_DiagDatamart1 > 0 || soap_flag_EstadoSubViv1 > 0 || soap_flag_IdMovimiento1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ResolucionTotalImss::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ResolucionTotalImss);
	if (this->soap_out(soap, tag?tag:"ns2:ResolucionTotalImss", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ResolucionTotalImss::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ResolucionTotalImss(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ResolucionTotalImss * SOAP_FMAC4 soap_get_ns2__ResolucionTotalImss(struct soap *soap, ns2__ResolucionTotalImss *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ResolucionTotalImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ResolucionTotalImss * SOAP_FMAC2 soap_instantiate_ns2__ResolucionTotalImss(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ResolucionTotalImss(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ResolucionTotalImss, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ResolucionTotalImss);
		if (size)
			*size = sizeof(ns2__ResolucionTotalImss);
		((ns2__ResolucionTotalImss*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ResolucionTotalImss, n);
		if (size)
			*size = n * sizeof(ns2__ResolucionTotalImss);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ResolucionTotalImss*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ResolucionTotalImss*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ResolucionTotalImss(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ResolucionTotalImss %p -> %p\n", q, p));
	*(ns2__ResolucionTotalImss*)p = *(ns2__ResolucionTotalImss*)q;
}

void ns2__ParamResolucionTotalImssRI::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__ParamResolucionTotalImssRI::Opcion);
	soap_default_string(soap, &this->ns2__ParamResolucionTotalImssRI::Nss);
	soap_default_string(soap, &this->ns2__ParamResolucionTotalImssRI::Curp);
	soap_default_int(soap, &this->ns2__ParamResolucionTotalImssRI::Documento);
	/* transient soap skipped */
}

void ns2__ParamResolucionTotalImssRI::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParamResolucionTotalImssRI::Nss);
	soap_serialize_string(soap, &this->ns2__ParamResolucionTotalImssRI::Curp);
	/* transient soap skipped */
#endif
}

int ns2__ParamResolucionTotalImssRI::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParamResolucionTotalImssRI(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParamResolucionTotalImssRI(struct soap *soap, const char *tag, int id, const ns2__ParamResolucionTotalImssRI *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParamResolucionTotalImssRI), type))
		return soap->error;
	if (soap_out_int(soap, "Opcion", -1, &(a->ns2__ParamResolucionTotalImssRI::Opcion), ""))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ParamResolucionTotalImssRI::Nss), ""))
		return soap->error;
	if (soap_out_string(soap, "Curp", -1, &(a->ns2__ParamResolucionTotalImssRI::Curp), ""))
		return soap->error;
	if (soap_out_int(soap, "Documento", -1, &(a->ns2__ParamResolucionTotalImssRI::Documento), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParamResolucionTotalImssRI::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParamResolucionTotalImssRI(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParamResolucionTotalImssRI * SOAP_FMAC4 soap_in_ns2__ParamResolucionTotalImssRI(struct soap *soap, const char *tag, ns2__ParamResolucionTotalImssRI *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParamResolucionTotalImssRI *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParamResolucionTotalImssRI, sizeof(ns2__ParamResolucionTotalImssRI), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParamResolucionTotalImssRI)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParamResolucionTotalImssRI *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Opcion1 = 1;
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_Curp1 = 1;
	size_t soap_flag_Documento1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Opcion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Opcion", &(a->ns2__ParamResolucionTotalImssRI::Opcion), "xsd:int"))
				{	soap_flag_Opcion1--;
					continue;
				}
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ParamResolucionTotalImssRI::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_Curp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Curp", &(a->ns2__ParamResolucionTotalImssRI::Curp), "xsd:string"))
				{	soap_flag_Curp1--;
					continue;
				}
			if (soap_flag_Documento1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Documento", &(a->ns2__ParamResolucionTotalImssRI::Documento), "xsd:int"))
				{	soap_flag_Documento1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParamResolucionTotalImssRI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParamResolucionTotalImssRI, 0, sizeof(ns2__ParamResolucionTotalImssRI), 0, soap_copy_ns2__ParamResolucionTotalImssRI);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Opcion1 > 0 || soap_flag_Documento1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ParamResolucionTotalImssRI::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParamResolucionTotalImssRI);
	if (this->soap_out(soap, tag?tag:"ns2:ParamResolucionTotalImssRI", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParamResolucionTotalImssRI::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParamResolucionTotalImssRI(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParamResolucionTotalImssRI * SOAP_FMAC4 soap_get_ns2__ParamResolucionTotalImssRI(struct soap *soap, ns2__ParamResolucionTotalImssRI *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParamResolucionTotalImssRI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParamResolucionTotalImssRI * SOAP_FMAC2 soap_instantiate_ns2__ParamResolucionTotalImssRI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParamResolucionTotalImssRI(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParamResolucionTotalImssRI, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParamResolucionTotalImssRI);
		if (size)
			*size = sizeof(ns2__ParamResolucionTotalImssRI);
		((ns2__ParamResolucionTotalImssRI*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParamResolucionTotalImssRI, n);
		if (size)
			*size = n * sizeof(ns2__ParamResolucionTotalImssRI);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParamResolucionTotalImssRI*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParamResolucionTotalImssRI*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParamResolucionTotalImssRI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParamResolucionTotalImssRI %p -> %p\n", q, p));
	*(ns2__ParamResolucionTotalImssRI*)p = *(ns2__ParamResolucionTotalImssRI*)q;
}

void ns2__ParamResolucionTotalImss::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__ParamResolucionTotalImss::Opcion);
	soap_default_string(soap, &this->ns2__ParamResolucionTotalImss::Nss);
	soap_default_string(soap, &this->ns2__ParamResolucionTotalImss::Curp);
	/* transient soap skipped */
}

void ns2__ParamResolucionTotalImss::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParamResolucionTotalImss::Nss);
	soap_serialize_string(soap, &this->ns2__ParamResolucionTotalImss::Curp);
	/* transient soap skipped */
#endif
}

int ns2__ParamResolucionTotalImss::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParamResolucionTotalImss(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParamResolucionTotalImss(struct soap *soap, const char *tag, int id, const ns2__ParamResolucionTotalImss *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParamResolucionTotalImss), type))
		return soap->error;
	if (soap_out_int(soap, "Opcion", -1, &(a->ns2__ParamResolucionTotalImss::Opcion), ""))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ParamResolucionTotalImss::Nss), ""))
		return soap->error;
	if (soap_out_string(soap, "Curp", -1, &(a->ns2__ParamResolucionTotalImss::Curp), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParamResolucionTotalImss::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParamResolucionTotalImss(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParamResolucionTotalImss * SOAP_FMAC4 soap_in_ns2__ParamResolucionTotalImss(struct soap *soap, const char *tag, ns2__ParamResolucionTotalImss *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParamResolucionTotalImss *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParamResolucionTotalImss, sizeof(ns2__ParamResolucionTotalImss), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParamResolucionTotalImss)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParamResolucionTotalImss *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Opcion1 = 1;
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_Curp1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Opcion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Opcion", &(a->ns2__ParamResolucionTotalImss::Opcion), "xsd:int"))
				{	soap_flag_Opcion1--;
					continue;
				}
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ParamResolucionTotalImss::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_Curp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Curp", &(a->ns2__ParamResolucionTotalImss::Curp), "xsd:string"))
				{	soap_flag_Curp1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParamResolucionTotalImss *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParamResolucionTotalImss, 0, sizeof(ns2__ParamResolucionTotalImss), 0, soap_copy_ns2__ParamResolucionTotalImss);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Opcion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ParamResolucionTotalImss::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParamResolucionTotalImss);
	if (this->soap_out(soap, tag?tag:"ns2:ParamResolucionTotalImss", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParamResolucionTotalImss::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParamResolucionTotalImss(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParamResolucionTotalImss * SOAP_FMAC4 soap_get_ns2__ParamResolucionTotalImss(struct soap *soap, ns2__ParamResolucionTotalImss *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParamResolucionTotalImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParamResolucionTotalImss * SOAP_FMAC2 soap_instantiate_ns2__ParamResolucionTotalImss(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParamResolucionTotalImss(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParamResolucionTotalImss, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParamResolucionTotalImss);
		if (size)
			*size = sizeof(ns2__ParamResolucionTotalImss);
		((ns2__ParamResolucionTotalImss*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParamResolucionTotalImss, n);
		if (size)
			*size = n * sizeof(ns2__ParamResolucionTotalImss);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParamResolucionTotalImss*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParamResolucionTotalImss*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParamResolucionTotalImss(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParamResolucionTotalImss %p -> %p\n", q, p));
	*(ns2__ParamResolucionTotalImss*)p = *(ns2__ParamResolucionTotalImss*)q;
}

void ns2__RespuestaComplementoResolucion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaComplementoResolucion::EstadoProc = NULL;
	this->ns2__RespuestaComplementoResolucion::ResolucionComplemento = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaComplementoResolucion::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaComplementoResolucion::EstadoProc);
	soap_serialize_PointerTons2__ComplementoResolucion(soap, &this->ns2__RespuestaComplementoResolucion::ResolucionComplemento);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaComplementoResolucion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaComplementoResolucion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaComplementoResolucion(struct soap *soap, const char *tag, int id, const ns2__RespuestaComplementoResolucion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaComplementoResolucion), type))
		return soap->error;
	if (a->ns2__RespuestaComplementoResolucion::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaComplementoResolucion::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaComplementoResolucion::ResolucionComplemento)
	{	if (soap_out_PointerTons2__ComplementoResolucion(soap, "ResolucionComplemento", -1, &a->ns2__RespuestaComplementoResolucion::ResolucionComplemento, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ResolucionComplemento"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaComplementoResolucion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaComplementoResolucion(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaComplementoResolucion * SOAP_FMAC4 soap_in_ns2__RespuestaComplementoResolucion(struct soap *soap, const char *tag, ns2__RespuestaComplementoResolucion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaComplementoResolucion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaComplementoResolucion, sizeof(ns2__RespuestaComplementoResolucion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaComplementoResolucion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaComplementoResolucion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_ResolucionComplemento1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaComplementoResolucion::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_ResolucionComplemento1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ComplementoResolucion(soap, "ResolucionComplemento", &(a->ns2__RespuestaComplementoResolucion::ResolucionComplemento), "ns2:ComplementoResolucion"))
				{	soap_flag_ResolucionComplemento1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaComplementoResolucion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaComplementoResolucion, 0, sizeof(ns2__RespuestaComplementoResolucion), 0, soap_copy_ns2__RespuestaComplementoResolucion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_ResolucionComplemento1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaComplementoResolucion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaComplementoResolucion);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaComplementoResolucion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaComplementoResolucion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaComplementoResolucion(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaComplementoResolucion * SOAP_FMAC4 soap_get_ns2__RespuestaComplementoResolucion(struct soap *soap, ns2__RespuestaComplementoResolucion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaComplementoResolucion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaComplementoResolucion * SOAP_FMAC2 soap_instantiate_ns2__RespuestaComplementoResolucion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaComplementoResolucion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaComplementoResolucion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaComplementoResolucion);
		if (size)
			*size = sizeof(ns2__RespuestaComplementoResolucion);
		((ns2__RespuestaComplementoResolucion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaComplementoResolucion, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaComplementoResolucion);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaComplementoResolucion*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaComplementoResolucion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaComplementoResolucion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaComplementoResolucion %p -> %p\n", q, p));
	*(ns2__RespuestaComplementoResolucion*)p = *(ns2__RespuestaComplementoResolucion*)q;
}

void ns2__ComplementoResolucion::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__ComplementoResolucion::IdentificadorComplemento);
	soap_default_int(soap, &this->ns2__ComplementoResolucion::NumeroResolucion);
	soap_default_string(soap, &this->ns2__ComplementoResolucion::MontoPagado);
	soap_default_string(soap, &this->ns2__ComplementoResolucion::MontoPagadoComplemento);
	soap_default_string(soap, &this->ns2__ComplementoResolucion::SaldoRCV);
	soap_default_string(soap, &this->ns2__ComplementoResolucion::SaldoRCVAnterior);
	soap_default_int(soap, &this->ns2__ComplementoResolucion::RespuestaOtroDatamart);
	/* transient soap skipped */
}

void ns2__ComplementoResolucion::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ComplementoResolucion::MontoPagado);
	soap_serialize_string(soap, &this->ns2__ComplementoResolucion::MontoPagadoComplemento);
	soap_serialize_string(soap, &this->ns2__ComplementoResolucion::SaldoRCV);
	soap_serialize_string(soap, &this->ns2__ComplementoResolucion::SaldoRCVAnterior);
	/* transient soap skipped */
#endif
}

int ns2__ComplementoResolucion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ComplementoResolucion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ComplementoResolucion(struct soap *soap, const char *tag, int id, const ns2__ComplementoResolucion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ComplementoResolucion), type))
		return soap->error;
	if (soap_out_int(soap, "IdentificadorComplemento", -1, &(a->ns2__ComplementoResolucion::IdentificadorComplemento), ""))
		return soap->error;
	if (soap_out_int(soap, "NumeroResolucion", -1, &(a->ns2__ComplementoResolucion::NumeroResolucion), ""))
		return soap->error;
	if (soap_out_string(soap, "MontoPagado", -1, &(a->ns2__ComplementoResolucion::MontoPagado), ""))
		return soap->error;
	if (soap_out_string(soap, "MontoPagadoComplemento", -1, &(a->ns2__ComplementoResolucion::MontoPagadoComplemento), ""))
		return soap->error;
	if (soap_out_string(soap, "SaldoRCV", -1, &(a->ns2__ComplementoResolucion::SaldoRCV), ""))
		return soap->error;
	if (soap_out_string(soap, "SaldoRCVAnterior", -1, &(a->ns2__ComplementoResolucion::SaldoRCVAnterior), ""))
		return soap->error;
	if (soap_out_int(soap, "RespuestaOtroDatamart", -1, &(a->ns2__ComplementoResolucion::RespuestaOtroDatamart), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ComplementoResolucion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ComplementoResolucion(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ComplementoResolucion * SOAP_FMAC4 soap_in_ns2__ComplementoResolucion(struct soap *soap, const char *tag, ns2__ComplementoResolucion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ComplementoResolucion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ComplementoResolucion, sizeof(ns2__ComplementoResolucion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ComplementoResolucion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ComplementoResolucion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_IdentificadorComplemento1 = 1;
	size_t soap_flag_NumeroResolucion1 = 1;
	size_t soap_flag_MontoPagado1 = 1;
	size_t soap_flag_MontoPagadoComplemento1 = 1;
	size_t soap_flag_SaldoRCV1 = 1;
	size_t soap_flag_SaldoRCVAnterior1 = 1;
	size_t soap_flag_RespuestaOtroDatamart1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IdentificadorComplemento1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "IdentificadorComplemento", &(a->ns2__ComplementoResolucion::IdentificadorComplemento), "xsd:int"))
				{	soap_flag_IdentificadorComplemento1--;
					continue;
				}
			if (soap_flag_NumeroResolucion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "NumeroResolucion", &(a->ns2__ComplementoResolucion::NumeroResolucion), "xsd:int"))
				{	soap_flag_NumeroResolucion1--;
					continue;
				}
			if (soap_flag_MontoPagado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "MontoPagado", &(a->ns2__ComplementoResolucion::MontoPagado), "xsd:string"))
				{	soap_flag_MontoPagado1--;
					continue;
				}
			if (soap_flag_MontoPagadoComplemento1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "MontoPagadoComplemento", &(a->ns2__ComplementoResolucion::MontoPagadoComplemento), "xsd:string"))
				{	soap_flag_MontoPagadoComplemento1--;
					continue;
				}
			if (soap_flag_SaldoRCV1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SaldoRCV", &(a->ns2__ComplementoResolucion::SaldoRCV), "xsd:string"))
				{	soap_flag_SaldoRCV1--;
					continue;
				}
			if (soap_flag_SaldoRCVAnterior1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SaldoRCVAnterior", &(a->ns2__ComplementoResolucion::SaldoRCVAnterior), "xsd:string"))
				{	soap_flag_SaldoRCVAnterior1--;
					continue;
				}
			if (soap_flag_RespuestaOtroDatamart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "RespuestaOtroDatamart", &(a->ns2__ComplementoResolucion::RespuestaOtroDatamart), "xsd:int"))
				{	soap_flag_RespuestaOtroDatamart1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ComplementoResolucion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ComplementoResolucion, 0, sizeof(ns2__ComplementoResolucion), 0, soap_copy_ns2__ComplementoResolucion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IdentificadorComplemento1 > 0 || soap_flag_NumeroResolucion1 > 0 || soap_flag_RespuestaOtroDatamart1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ComplementoResolucion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ComplementoResolucion);
	if (this->soap_out(soap, tag?tag:"ns2:ComplementoResolucion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ComplementoResolucion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ComplementoResolucion(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ComplementoResolucion * SOAP_FMAC4 soap_get_ns2__ComplementoResolucion(struct soap *soap, ns2__ComplementoResolucion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ComplementoResolucion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ComplementoResolucion * SOAP_FMAC2 soap_instantiate_ns2__ComplementoResolucion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ComplementoResolucion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ComplementoResolucion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ComplementoResolucion);
		if (size)
			*size = sizeof(ns2__ComplementoResolucion);
		((ns2__ComplementoResolucion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ComplementoResolucion, n);
		if (size)
			*size = n * sizeof(ns2__ComplementoResolucion);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ComplementoResolucion*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ComplementoResolucion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ComplementoResolucion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ComplementoResolucion %p -> %p\n", q, p));
	*(ns2__ComplementoResolucion*)p = *(ns2__ComplementoResolucion*)q;
}

void ns2__RespuestaDatosResolucion::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaDatosResolucion::EstadoProc = NULL;
	this->ns2__RespuestaDatosResolucion::Resolucion = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaDatosResolucion::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaDatosResolucion::EstadoProc);
	soap_serialize_PointerTons2__DatosResolucion(soap, &this->ns2__RespuestaDatosResolucion::Resolucion);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaDatosResolucion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaDatosResolucion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaDatosResolucion(struct soap *soap, const char *tag, int id, const ns2__RespuestaDatosResolucion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaDatosResolucion), type))
		return soap->error;
	if (a->ns2__RespuestaDatosResolucion::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaDatosResolucion::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaDatosResolucion::Resolucion)
	{	if (soap_out_PointerTons2__DatosResolucion(soap, "Resolucion", -1, &a->ns2__RespuestaDatosResolucion::Resolucion, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Resolucion"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaDatosResolucion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaDatosResolucion(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaDatosResolucion * SOAP_FMAC4 soap_in_ns2__RespuestaDatosResolucion(struct soap *soap, const char *tag, ns2__RespuestaDatosResolucion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaDatosResolucion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaDatosResolucion, sizeof(ns2__RespuestaDatosResolucion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaDatosResolucion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaDatosResolucion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_Resolucion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaDatosResolucion::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_Resolucion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__DatosResolucion(soap, "Resolucion", &(a->ns2__RespuestaDatosResolucion::Resolucion), "ns2:DatosResolucion"))
				{	soap_flag_Resolucion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaDatosResolucion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaDatosResolucion, 0, sizeof(ns2__RespuestaDatosResolucion), 0, soap_copy_ns2__RespuestaDatosResolucion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_Resolucion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaDatosResolucion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaDatosResolucion);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaDatosResolucion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaDatosResolucion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaDatosResolucion(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaDatosResolucion * SOAP_FMAC4 soap_get_ns2__RespuestaDatosResolucion(struct soap *soap, ns2__RespuestaDatosResolucion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaDatosResolucion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaDatosResolucion * SOAP_FMAC2 soap_instantiate_ns2__RespuestaDatosResolucion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaDatosResolucion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaDatosResolucion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaDatosResolucion);
		if (size)
			*size = sizeof(ns2__RespuestaDatosResolucion);
		((ns2__RespuestaDatosResolucion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaDatosResolucion, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaDatosResolucion);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaDatosResolucion*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaDatosResolucion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaDatosResolucion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaDatosResolucion %p -> %p\n", q, p));
	*(ns2__RespuestaDatosResolucion*)p = *(ns2__RespuestaDatosResolucion*)q;
}

void ns2__DatosResolucion::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__DatosResolucion::Nss);
	soap_default_string(soap, &this->ns2__DatosResolucion::FechaInicioVigencia);
	soap_default_string(soap, &this->ns2__DatosResolucion::FechaFinVigencia);
	soap_default_int(soap, &this->ns2__DatosResolucion::NumeroResolucion);
	/* transient soap skipped */
}

void ns2__DatosResolucion::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__DatosResolucion::Nss);
	soap_serialize_string(soap, &this->ns2__DatosResolucion::FechaInicioVigencia);
	soap_serialize_string(soap, &this->ns2__DatosResolucion::FechaFinVigencia);
	/* transient soap skipped */
#endif
}

int ns2__DatosResolucion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__DatosResolucion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__DatosResolucion(struct soap *soap, const char *tag, int id, const ns2__DatosResolucion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__DatosResolucion), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__DatosResolucion::Nss), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaInicioVigencia", -1, &(a->ns2__DatosResolucion::FechaInicioVigencia), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaFinVigencia", -1, &(a->ns2__DatosResolucion::FechaFinVigencia), ""))
		return soap->error;
	if (soap_out_int(soap, "NumeroResolucion", -1, &(a->ns2__DatosResolucion::NumeroResolucion), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__DatosResolucion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__DatosResolucion(soap, tag, this, type);
}

SOAP_FMAC3 ns2__DatosResolucion * SOAP_FMAC4 soap_in_ns2__DatosResolucion(struct soap *soap, const char *tag, ns2__DatosResolucion *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__DatosResolucion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__DatosResolucion, sizeof(ns2__DatosResolucion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__DatosResolucion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__DatosResolucion *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_FechaInicioVigencia1 = 1;
	size_t soap_flag_FechaFinVigencia1 = 1;
	size_t soap_flag_NumeroResolucion1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__DatosResolucion::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_FechaInicioVigencia1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaInicioVigencia", &(a->ns2__DatosResolucion::FechaInicioVigencia), "xsd:string"))
				{	soap_flag_FechaInicioVigencia1--;
					continue;
				}
			if (soap_flag_FechaFinVigencia1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaFinVigencia", &(a->ns2__DatosResolucion::FechaFinVigencia), "xsd:string"))
				{	soap_flag_FechaFinVigencia1--;
					continue;
				}
			if (soap_flag_NumeroResolucion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "NumeroResolucion", &(a->ns2__DatosResolucion::NumeroResolucion), "xsd:int"))
				{	soap_flag_NumeroResolucion1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__DatosResolucion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__DatosResolucion, 0, sizeof(ns2__DatosResolucion), 0, soap_copy_ns2__DatosResolucion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NumeroResolucion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__DatosResolucion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__DatosResolucion);
	if (this->soap_out(soap, tag?tag:"ns2:DatosResolucion", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__DatosResolucion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__DatosResolucion(soap, this, tag, type);
}

SOAP_FMAC3 ns2__DatosResolucion * SOAP_FMAC4 soap_get_ns2__DatosResolucion(struct soap *soap, ns2__DatosResolucion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__DatosResolucion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__DatosResolucion * SOAP_FMAC2 soap_instantiate_ns2__DatosResolucion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__DatosResolucion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__DatosResolucion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__DatosResolucion);
		if (size)
			*size = sizeof(ns2__DatosResolucion);
		((ns2__DatosResolucion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__DatosResolucion, n);
		if (size)
			*size = n * sizeof(ns2__DatosResolucion);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__DatosResolucion*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__DatosResolucion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__DatosResolucion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__DatosResolucion %p -> %p\n", q, p));
	*(ns2__DatosResolucion*)p = *(ns2__DatosResolucion*)q;
}

void ns2__RespuestaMontosFechasDatamart::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaMontosFechasDatamart::EstadoProc = NULL;
	this->ns2__RespuestaMontosFechasDatamart::MontosFechaDat = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaMontosFechasDatamart::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaMontosFechasDatamart::EstadoProc);
	soap_serialize_PointerTons2__MontosFechasDatamart(soap, &this->ns2__RespuestaMontosFechasDatamart::MontosFechaDat);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaMontosFechasDatamart::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaMontosFechasDatamart(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaMontosFechasDatamart(struct soap *soap, const char *tag, int id, const ns2__RespuestaMontosFechasDatamart *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaMontosFechasDatamart), type))
		return soap->error;
	if (a->ns2__RespuestaMontosFechasDatamart::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaMontosFechasDatamart::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaMontosFechasDatamart::MontosFechaDat)
	{	if (soap_out_PointerTons2__MontosFechasDatamart(soap, "MontosFechaDat", -1, &a->ns2__RespuestaMontosFechasDatamart::MontosFechaDat, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "MontosFechaDat"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaMontosFechasDatamart::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaMontosFechasDatamart(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaMontosFechasDatamart * SOAP_FMAC4 soap_in_ns2__RespuestaMontosFechasDatamart(struct soap *soap, const char *tag, ns2__RespuestaMontosFechasDatamart *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaMontosFechasDatamart *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaMontosFechasDatamart, sizeof(ns2__RespuestaMontosFechasDatamart), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaMontosFechasDatamart)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaMontosFechasDatamart *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_MontosFechaDat1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaMontosFechasDatamart::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_MontosFechaDat1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__MontosFechasDatamart(soap, "MontosFechaDat", &(a->ns2__RespuestaMontosFechasDatamart::MontosFechaDat), "ns2:MontosFechasDatamart"))
				{	soap_flag_MontosFechaDat1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaMontosFechasDatamart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaMontosFechasDatamart, 0, sizeof(ns2__RespuestaMontosFechasDatamart), 0, soap_copy_ns2__RespuestaMontosFechasDatamart);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_MontosFechaDat1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaMontosFechasDatamart::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaMontosFechasDatamart);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaMontosFechasDatamart", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaMontosFechasDatamart::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaMontosFechasDatamart(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaMontosFechasDatamart * SOAP_FMAC4 soap_get_ns2__RespuestaMontosFechasDatamart(struct soap *soap, ns2__RespuestaMontosFechasDatamart *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaMontosFechasDatamart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaMontosFechasDatamart * SOAP_FMAC2 soap_instantiate_ns2__RespuestaMontosFechasDatamart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaMontosFechasDatamart(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaMontosFechasDatamart, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaMontosFechasDatamart);
		if (size)
			*size = sizeof(ns2__RespuestaMontosFechasDatamart);
		((ns2__RespuestaMontosFechasDatamart*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaMontosFechasDatamart, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaMontosFechasDatamart);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaMontosFechasDatamart*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaMontosFechasDatamart*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaMontosFechasDatamart(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaMontosFechasDatamart %p -> %p\n", q, p));
	*(ns2__RespuestaMontosFechasDatamart*)p = *(ns2__RespuestaMontosFechasDatamart*)q;
}

void ns2__MontosFechasDatamart::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__MontosFechasDatamart::Nss);
	soap_default_string(soap, &this->ns2__MontosFechasDatamart::FechaMatrimonioDesempleo);
	soap_default_string(soap, &this->ns2__MontosFechasDatamart::FechaInicioVigencia);
	soap_default_string(soap, &this->ns2__MontosFechasDatamart::SalarioBaseA);
	soap_default_string(soap, &this->ns2__MontosFechasDatamart::SalarioBaseB);
	soap_default_string(soap, &this->ns2__MontosFechasDatamart::UltimoSalarioBaseCotizado);
	soap_default_string(soap, &this->ns2__MontosFechasDatamart::Ultimas250SemanasSBC);
	/* transient soap skipped */
}

void ns2__MontosFechasDatamart::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__MontosFechasDatamart::Nss);
	soap_serialize_string(soap, &this->ns2__MontosFechasDatamart::FechaMatrimonioDesempleo);
	soap_serialize_string(soap, &this->ns2__MontosFechasDatamart::FechaInicioVigencia);
	soap_serialize_string(soap, &this->ns2__MontosFechasDatamart::SalarioBaseA);
	soap_serialize_string(soap, &this->ns2__MontosFechasDatamart::SalarioBaseB);
	soap_serialize_string(soap, &this->ns2__MontosFechasDatamart::UltimoSalarioBaseCotizado);
	soap_serialize_string(soap, &this->ns2__MontosFechasDatamart::Ultimas250SemanasSBC);
	/* transient soap skipped */
#endif
}

int ns2__MontosFechasDatamart::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__MontosFechasDatamart(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MontosFechasDatamart(struct soap *soap, const char *tag, int id, const ns2__MontosFechasDatamart *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MontosFechasDatamart), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__MontosFechasDatamart::Nss), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaMatrimonioDesempleo", -1, &(a->ns2__MontosFechasDatamart::FechaMatrimonioDesempleo), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaInicioVigencia", -1, &(a->ns2__MontosFechasDatamart::FechaInicioVigencia), ""))
		return soap->error;
	if (soap_out_string(soap, "SalarioBaseA", -1, &(a->ns2__MontosFechasDatamart::SalarioBaseA), ""))
		return soap->error;
	if (soap_out_string(soap, "SalarioBaseB", -1, &(a->ns2__MontosFechasDatamart::SalarioBaseB), ""))
		return soap->error;
	if (soap_out_string(soap, "UltimoSalarioBaseCotizado", -1, &(a->ns2__MontosFechasDatamart::UltimoSalarioBaseCotizado), ""))
		return soap->error;
	if (soap_out_string(soap, "Ultimas250SemanasSBC", -1, &(a->ns2__MontosFechasDatamart::Ultimas250SemanasSBC), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__MontosFechasDatamart::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__MontosFechasDatamart(soap, tag, this, type);
}

SOAP_FMAC3 ns2__MontosFechasDatamart * SOAP_FMAC4 soap_in_ns2__MontosFechasDatamart(struct soap *soap, const char *tag, ns2__MontosFechasDatamart *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__MontosFechasDatamart *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MontosFechasDatamart, sizeof(ns2__MontosFechasDatamart), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__MontosFechasDatamart)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__MontosFechasDatamart *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_FechaMatrimonioDesempleo1 = 1;
	size_t soap_flag_FechaInicioVigencia1 = 1;
	size_t soap_flag_SalarioBaseA1 = 1;
	size_t soap_flag_SalarioBaseB1 = 1;
	size_t soap_flag_UltimoSalarioBaseCotizado1 = 1;
	size_t soap_flag_Ultimas250SemanasSBC1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__MontosFechasDatamart::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_FechaMatrimonioDesempleo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaMatrimonioDesempleo", &(a->ns2__MontosFechasDatamart::FechaMatrimonioDesempleo), "xsd:string"))
				{	soap_flag_FechaMatrimonioDesempleo1--;
					continue;
				}
			if (soap_flag_FechaInicioVigencia1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaInicioVigencia", &(a->ns2__MontosFechasDatamart::FechaInicioVigencia), "xsd:string"))
				{	soap_flag_FechaInicioVigencia1--;
					continue;
				}
			if (soap_flag_SalarioBaseA1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SalarioBaseA", &(a->ns2__MontosFechasDatamart::SalarioBaseA), "xsd:string"))
				{	soap_flag_SalarioBaseA1--;
					continue;
				}
			if (soap_flag_SalarioBaseB1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SalarioBaseB", &(a->ns2__MontosFechasDatamart::SalarioBaseB), "xsd:string"))
				{	soap_flag_SalarioBaseB1--;
					continue;
				}
			if (soap_flag_UltimoSalarioBaseCotizado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "UltimoSalarioBaseCotizado", &(a->ns2__MontosFechasDatamart::UltimoSalarioBaseCotizado), "xsd:string"))
				{	soap_flag_UltimoSalarioBaseCotizado1--;
					continue;
				}
			if (soap_flag_Ultimas250SemanasSBC1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Ultimas250SemanasSBC", &(a->ns2__MontosFechasDatamart::Ultimas250SemanasSBC), "xsd:string"))
				{	soap_flag_Ultimas250SemanasSBC1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__MontosFechasDatamart *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MontosFechasDatamart, 0, sizeof(ns2__MontosFechasDatamart), 0, soap_copy_ns2__MontosFechasDatamart);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__MontosFechasDatamart::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__MontosFechasDatamart);
	if (this->soap_out(soap, tag?tag:"ns2:MontosFechasDatamart", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__MontosFechasDatamart::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__MontosFechasDatamart(soap, this, tag, type);
}

SOAP_FMAC3 ns2__MontosFechasDatamart * SOAP_FMAC4 soap_get_ns2__MontosFechasDatamart(struct soap *soap, ns2__MontosFechasDatamart *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MontosFechasDatamart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__MontosFechasDatamart * SOAP_FMAC2 soap_instantiate_ns2__MontosFechasDatamart(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MontosFechasDatamart(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MontosFechasDatamart, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__MontosFechasDatamart);
		if (size)
			*size = sizeof(ns2__MontosFechasDatamart);
		((ns2__MontosFechasDatamart*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__MontosFechasDatamart, n);
		if (size)
			*size = n * sizeof(ns2__MontosFechasDatamart);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__MontosFechasDatamart*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__MontosFechasDatamart*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MontosFechasDatamart(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__MontosFechasDatamart %p -> %p\n", q, p));
	*(ns2__MontosFechasDatamart*)p = *(ns2__MontosFechasDatamart*)q;
}

void ns2__RespuestaValidarResolucionImss::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaValidarResolucionImss::EstadoProc = NULL;
	this->ns2__RespuestaValidarResolucionImss::ResolucionImss = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaValidarResolucionImss::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaValidarResolucionImss::EstadoProc);
	soap_serialize_PointerTons2__ValidarResolucionImss(soap, &this->ns2__RespuestaValidarResolucionImss::ResolucionImss);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaValidarResolucionImss::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaValidarResolucionImss(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaValidarResolucionImss(struct soap *soap, const char *tag, int id, const ns2__RespuestaValidarResolucionImss *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaValidarResolucionImss), type))
		return soap->error;
	if (a->ns2__RespuestaValidarResolucionImss::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaValidarResolucionImss::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaValidarResolucionImss::ResolucionImss)
	{	if (soap_out_PointerTons2__ValidarResolucionImss(soap, "ResolucionImss", -1, &a->ns2__RespuestaValidarResolucionImss::ResolucionImss, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ResolucionImss"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaValidarResolucionImss::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaValidarResolucionImss(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaValidarResolucionImss * SOAP_FMAC4 soap_in_ns2__RespuestaValidarResolucionImss(struct soap *soap, const char *tag, ns2__RespuestaValidarResolucionImss *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaValidarResolucionImss *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaValidarResolucionImss, sizeof(ns2__RespuestaValidarResolucionImss), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaValidarResolucionImss)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaValidarResolucionImss *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_ResolucionImss1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaValidarResolucionImss::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_ResolucionImss1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValidarResolucionImss(soap, "ResolucionImss", &(a->ns2__RespuestaValidarResolucionImss::ResolucionImss), "ns2:ValidarResolucionImss"))
				{	soap_flag_ResolucionImss1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaValidarResolucionImss *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaValidarResolucionImss, 0, sizeof(ns2__RespuestaValidarResolucionImss), 0, soap_copy_ns2__RespuestaValidarResolucionImss);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_ResolucionImss1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaValidarResolucionImss::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaValidarResolucionImss);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaValidarResolucionImss", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaValidarResolucionImss::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaValidarResolucionImss(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaValidarResolucionImss * SOAP_FMAC4 soap_get_ns2__RespuestaValidarResolucionImss(struct soap *soap, ns2__RespuestaValidarResolucionImss *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaValidarResolucionImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaValidarResolucionImss * SOAP_FMAC2 soap_instantiate_ns2__RespuestaValidarResolucionImss(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaValidarResolucionImss(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaValidarResolucionImss, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaValidarResolucionImss);
		if (size)
			*size = sizeof(ns2__RespuestaValidarResolucionImss);
		((ns2__RespuestaValidarResolucionImss*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaValidarResolucionImss, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaValidarResolucionImss);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaValidarResolucionImss*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaValidarResolucionImss*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaValidarResolucionImss(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaValidarResolucionImss %p -> %p\n", q, p));
	*(ns2__RespuestaValidarResolucionImss*)p = *(ns2__RespuestaValidarResolucionImss*)q;
}

void ns2__ValidarResolucionImss::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ValidarResolucionImss::FechaVigencia);
	soap_default_string(soap, &this->ns2__ValidarResolucionImss::FechaVigenciaAnterior);
	soap_default_string(soap, &this->ns2__ValidarResolucionImss::FechaProximaSolicitud);
	soap_default_int(soap, &this->ns2__ValidarResolucionImss::Retorno);
	soap_default_string(soap, &this->ns2__ValidarResolucionImss::Descripcion);
	soap_default_int(soap, &this->ns2__ValidarResolucionImss::DiagnosticoProcesar);
	/* transient soap skipped */
}

void ns2__ValidarResolucionImss::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ValidarResolucionImss::FechaVigencia);
	soap_serialize_string(soap, &this->ns2__ValidarResolucionImss::FechaVigenciaAnterior);
	soap_serialize_string(soap, &this->ns2__ValidarResolucionImss::FechaProximaSolicitud);
	soap_serialize_string(soap, &this->ns2__ValidarResolucionImss::Descripcion);
	/* transient soap skipped */
#endif
}

int ns2__ValidarResolucionImss::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ValidarResolucionImss(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValidarResolucionImss(struct soap *soap, const char *tag, int id, const ns2__ValidarResolucionImss *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValidarResolucionImss), type))
		return soap->error;
	if (soap_out_string(soap, "FechaVigencia", -1, &(a->ns2__ValidarResolucionImss::FechaVigencia), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaVigenciaAnterior", -1, &(a->ns2__ValidarResolucionImss::FechaVigenciaAnterior), ""))
		return soap->error;
	if (soap_out_string(soap, "FechaProximaSolicitud", -1, &(a->ns2__ValidarResolucionImss::FechaProximaSolicitud), ""))
		return soap->error;
	if (soap_out_int(soap, "Retorno", -1, &(a->ns2__ValidarResolucionImss::Retorno), ""))
		return soap->error;
	if (soap_out_string(soap, "Descripcion", -1, &(a->ns2__ValidarResolucionImss::Descripcion), ""))
		return soap->error;
	if (soap_out_int(soap, "DiagnosticoProcesar", -1, &(a->ns2__ValidarResolucionImss::DiagnosticoProcesar), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ValidarResolucionImss::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ValidarResolucionImss(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ValidarResolucionImss * SOAP_FMAC4 soap_in_ns2__ValidarResolucionImss(struct soap *soap, const char *tag, ns2__ValidarResolucionImss *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ValidarResolucionImss *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValidarResolucionImss, sizeof(ns2__ValidarResolucionImss), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ValidarResolucionImss)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ValidarResolucionImss *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_FechaVigencia1 = 1;
	size_t soap_flag_FechaVigenciaAnterior1 = 1;
	size_t soap_flag_FechaProximaSolicitud1 = 1;
	size_t soap_flag_Retorno1 = 1;
	size_t soap_flag_Descripcion1 = 1;
	size_t soap_flag_DiagnosticoProcesar1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FechaVigencia1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaVigencia", &(a->ns2__ValidarResolucionImss::FechaVigencia), "xsd:string"))
				{	soap_flag_FechaVigencia1--;
					continue;
				}
			if (soap_flag_FechaVigenciaAnterior1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaVigenciaAnterior", &(a->ns2__ValidarResolucionImss::FechaVigenciaAnterior), "xsd:string"))
				{	soap_flag_FechaVigenciaAnterior1--;
					continue;
				}
			if (soap_flag_FechaProximaSolicitud1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "FechaProximaSolicitud", &(a->ns2__ValidarResolucionImss::FechaProximaSolicitud), "xsd:string"))
				{	soap_flag_FechaProximaSolicitud1--;
					continue;
				}
			if (soap_flag_Retorno1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Retorno", &(a->ns2__ValidarResolucionImss::Retorno), "xsd:int"))
				{	soap_flag_Retorno1--;
					continue;
				}
			if (soap_flag_Descripcion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Descripcion", &(a->ns2__ValidarResolucionImss::Descripcion), "xsd:string"))
				{	soap_flag_Descripcion1--;
					continue;
				}
			if (soap_flag_DiagnosticoProcesar1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "DiagnosticoProcesar", &(a->ns2__ValidarResolucionImss::DiagnosticoProcesar), "xsd:int"))
				{	soap_flag_DiagnosticoProcesar1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ValidarResolucionImss *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValidarResolucionImss, 0, sizeof(ns2__ValidarResolucionImss), 0, soap_copy_ns2__ValidarResolucionImss);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Retorno1 > 0 || soap_flag_DiagnosticoProcesar1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ValidarResolucionImss::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ValidarResolucionImss);
	if (this->soap_out(soap, tag?tag:"ns2:ValidarResolucionImss", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ValidarResolucionImss::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ValidarResolucionImss(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ValidarResolucionImss * SOAP_FMAC4 soap_get_ns2__ValidarResolucionImss(struct soap *soap, ns2__ValidarResolucionImss *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValidarResolucionImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ValidarResolucionImss * SOAP_FMAC2 soap_instantiate_ns2__ValidarResolucionImss(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValidarResolucionImss(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValidarResolucionImss, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValidarResolucionImss);
		if (size)
			*size = sizeof(ns2__ValidarResolucionImss);
		((ns2__ValidarResolucionImss*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ValidarResolucionImss, n);
		if (size)
			*size = n * sizeof(ns2__ValidarResolucionImss);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ValidarResolucionImss*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ValidarResolucionImss*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValidarResolucionImss(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ValidarResolucionImss %p -> %p\n", q, p));
	*(ns2__ValidarResolucionImss*)p = *(ns2__ValidarResolucionImss*)q;
}

void ns2__SaldoDiarioRetiroParcial::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__SaldoDiarioRetiroParcial::EstadoProc = NULL;
	soap_default_string(soap, &this->ns2__SaldoDiarioRetiroParcial::SaldoPesos);
	/* transient soap skipped */
}

void ns2__SaldoDiarioRetiroParcial::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__SaldoDiarioRetiroParcial::EstadoProc);
	soap_serialize_string(soap, &this->ns2__SaldoDiarioRetiroParcial::SaldoPesos);
	/* transient soap skipped */
#endif
}

int ns2__SaldoDiarioRetiroParcial::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SaldoDiarioRetiroParcial(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SaldoDiarioRetiroParcial(struct soap *soap, const char *tag, int id, const ns2__SaldoDiarioRetiroParcial *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SaldoDiarioRetiroParcial), type))
		return soap->error;
	if (a->ns2__SaldoDiarioRetiroParcial::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__SaldoDiarioRetiroParcial::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (soap_out_string(soap, "SaldoPesos", -1, &(a->ns2__SaldoDiarioRetiroParcial::SaldoPesos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SaldoDiarioRetiroParcial::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SaldoDiarioRetiroParcial(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SaldoDiarioRetiroParcial * SOAP_FMAC4 soap_in_ns2__SaldoDiarioRetiroParcial(struct soap *soap, const char *tag, ns2__SaldoDiarioRetiroParcial *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SaldoDiarioRetiroParcial *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SaldoDiarioRetiroParcial, sizeof(ns2__SaldoDiarioRetiroParcial), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SaldoDiarioRetiroParcial)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SaldoDiarioRetiroParcial *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_SaldoPesos1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__SaldoDiarioRetiroParcial::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_SaldoPesos1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SaldoPesos", &(a->ns2__SaldoDiarioRetiroParcial::SaldoPesos), "xsd:string"))
				{	soap_flag_SaldoPesos1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SaldoDiarioRetiroParcial *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SaldoDiarioRetiroParcial, 0, sizeof(ns2__SaldoDiarioRetiroParcial), 0, soap_copy_ns2__SaldoDiarioRetiroParcial);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SaldoDiarioRetiroParcial::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SaldoDiarioRetiroParcial);
	if (this->soap_out(soap, tag?tag:"ns2:SaldoDiarioRetiroParcial", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SaldoDiarioRetiroParcial::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SaldoDiarioRetiroParcial(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SaldoDiarioRetiroParcial * SOAP_FMAC4 soap_get_ns2__SaldoDiarioRetiroParcial(struct soap *soap, ns2__SaldoDiarioRetiroParcial *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SaldoDiarioRetiroParcial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SaldoDiarioRetiroParcial * SOAP_FMAC2 soap_instantiate_ns2__SaldoDiarioRetiroParcial(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SaldoDiarioRetiroParcial(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SaldoDiarioRetiroParcial, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SaldoDiarioRetiroParcial);
		if (size)
			*size = sizeof(ns2__SaldoDiarioRetiroParcial);
		((ns2__SaldoDiarioRetiroParcial*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__SaldoDiarioRetiroParcial, n);
		if (size)
			*size = n * sizeof(ns2__SaldoDiarioRetiroParcial);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__SaldoDiarioRetiroParcial*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__SaldoDiarioRetiroParcial*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SaldoDiarioRetiroParcial(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SaldoDiarioRetiroParcial %p -> %p\n", q, p));
	*(ns2__SaldoDiarioRetiroParcial*)p = *(ns2__SaldoDiarioRetiroParcial*)q;
}

void ns2__ConsultaSaldoDiarioRetiroParcial::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ConsultaSaldoDiarioRetiroParcial::Nss);
	soap_default_ns2__TipoRetiroParcial(soap, &this->ns2__ConsultaSaldoDiarioRetiroParcial::TipoRetiro);
	/* transient soap skipped */
}

void ns2__ConsultaSaldoDiarioRetiroParcial::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ConsultaSaldoDiarioRetiroParcial::Nss);
	/* transient soap skipped */
#endif
}

int ns2__ConsultaSaldoDiarioRetiroParcial::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ConsultaSaldoDiarioRetiroParcial(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultaSaldoDiarioRetiroParcial(struct soap *soap, const char *tag, int id, const ns2__ConsultaSaldoDiarioRetiroParcial *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ConsultaSaldoDiarioRetiroParcial::Nss), ""))
		return soap->error;
	if (soap_out_ns2__TipoRetiroParcial(soap, "TipoRetiro", -1, &(a->ns2__ConsultaSaldoDiarioRetiroParcial::TipoRetiro), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ConsultaSaldoDiarioRetiroParcial::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ConsultaSaldoDiarioRetiroParcial(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ConsultaSaldoDiarioRetiroParcial * SOAP_FMAC4 soap_in_ns2__ConsultaSaldoDiarioRetiroParcial(struct soap *soap, const char *tag, ns2__ConsultaSaldoDiarioRetiroParcial *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ConsultaSaldoDiarioRetiroParcial *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial, sizeof(ns2__ConsultaSaldoDiarioRetiroParcial), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ConsultaSaldoDiarioRetiroParcial *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_TipoRetiro1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ConsultaSaldoDiarioRetiroParcial::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_TipoRetiro1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__TipoRetiroParcial(soap, "TipoRetiro", &(a->ns2__ConsultaSaldoDiarioRetiroParcial::TipoRetiro), "ns2:TipoRetiroParcial"))
				{	soap_flag_TipoRetiro1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ConsultaSaldoDiarioRetiroParcial *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial, 0, sizeof(ns2__ConsultaSaldoDiarioRetiroParcial), 0, soap_copy_ns2__ConsultaSaldoDiarioRetiroParcial);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TipoRetiro1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ConsultaSaldoDiarioRetiroParcial::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial);
	if (this->soap_out(soap, tag?tag:"ns2:ConsultaSaldoDiarioRetiroParcial", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ConsultaSaldoDiarioRetiroParcial::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ConsultaSaldoDiarioRetiroParcial(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ConsultaSaldoDiarioRetiroParcial * SOAP_FMAC4 soap_get_ns2__ConsultaSaldoDiarioRetiroParcial(struct soap *soap, ns2__ConsultaSaldoDiarioRetiroParcial *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultaSaldoDiarioRetiroParcial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ConsultaSaldoDiarioRetiroParcial * SOAP_FMAC2 soap_instantiate_ns2__ConsultaSaldoDiarioRetiroParcial(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultaSaldoDiarioRetiroParcial(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ConsultaSaldoDiarioRetiroParcial);
		if (size)
			*size = sizeof(ns2__ConsultaSaldoDiarioRetiroParcial);
		((ns2__ConsultaSaldoDiarioRetiroParcial*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ConsultaSaldoDiarioRetiroParcial, n);
		if (size)
			*size = n * sizeof(ns2__ConsultaSaldoDiarioRetiroParcial);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ConsultaSaldoDiarioRetiroParcial*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ConsultaSaldoDiarioRetiroParcial*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultaSaldoDiarioRetiroParcial(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ConsultaSaldoDiarioRetiroParcial %p -> %p\n", q, p));
	*(ns2__ConsultaSaldoDiarioRetiroParcial*)p = *(ns2__ConsultaSaldoDiarioRetiroParcial*)q;
}

void ns2__RespuestaTipoSolicitante::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaTipoSolicitante::Solicitante = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaTipoSolicitante::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__TipoSolicitante(soap, &this->ns2__RespuestaTipoSolicitante::Solicitante);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaTipoSolicitante::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaTipoSolicitante(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaTipoSolicitante(struct soap *soap, const char *tag, int id, const ns2__RespuestaTipoSolicitante *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaTipoSolicitante), type))
		return soap->error;
	if (a->ns2__RespuestaTipoSolicitante::Solicitante)
	{	if (soap_out_PointerTons2__TipoSolicitante(soap, "Solicitante", -1, &a->ns2__RespuestaTipoSolicitante::Solicitante, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "Solicitante"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaTipoSolicitante::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaTipoSolicitante(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaTipoSolicitante * SOAP_FMAC4 soap_in_ns2__RespuestaTipoSolicitante(struct soap *soap, const char *tag, ns2__RespuestaTipoSolicitante *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaTipoSolicitante *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaTipoSolicitante, sizeof(ns2__RespuestaTipoSolicitante), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaTipoSolicitante)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaTipoSolicitante *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Solicitante1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Solicitante1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__TipoSolicitante(soap, "Solicitante", &(a->ns2__RespuestaTipoSolicitante::Solicitante), "ns2:TipoSolicitante"))
				{	soap_flag_Solicitante1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaTipoSolicitante *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaTipoSolicitante, 0, sizeof(ns2__RespuestaTipoSolicitante), 0, soap_copy_ns2__RespuestaTipoSolicitante);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Solicitante1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaTipoSolicitante::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaTipoSolicitante);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaTipoSolicitante", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaTipoSolicitante::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaTipoSolicitante(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaTipoSolicitante * SOAP_FMAC4 soap_get_ns2__RespuestaTipoSolicitante(struct soap *soap, ns2__RespuestaTipoSolicitante *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaTipoSolicitante(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaTipoSolicitante * SOAP_FMAC2 soap_instantiate_ns2__RespuestaTipoSolicitante(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaTipoSolicitante(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaTipoSolicitante, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaTipoSolicitante);
		if (size)
			*size = sizeof(ns2__RespuestaTipoSolicitante);
		((ns2__RespuestaTipoSolicitante*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaTipoSolicitante, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaTipoSolicitante);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaTipoSolicitante*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaTipoSolicitante*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaTipoSolicitante(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaTipoSolicitante %p -> %p\n", q, p));
	*(ns2__RespuestaTipoSolicitante*)p = *(ns2__RespuestaTipoSolicitante*)q;
}

void ns2__TipoSolicitante::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__TipoSolicitante::iTipoSolicitante);
	/* transient soap skipped */
}

void ns2__TipoSolicitante::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns2__TipoSolicitante::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__TipoSolicitante(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__TipoSolicitante(struct soap *soap, const char *tag, int id, const ns2__TipoSolicitante *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__TipoSolicitante), type))
		return soap->error;
	if (soap_out_int(soap, "iTipoSolicitante", -1, &(a->ns2__TipoSolicitante::iTipoSolicitante), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__TipoSolicitante::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__TipoSolicitante(soap, tag, this, type);
}

SOAP_FMAC3 ns2__TipoSolicitante * SOAP_FMAC4 soap_in_ns2__TipoSolicitante(struct soap *soap, const char *tag, ns2__TipoSolicitante *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__TipoSolicitante *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__TipoSolicitante, sizeof(ns2__TipoSolicitante), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__TipoSolicitante)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__TipoSolicitante *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_iTipoSolicitante1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_iTipoSolicitante1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iTipoSolicitante", &(a->ns2__TipoSolicitante::iTipoSolicitante), "xsd:int"))
				{	soap_flag_iTipoSolicitante1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__TipoSolicitante *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__TipoSolicitante, 0, sizeof(ns2__TipoSolicitante), 0, soap_copy_ns2__TipoSolicitante);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_iTipoSolicitante1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__TipoSolicitante::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__TipoSolicitante);
	if (this->soap_out(soap, tag?tag:"ns2:TipoSolicitante", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__TipoSolicitante::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__TipoSolicitante(soap, this, tag, type);
}

SOAP_FMAC3 ns2__TipoSolicitante * SOAP_FMAC4 soap_get_ns2__TipoSolicitante(struct soap *soap, ns2__TipoSolicitante *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__TipoSolicitante(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__TipoSolicitante * SOAP_FMAC2 soap_instantiate_ns2__TipoSolicitante(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__TipoSolicitante(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__TipoSolicitante, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__TipoSolicitante);
		if (size)
			*size = sizeof(ns2__TipoSolicitante);
		((ns2__TipoSolicitante*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__TipoSolicitante, n);
		if (size)
			*size = n * sizeof(ns2__TipoSolicitante);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__TipoSolicitante*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__TipoSolicitante*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__TipoSolicitante(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__TipoSolicitante %p -> %p\n", q, p));
	*(ns2__TipoSolicitante*)p = *(ns2__TipoSolicitante*)q;
}

void ns2__RespuestaConvivenciaMarca::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespuestaConvivenciaMarca::EstadoProc = NULL;
	this->ns2__RespuestaConvivenciaMarca::ConvivenciaMarca = NULL;
	/* transient soap skipped */
}

void ns2__RespuestaConvivenciaMarca::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespuestaConvivenciaMarca::EstadoProc);
	soap_serialize_PointerTons2__ValidaConvivenciaMarcas(soap, &this->ns2__RespuestaConvivenciaMarca::ConvivenciaMarca);
	/* transient soap skipped */
#endif
}

int ns2__RespuestaConvivenciaMarca::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespuestaConvivenciaMarca(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespuestaConvivenciaMarca(struct soap *soap, const char *tag, int id, const ns2__RespuestaConvivenciaMarca *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespuestaConvivenciaMarca), type))
		return soap->error;
	if (a->ns2__RespuestaConvivenciaMarca::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespuestaConvivenciaMarca::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__RespuestaConvivenciaMarca::ConvivenciaMarca)
	{	if (soap_out_PointerTons2__ValidaConvivenciaMarcas(soap, "ConvivenciaMarca", -1, &a->ns2__RespuestaConvivenciaMarca::ConvivenciaMarca, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ConvivenciaMarca"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespuestaConvivenciaMarca::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespuestaConvivenciaMarca(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespuestaConvivenciaMarca * SOAP_FMAC4 soap_in_ns2__RespuestaConvivenciaMarca(struct soap *soap, const char *tag, ns2__RespuestaConvivenciaMarca *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespuestaConvivenciaMarca *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespuestaConvivenciaMarca, sizeof(ns2__RespuestaConvivenciaMarca), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespuestaConvivenciaMarca)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespuestaConvivenciaMarca *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_ConvivenciaMarca1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespuestaConvivenciaMarca::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_ConvivenciaMarca1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ValidaConvivenciaMarcas(soap, "ConvivenciaMarca", &(a->ns2__RespuestaConvivenciaMarca::ConvivenciaMarca), "ns2:ValidaConvivenciaMarcas"))
				{	soap_flag_ConvivenciaMarca1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespuestaConvivenciaMarca *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespuestaConvivenciaMarca, 0, sizeof(ns2__RespuestaConvivenciaMarca), 0, soap_copy_ns2__RespuestaConvivenciaMarca);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_ConvivenciaMarca1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespuestaConvivenciaMarca::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespuestaConvivenciaMarca);
	if (this->soap_out(soap, tag?tag:"ns2:RespuestaConvivenciaMarca", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespuestaConvivenciaMarca::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespuestaConvivenciaMarca(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespuestaConvivenciaMarca * SOAP_FMAC4 soap_get_ns2__RespuestaConvivenciaMarca(struct soap *soap, ns2__RespuestaConvivenciaMarca *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespuestaConvivenciaMarca(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespuestaConvivenciaMarca * SOAP_FMAC2 soap_instantiate_ns2__RespuestaConvivenciaMarca(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespuestaConvivenciaMarca(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespuestaConvivenciaMarca, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespuestaConvivenciaMarca);
		if (size)
			*size = sizeof(ns2__RespuestaConvivenciaMarca);
		((ns2__RespuestaConvivenciaMarca*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespuestaConvivenciaMarca, n);
		if (size)
			*size = n * sizeof(ns2__RespuestaConvivenciaMarca);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespuestaConvivenciaMarca*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespuestaConvivenciaMarca*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespuestaConvivenciaMarca(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespuestaConvivenciaMarca %p -> %p\n", q, p));
	*(ns2__RespuestaConvivenciaMarca*)p = *(ns2__RespuestaConvivenciaMarca*)q;
}

void ns2__ValidaConvivenciaMarcas::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__ValidaConvivenciaMarcas::Codigo);
	soap_default_string(soap, &this->ns2__ValidaConvivenciaMarcas::Descripcion);
	soap_default_int(soap, &this->ns2__ValidaConvivenciaMarcas::TieneMarca);
	/* transient soap skipped */
}

void ns2__ValidaConvivenciaMarcas::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ValidaConvivenciaMarcas::Descripcion);
	/* transient soap skipped */
#endif
}

int ns2__ValidaConvivenciaMarcas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ValidaConvivenciaMarcas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValidaConvivenciaMarcas(struct soap *soap, const char *tag, int id, const ns2__ValidaConvivenciaMarcas *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValidaConvivenciaMarcas), type))
		return soap->error;
	if (soap_out_int(soap, "Codigo", -1, &(a->ns2__ValidaConvivenciaMarcas::Codigo), ""))
		return soap->error;
	if (soap_out_string(soap, "Descripcion", -1, &(a->ns2__ValidaConvivenciaMarcas::Descripcion), ""))
		return soap->error;
	if (soap_out_int(soap, "TieneMarca", -1, &(a->ns2__ValidaConvivenciaMarcas::TieneMarca), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ValidaConvivenciaMarcas::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ValidaConvivenciaMarcas(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ValidaConvivenciaMarcas * SOAP_FMAC4 soap_in_ns2__ValidaConvivenciaMarcas(struct soap *soap, const char *tag, ns2__ValidaConvivenciaMarcas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ValidaConvivenciaMarcas *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValidaConvivenciaMarcas, sizeof(ns2__ValidaConvivenciaMarcas), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ValidaConvivenciaMarcas)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ValidaConvivenciaMarcas *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Codigo1 = 1;
	size_t soap_flag_Descripcion1 = 1;
	size_t soap_flag_TieneMarca1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Codigo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Codigo", &(a->ns2__ValidaConvivenciaMarcas::Codigo), "xsd:int"))
				{	soap_flag_Codigo1--;
					continue;
				}
			if (soap_flag_Descripcion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Descripcion", &(a->ns2__ValidaConvivenciaMarcas::Descripcion), "xsd:string"))
				{	soap_flag_Descripcion1--;
					continue;
				}
			if (soap_flag_TieneMarca1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "TieneMarca", &(a->ns2__ValidaConvivenciaMarcas::TieneMarca), "xsd:int"))
				{	soap_flag_TieneMarca1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ValidaConvivenciaMarcas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValidaConvivenciaMarcas, 0, sizeof(ns2__ValidaConvivenciaMarcas), 0, soap_copy_ns2__ValidaConvivenciaMarcas);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Codigo1 > 0 || soap_flag_TieneMarca1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ValidaConvivenciaMarcas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ValidaConvivenciaMarcas);
	if (this->soap_out(soap, tag?tag:"ns2:ValidaConvivenciaMarcas", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ValidaConvivenciaMarcas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ValidaConvivenciaMarcas(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ValidaConvivenciaMarcas * SOAP_FMAC4 soap_get_ns2__ValidaConvivenciaMarcas(struct soap *soap, ns2__ValidaConvivenciaMarcas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValidaConvivenciaMarcas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ValidaConvivenciaMarcas * SOAP_FMAC2 soap_instantiate_ns2__ValidaConvivenciaMarcas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValidaConvivenciaMarcas(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValidaConvivenciaMarcas, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ValidaConvivenciaMarcas);
		if (size)
			*size = sizeof(ns2__ValidaConvivenciaMarcas);
		((ns2__ValidaConvivenciaMarcas*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ValidaConvivenciaMarcas, n);
		if (size)
			*size = n * sizeof(ns2__ValidaConvivenciaMarcas);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ValidaConvivenciaMarcas*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ValidaConvivenciaMarcas*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValidaConvivenciaMarcas(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ValidaConvivenciaMarcas %p -> %p\n", q, p));
	*(ns2__ValidaConvivenciaMarcas*)p = *(ns2__ValidaConvivenciaMarcas*)q;
}

void ns2__ConvivenciaMarcas::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__TipoTrabajador(soap, &this->ns2__ConvivenciaMarcas::TipoTrabajador);
	soap_default_int(soap, &this->ns2__ConvivenciaMarcas::Opcion);
	soap_default_string(soap, &this->ns2__ConvivenciaMarcas::Nss);
	soap_default_string(soap, &this->ns2__ConvivenciaMarcas::TipoRetiro);
	/* transient soap skipped */
}

void ns2__ConvivenciaMarcas::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ConvivenciaMarcas::Nss);
	soap_serialize_string(soap, &this->ns2__ConvivenciaMarcas::TipoRetiro);
	/* transient soap skipped */
#endif
}

int ns2__ConvivenciaMarcas::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ConvivenciaMarcas(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConvivenciaMarcas(struct soap *soap, const char *tag, int id, const ns2__ConvivenciaMarcas *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConvivenciaMarcas), type))
		return soap->error;
	if (soap_out_ns2__TipoTrabajador(soap, "TipoTrabajador", -1, &(a->ns2__ConvivenciaMarcas::TipoTrabajador), ""))
		return soap->error;
	if (soap_out_int(soap, "Opcion", -1, &(a->ns2__ConvivenciaMarcas::Opcion), ""))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ConvivenciaMarcas::Nss), ""))
		return soap->error;
	if (soap_out_string(soap, "TipoRetiro", -1, &(a->ns2__ConvivenciaMarcas::TipoRetiro), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ConvivenciaMarcas::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ConvivenciaMarcas(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ConvivenciaMarcas * SOAP_FMAC4 soap_in_ns2__ConvivenciaMarcas(struct soap *soap, const char *tag, ns2__ConvivenciaMarcas *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ConvivenciaMarcas *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConvivenciaMarcas, sizeof(ns2__ConvivenciaMarcas), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ConvivenciaMarcas)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ConvivenciaMarcas *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TipoTrabajador1 = 1;
	size_t soap_flag_Opcion1 = 1;
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_TipoRetiro1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TipoTrabajador1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__TipoTrabajador(soap, "TipoTrabajador", &(a->ns2__ConvivenciaMarcas::TipoTrabajador), "ns2:TipoTrabajador"))
				{	soap_flag_TipoTrabajador1--;
					continue;
				}
			if (soap_flag_Opcion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Opcion", &(a->ns2__ConvivenciaMarcas::Opcion), "xsd:int"))
				{	soap_flag_Opcion1--;
					continue;
				}
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ConvivenciaMarcas::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_TipoRetiro1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "TipoRetiro", &(a->ns2__ConvivenciaMarcas::TipoRetiro), "xsd:string"))
				{	soap_flag_TipoRetiro1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ConvivenciaMarcas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConvivenciaMarcas, 0, sizeof(ns2__ConvivenciaMarcas), 0, soap_copy_ns2__ConvivenciaMarcas);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TipoTrabajador1 > 0 || soap_flag_Opcion1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ConvivenciaMarcas::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ConvivenciaMarcas);
	if (this->soap_out(soap, tag?tag:"ns2:ConvivenciaMarcas", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ConvivenciaMarcas::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ConvivenciaMarcas(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ConvivenciaMarcas * SOAP_FMAC4 soap_get_ns2__ConvivenciaMarcas(struct soap *soap, ns2__ConvivenciaMarcas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConvivenciaMarcas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ConvivenciaMarcas * SOAP_FMAC2 soap_instantiate_ns2__ConvivenciaMarcas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConvivenciaMarcas(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConvivenciaMarcas, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ConvivenciaMarcas);
		if (size)
			*size = sizeof(ns2__ConvivenciaMarcas);
		((ns2__ConvivenciaMarcas*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ConvivenciaMarcas, n);
		if (size)
			*size = n * sizeof(ns2__ConvivenciaMarcas);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ConvivenciaMarcas*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ConvivenciaMarcas*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConvivenciaMarcas(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ConvivenciaMarcas %p -> %p\n", q, p));
	*(ns2__ConvivenciaMarcas*)p = *(ns2__ConvivenciaMarcas*)q;
}

void ns2__FolioServicio::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__FolioServicio::EstadoProc = NULL;
	soap_default_int(soap, &this->ns2__FolioServicio::Folio);
	/* transient soap skipped */
}

void ns2__FolioServicio::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__FolioServicio::EstadoProc);
	/* transient soap skipped */
#endif
}

int ns2__FolioServicio::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FolioServicio(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FolioServicio(struct soap *soap, const char *tag, int id, const ns2__FolioServicio *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FolioServicio), type))
		return soap->error;
	if (a->ns2__FolioServicio::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__FolioServicio::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (soap_out_int(soap, "Folio", -1, &(a->ns2__FolioServicio::Folio), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__FolioServicio::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FolioServicio(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FolioServicio * SOAP_FMAC4 soap_in_ns2__FolioServicio(struct soap *soap, const char *tag, ns2__FolioServicio *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FolioServicio *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FolioServicio, sizeof(ns2__FolioServicio), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FolioServicio)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FolioServicio *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_Folio1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__FolioServicio::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_Folio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Folio", &(a->ns2__FolioServicio::Folio), "xsd:int"))
				{	soap_flag_Folio1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FolioServicio *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FolioServicio, 0, sizeof(ns2__FolioServicio), 0, soap_copy_ns2__FolioServicio);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_Folio1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__FolioServicio::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FolioServicio);
	if (this->soap_out(soap, tag?tag:"ns2:FolioServicio", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FolioServicio::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FolioServicio(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FolioServicio * SOAP_FMAC4 soap_get_ns2__FolioServicio(struct soap *soap, ns2__FolioServicio *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FolioServicio(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FolioServicio * SOAP_FMAC2 soap_instantiate_ns2__FolioServicio(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FolioServicio(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FolioServicio, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FolioServicio);
		if (size)
			*size = sizeof(ns2__FolioServicio);
		((ns2__FolioServicio*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__FolioServicio, n);
		if (size)
			*size = n * sizeof(ns2__FolioServicio);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__FolioServicio*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__FolioServicio*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FolioServicio(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FolioServicio %p -> %p\n", q, p));
	*(ns2__FolioServicio*)p = *(ns2__FolioServicio*)q;
}

void ns2__FoliadorServicio::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns2__ClasificacionServicio(soap, &this->ns2__FoliadorServicio::TipoServicio);
	/* transient soap skipped */
}

void ns2__FoliadorServicio::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns2__FoliadorServicio::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__FoliadorServicio(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__FoliadorServicio(struct soap *soap, const char *tag, int id, const ns2__FoliadorServicio *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__FoliadorServicio), type))
		return soap->error;
	if (soap_out_ns2__ClasificacionServicio(soap, "TipoServicio", -1, &(a->ns2__FoliadorServicio::TipoServicio), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__FoliadorServicio::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__FoliadorServicio(soap, tag, this, type);
}

SOAP_FMAC3 ns2__FoliadorServicio * SOAP_FMAC4 soap_in_ns2__FoliadorServicio(struct soap *soap, const char *tag, ns2__FoliadorServicio *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__FoliadorServicio *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__FoliadorServicio, sizeof(ns2__FoliadorServicio), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__FoliadorServicio)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__FoliadorServicio *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_TipoServicio1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TipoServicio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__ClasificacionServicio(soap, "TipoServicio", &(a->ns2__FoliadorServicio::TipoServicio), "ns2:ClasificacionServicio"))
				{	soap_flag_TipoServicio1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__FoliadorServicio *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__FoliadorServicio, 0, sizeof(ns2__FoliadorServicio), 0, soap_copy_ns2__FoliadorServicio);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TipoServicio1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__FoliadorServicio::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__FoliadorServicio);
	if (this->soap_out(soap, tag?tag:"ns2:FoliadorServicio", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__FoliadorServicio::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__FoliadorServicio(soap, this, tag, type);
}

SOAP_FMAC3 ns2__FoliadorServicio * SOAP_FMAC4 soap_get_ns2__FoliadorServicio(struct soap *soap, ns2__FoliadorServicio *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__FoliadorServicio(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__FoliadorServicio * SOAP_FMAC2 soap_instantiate_ns2__FoliadorServicio(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__FoliadorServicio(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__FoliadorServicio, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__FoliadorServicio);
		if (size)
			*size = sizeof(ns2__FoliadorServicio);
		((ns2__FoliadorServicio*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__FoliadorServicio, n);
		if (size)
			*size = n * sizeof(ns2__FoliadorServicio);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__FoliadorServicio*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__FoliadorServicio*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__FoliadorServicio(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__FoliadorServicio %p -> %p\n", q, p));
	*(ns2__FoliadorServicio*)p = *(ns2__FoliadorServicio*)q;
}

void ns2__SaldoPorSubcuentaPmg::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__SaldoPorSubcuentaPmg::EstadoProc = NULL;
	this->ns2__SaldoPorSubcuentaPmg::SaldosPmg = NULL;
	/* transient soap skipped */
}

void ns2__SaldoPorSubcuentaPmg::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__SaldoPorSubcuentaPmg::EstadoProc);
	soap_serialize_PointerTons2__SaldosCuentasPmg(soap, &this->ns2__SaldoPorSubcuentaPmg::SaldosPmg);
	/* transient soap skipped */
#endif
}

int ns2__SaldoPorSubcuentaPmg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SaldoPorSubcuentaPmg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SaldoPorSubcuentaPmg(struct soap *soap, const char *tag, int id, const ns2__SaldoPorSubcuentaPmg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SaldoPorSubcuentaPmg), type))
		return soap->error;
	if (a->ns2__SaldoPorSubcuentaPmg::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__SaldoPorSubcuentaPmg::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (a->ns2__SaldoPorSubcuentaPmg::SaldosPmg)
	{	if (soap_out_PointerTons2__SaldosCuentasPmg(soap, "SaldosPmg", -1, &a->ns2__SaldoPorSubcuentaPmg::SaldosPmg, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "SaldosPmg"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SaldoPorSubcuentaPmg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SaldoPorSubcuentaPmg(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SaldoPorSubcuentaPmg * SOAP_FMAC4 soap_in_ns2__SaldoPorSubcuentaPmg(struct soap *soap, const char *tag, ns2__SaldoPorSubcuentaPmg *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SaldoPorSubcuentaPmg *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SaldoPorSubcuentaPmg, sizeof(ns2__SaldoPorSubcuentaPmg), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SaldoPorSubcuentaPmg)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SaldoPorSubcuentaPmg *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_SaldosPmg1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__SaldoPorSubcuentaPmg::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_SaldosPmg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SaldosCuentasPmg(soap, "SaldosPmg", &(a->ns2__SaldoPorSubcuentaPmg::SaldosPmg), "ns2:SaldosCuentasPmg"))
				{	soap_flag_SaldosPmg1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SaldoPorSubcuentaPmg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SaldoPorSubcuentaPmg, 0, sizeof(ns2__SaldoPorSubcuentaPmg), 0, soap_copy_ns2__SaldoPorSubcuentaPmg);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0 || soap_flag_SaldosPmg1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SaldoPorSubcuentaPmg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SaldoPorSubcuentaPmg);
	if (this->soap_out(soap, tag?tag:"ns2:SaldoPorSubcuentaPmg", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SaldoPorSubcuentaPmg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SaldoPorSubcuentaPmg(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SaldoPorSubcuentaPmg * SOAP_FMAC4 soap_get_ns2__SaldoPorSubcuentaPmg(struct soap *soap, ns2__SaldoPorSubcuentaPmg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SaldoPorSubcuentaPmg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SaldoPorSubcuentaPmg * SOAP_FMAC2 soap_instantiate_ns2__SaldoPorSubcuentaPmg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SaldoPorSubcuentaPmg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SaldoPorSubcuentaPmg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SaldoPorSubcuentaPmg);
		if (size)
			*size = sizeof(ns2__SaldoPorSubcuentaPmg);
		((ns2__SaldoPorSubcuentaPmg*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__SaldoPorSubcuentaPmg, n);
		if (size)
			*size = n * sizeof(ns2__SaldoPorSubcuentaPmg);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__SaldoPorSubcuentaPmg*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__SaldoPorSubcuentaPmg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SaldoPorSubcuentaPmg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SaldoPorSubcuentaPmg %p -> %p\n", q, p));
	*(ns2__SaldoPorSubcuentaPmg*)p = *(ns2__SaldoPorSubcuentaPmg*)q;
}

void ns2__SaldosCuentasPmg::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->ns2__SaldosCuentasPmg::Retroactivo);
	soap_default_double(soap, &this->ns2__SaldosCuentasPmg::Devengado);
	soap_default_double(soap, &this->ns2__SaldosCuentasPmg::SaldoDia);
	soap_default_int(soap, &this->ns2__SaldosCuentasPmg::Suficiencia);
	soap_default_int(soap, &this->ns2__SaldosCuentasPmg::Registros);
	/* transient soap skipped */
}

void ns2__SaldosCuentasPmg::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns2__SaldosCuentasPmg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SaldosCuentasPmg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SaldosCuentasPmg(struct soap *soap, const char *tag, int id, const ns2__SaldosCuentasPmg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SaldosCuentasPmg), type))
		return soap->error;
	if (soap_out_double(soap, "Retroactivo", -1, &(a->ns2__SaldosCuentasPmg::Retroactivo), ""))
		return soap->error;
	if (soap_out_double(soap, "Devengado", -1, &(a->ns2__SaldosCuentasPmg::Devengado), ""))
		return soap->error;
	if (soap_out_double(soap, "SaldoDia", -1, &(a->ns2__SaldosCuentasPmg::SaldoDia), ""))
		return soap->error;
	if (soap_out_int(soap, "Suficiencia", -1, &(a->ns2__SaldosCuentasPmg::Suficiencia), ""))
		return soap->error;
	if (soap_out_int(soap, "Registros", -1, &(a->ns2__SaldosCuentasPmg::Registros), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SaldosCuentasPmg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SaldosCuentasPmg(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SaldosCuentasPmg * SOAP_FMAC4 soap_in_ns2__SaldosCuentasPmg(struct soap *soap, const char *tag, ns2__SaldosCuentasPmg *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SaldosCuentasPmg *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SaldosCuentasPmg, sizeof(ns2__SaldosCuentasPmg), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SaldosCuentasPmg)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SaldosCuentasPmg *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Retroactivo1 = 1;
	size_t soap_flag_Devengado1 = 1;
	size_t soap_flag_SaldoDia1 = 1;
	size_t soap_flag_Suficiencia1 = 1;
	size_t soap_flag_Registros1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Retroactivo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Retroactivo", &(a->ns2__SaldosCuentasPmg::Retroactivo), "xsd:double"))
				{	soap_flag_Retroactivo1--;
					continue;
				}
			if (soap_flag_Devengado1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "Devengado", &(a->ns2__SaldosCuentasPmg::Devengado), "xsd:double"))
				{	soap_flag_Devengado1--;
					continue;
				}
			if (soap_flag_SaldoDia1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "SaldoDia", &(a->ns2__SaldosCuentasPmg::SaldoDia), "xsd:double"))
				{	soap_flag_SaldoDia1--;
					continue;
				}
			if (soap_flag_Suficiencia1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Suficiencia", &(a->ns2__SaldosCuentasPmg::Suficiencia), "xsd:int"))
				{	soap_flag_Suficiencia1--;
					continue;
				}
			if (soap_flag_Registros1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Registros", &(a->ns2__SaldosCuentasPmg::Registros), "xsd:int"))
				{	soap_flag_Registros1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SaldosCuentasPmg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SaldosCuentasPmg, 0, sizeof(ns2__SaldosCuentasPmg), 0, soap_copy_ns2__SaldosCuentasPmg);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Retroactivo1 > 0 || soap_flag_Devengado1 > 0 || soap_flag_SaldoDia1 > 0 || soap_flag_Suficiencia1 > 0 || soap_flag_Registros1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SaldosCuentasPmg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SaldosCuentasPmg);
	if (this->soap_out(soap, tag?tag:"ns2:SaldosCuentasPmg", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SaldosCuentasPmg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SaldosCuentasPmg(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SaldosCuentasPmg * SOAP_FMAC4 soap_get_ns2__SaldosCuentasPmg(struct soap *soap, ns2__SaldosCuentasPmg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SaldosCuentasPmg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SaldosCuentasPmg * SOAP_FMAC2 soap_instantiate_ns2__SaldosCuentasPmg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SaldosCuentasPmg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SaldosCuentasPmg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SaldosCuentasPmg);
		if (size)
			*size = sizeof(ns2__SaldosCuentasPmg);
		((ns2__SaldosCuentasPmg*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__SaldosCuentasPmg, n);
		if (size)
			*size = n * sizeof(ns2__SaldosCuentasPmg);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__SaldosCuentasPmg*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__SaldosCuentasPmg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SaldosCuentasPmg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SaldosCuentasPmg %p -> %p\n", q, p));
	*(ns2__SaldosCuentasPmg*)p = *(ns2__SaldosCuentasPmg*)q;
}

void ns2__SaldoPorSubcuenta::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__SaldoPorSubcuenta::EstadoProc = NULL;
	soap_default_string(soap, &this->ns2__SaldoPorSubcuenta::Nss);
	this->ns2__SaldoPorSubcuenta::ListaSaldos = NULL;
	/* transient soap skipped */
}

void ns2__SaldoPorSubcuenta::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__SaldoPorSubcuenta::EstadoProc);
	soap_serialize_string(soap, &this->ns2__SaldoPorSubcuenta::Nss);
	soap_serialize_PointerToArrayOfSaldoSubCuenta(soap, &this->ns2__SaldoPorSubcuenta::ListaSaldos);
	/* transient soap skipped */
#endif
}

int ns2__SaldoPorSubcuenta::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SaldoPorSubcuenta(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SaldoPorSubcuenta(struct soap *soap, const char *tag, int id, const ns2__SaldoPorSubcuenta *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SaldoPorSubcuenta), type))
		return soap->error;
	if (a->ns2__SaldoPorSubcuenta::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__SaldoPorSubcuenta::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__SaldoPorSubcuenta::Nss), ""))
		return soap->error;
	if (soap_out_PointerToArrayOfSaldoSubCuenta(soap, "ListaSaldos", -1, &(a->ns2__SaldoPorSubcuenta::ListaSaldos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SaldoPorSubcuenta::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SaldoPorSubcuenta(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SaldoPorSubcuenta * SOAP_FMAC4 soap_in_ns2__SaldoPorSubcuenta(struct soap *soap, const char *tag, ns2__SaldoPorSubcuenta *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SaldoPorSubcuenta *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SaldoPorSubcuenta, sizeof(ns2__SaldoPorSubcuenta), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SaldoPorSubcuenta)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SaldoPorSubcuenta *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_EstadoProc1 = 1;
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_ListaSaldos1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__SaldoPorSubcuenta::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__SaldoPorSubcuenta::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_ListaSaldos1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfSaldoSubCuenta(soap, "ListaSaldos", &(a->ns2__SaldoPorSubcuenta::ListaSaldos), "ns2:SaldoSubCuenta"))
				{	soap_flag_ListaSaldos1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SaldoPorSubcuenta *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SaldoPorSubcuenta, 0, sizeof(ns2__SaldoPorSubcuenta), 0, soap_copy_ns2__SaldoPorSubcuenta);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoProc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SaldoPorSubcuenta::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SaldoPorSubcuenta);
	if (this->soap_out(soap, tag?tag:"ns2:SaldoPorSubcuenta", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SaldoPorSubcuenta::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SaldoPorSubcuenta(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SaldoPorSubcuenta * SOAP_FMAC4 soap_get_ns2__SaldoPorSubcuenta(struct soap *soap, ns2__SaldoPorSubcuenta *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SaldoPorSubcuenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SaldoPorSubcuenta * SOAP_FMAC2 soap_instantiate_ns2__SaldoPorSubcuenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SaldoPorSubcuenta(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SaldoPorSubcuenta, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SaldoPorSubcuenta);
		if (size)
			*size = sizeof(ns2__SaldoPorSubcuenta);
		((ns2__SaldoPorSubcuenta*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__SaldoPorSubcuenta, n);
		if (size)
			*size = n * sizeof(ns2__SaldoPorSubcuenta);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__SaldoPorSubcuenta*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__SaldoPorSubcuenta*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SaldoPorSubcuenta(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SaldoPorSubcuenta %p -> %p\n", q, p));
	*(ns2__SaldoPorSubcuenta*)p = *(ns2__SaldoPorSubcuenta*)q;
}

void ArrayOfSaldoSubCuenta::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptrSaldo = NULL;
}

void ArrayOfSaldoSubCuenta::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	if (this->__ptrSaldo && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptrSaldo, 1, SOAP_TYPE_ArrayOfSaldoSubCuenta))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons2__SaldoSubCuenta(soap, this->__ptrSaldo + i);
		}
#endif
}

int ArrayOfSaldoSubCuenta::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfSaldoSubCuenta(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfSaldoSubCuenta(struct soap *soap, const char *tag, int id, const ArrayOfSaldoSubCuenta *a, const char *type)
{
	int i, n = a->__size;
	char *t = a->__ptrSaldo ? soap_putsize(soap, "ns2:SaldoSubCuenta", a->__size) : NULL;
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptrSaldo, 1, type, SOAP_TYPE_ArrayOfSaldoSubCuenta);
	if (id < 0)
		return soap->error;
	if (soap_array_begin_out(soap, tag, id, t, NULL))
		return soap->error;
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons2__SaldoSubCuenta(soap, "Saldo", -1, &a->__ptrSaldo[i], "");
	}
	soap->position = 0;
	return soap_element_end_out(soap, tag);
}

void *ArrayOfSaldoSubCuenta::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfSaldoSubCuenta(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfSaldoSubCuenta * SOAP_FMAC4 soap_in_ArrayOfSaldoSubCuenta(struct soap *soap, const char *tag, ArrayOfSaldoSubCuenta *a, const char *type)
{	int i, j;
	ns2__SaldoSubCuenta **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfSaldoSubCuenta *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfSaldoSubCuenta, sizeof(ArrayOfSaldoSubCuenta), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptrSaldo = (ns2__SaldoSubCuenta **)soap_malloc(soap, sizeof(ns2__SaldoSubCuenta *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptrSaldo[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons2__SaldoSubCuenta(soap, NULL, a->__ptrSaldo + i, "ns2:SaldoSubCuenta"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	if (soap_new_block(soap) == NULL)
				return NULL;
			for (a->__size = 0; ; a->__size++)
			{	p = (ns2__SaldoSubCuenta **)soap_push_block(soap, NULL, sizeof(ns2__SaldoSubCuenta *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons2__SaldoSubCuenta(soap, NULL, p, "ns2:SaldoSubCuenta"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap, NULL);
			a->__ptrSaldo = (ns2__SaldoSubCuenta **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, NULL, (char*)a->__ptrSaldo, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfSaldoSubCuenta *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfSaldoSubCuenta, 0, sizeof(ArrayOfSaldoSubCuenta), 0, soap_copy_ArrayOfSaldoSubCuenta);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ArrayOfSaldoSubCuenta::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptrSaldo, 1, tag, SOAP_TYPE_ArrayOfSaldoSubCuenta);
	if (this->soap_out(soap, tag?tag:"SOAP-ENC:Array", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ArrayOfSaldoSubCuenta::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfSaldoSubCuenta(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfSaldoSubCuenta * SOAP_FMAC4 soap_get_ArrayOfSaldoSubCuenta(struct soap *soap, ArrayOfSaldoSubCuenta *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfSaldoSubCuenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ArrayOfSaldoSubCuenta * SOAP_FMAC2 soap_instantiate_ArrayOfSaldoSubCuenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfSaldoSubCuenta(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfSaldoSubCuenta, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ArrayOfSaldoSubCuenta);
		if (size)
			*size = sizeof(ArrayOfSaldoSubCuenta);
		((ArrayOfSaldoSubCuenta*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ArrayOfSaldoSubCuenta, n);
		if (size)
			*size = n * sizeof(ArrayOfSaldoSubCuenta);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ArrayOfSaldoSubCuenta*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ArrayOfSaldoSubCuenta*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfSaldoSubCuenta(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfSaldoSubCuenta %p -> %p\n", q, p));
	*(ArrayOfSaldoSubCuenta*)p = *(ArrayOfSaldoSubCuenta*)q;
}

void ns2__SaldoSubCuenta::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__SaldoSubCuenta::SubCuenta);
	soap_default_int(soap, &this->ns2__SaldoSubCuenta::Siefore);
	soap_default_string(soap, &this->ns2__SaldoSubCuenta::SaldoAccion);
	soap_default_string(soap, &this->ns2__SaldoSubCuenta::SaldoPesos);
	/* transient soap skipped */
}

void ns2__SaldoSubCuenta::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__SaldoSubCuenta::SaldoAccion);
	soap_serialize_string(soap, &this->ns2__SaldoSubCuenta::SaldoPesos);
	/* transient soap skipped */
#endif
}

int ns2__SaldoSubCuenta::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__SaldoSubCuenta(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__SaldoSubCuenta(struct soap *soap, const char *tag, int id, const ns2__SaldoSubCuenta *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__SaldoSubCuenta), type))
		return soap->error;
	if (soap_out_int(soap, "SubCuenta", -1, &(a->ns2__SaldoSubCuenta::SubCuenta), ""))
		return soap->error;
	if (soap_out_int(soap, "Siefore", -1, &(a->ns2__SaldoSubCuenta::Siefore), ""))
		return soap->error;
	if (soap_out_string(soap, "SaldoAccion", -1, &(a->ns2__SaldoSubCuenta::SaldoAccion), ""))
		return soap->error;
	if (soap_out_string(soap, "SaldoPesos", -1, &(a->ns2__SaldoSubCuenta::SaldoPesos), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__SaldoSubCuenta::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__SaldoSubCuenta(soap, tag, this, type);
}

SOAP_FMAC3 ns2__SaldoSubCuenta * SOAP_FMAC4 soap_in_ns2__SaldoSubCuenta(struct soap *soap, const char *tag, ns2__SaldoSubCuenta *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__SaldoSubCuenta *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__SaldoSubCuenta, sizeof(ns2__SaldoSubCuenta), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__SaldoSubCuenta)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__SaldoSubCuenta *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SubCuenta1 = 1;
	size_t soap_flag_Siefore1 = 1;
	size_t soap_flag_SaldoAccion1 = 1;
	size_t soap_flag_SaldoPesos1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubCuenta1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "SubCuenta", &(a->ns2__SaldoSubCuenta::SubCuenta), "xsd:int"))
				{	soap_flag_SubCuenta1--;
					continue;
				}
			if (soap_flag_Siefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "Siefore", &(a->ns2__SaldoSubCuenta::Siefore), "xsd:int"))
				{	soap_flag_Siefore1--;
					continue;
				}
			if (soap_flag_SaldoAccion1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SaldoAccion", &(a->ns2__SaldoSubCuenta::SaldoAccion), "xsd:string"))
				{	soap_flag_SaldoAccion1--;
					continue;
				}
			if (soap_flag_SaldoPesos1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SaldoPesos", &(a->ns2__SaldoSubCuenta::SaldoPesos), "xsd:string"))
				{	soap_flag_SaldoPesos1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__SaldoSubCuenta *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__SaldoSubCuenta, 0, sizeof(ns2__SaldoSubCuenta), 0, soap_copy_ns2__SaldoSubCuenta);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubCuenta1 > 0 || soap_flag_Siefore1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__SaldoSubCuenta::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__SaldoSubCuenta);
	if (this->soap_out(soap, tag?tag:"ns2:SaldoSubCuenta", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__SaldoSubCuenta::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__SaldoSubCuenta(soap, this, tag, type);
}

SOAP_FMAC3 ns2__SaldoSubCuenta * SOAP_FMAC4 soap_get_ns2__SaldoSubCuenta(struct soap *soap, ns2__SaldoSubCuenta *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__SaldoSubCuenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__SaldoSubCuenta * SOAP_FMAC2 soap_instantiate_ns2__SaldoSubCuenta(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__SaldoSubCuenta(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__SaldoSubCuenta, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__SaldoSubCuenta);
		if (size)
			*size = sizeof(ns2__SaldoSubCuenta);
		((ns2__SaldoSubCuenta*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__SaldoSubCuenta, n);
		if (size)
			*size = n * sizeof(ns2__SaldoSubCuenta);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__SaldoSubCuenta*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__SaldoSubCuenta*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__SaldoSubCuenta(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__SaldoSubCuenta %p -> %p\n", q, p));
	*(ns2__SaldoSubCuenta*)p = *(ns2__SaldoSubCuenta*)q;
}

void ns2__RespConsultarAfiliado::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns2__RespConsultarAfiliado::datosAfiliado = NULL;
	this->ns2__RespConsultarAfiliado::EstadoProc = NULL;
	/* transient soap skipped */
}

void ns2__RespConsultarAfiliado::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__Afiliado(soap, &this->ns2__RespConsultarAfiliado::datosAfiliado);
	soap_serialize_PointerTons2__EstadoProceso(soap, &this->ns2__RespConsultarAfiliado::EstadoProc);
	/* transient soap skipped */
#endif
}

int ns2__RespConsultarAfiliado::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__RespConsultarAfiliado(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__RespConsultarAfiliado(struct soap *soap, const char *tag, int id, const ns2__RespConsultarAfiliado *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__RespConsultarAfiliado), type))
		return soap->error;
	if (a->ns2__RespConsultarAfiliado::datosAfiliado)
	{	if (soap_out_PointerTons2__Afiliado(soap, "datosAfiliado", -1, &a->ns2__RespConsultarAfiliado::datosAfiliado, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "datosAfiliado"))
		return soap->error;
	if (a->ns2__RespConsultarAfiliado::EstadoProc)
	{	if (soap_out_PointerTons2__EstadoProceso(soap, "EstadoProc", -1, &a->ns2__RespConsultarAfiliado::EstadoProc, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "EstadoProc"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__RespConsultarAfiliado::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__RespConsultarAfiliado(soap, tag, this, type);
}

SOAP_FMAC3 ns2__RespConsultarAfiliado * SOAP_FMAC4 soap_in_ns2__RespConsultarAfiliado(struct soap *soap, const char *tag, ns2__RespConsultarAfiliado *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__RespConsultarAfiliado *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__RespConsultarAfiliado, sizeof(ns2__RespConsultarAfiliado), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__RespConsultarAfiliado)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__RespConsultarAfiliado *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_datosAfiliado1 = 1;
	size_t soap_flag_EstadoProc1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_datosAfiliado1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__Afiliado(soap, "datosAfiliado", &(a->ns2__RespConsultarAfiliado::datosAfiliado), "ns2:Afiliado"))
				{	soap_flag_datosAfiliado1--;
					continue;
				}
			if (soap_flag_EstadoProc1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__EstadoProceso(soap, "EstadoProc", &(a->ns2__RespConsultarAfiliado::EstadoProc), "ns2:EstadoProceso"))
				{	soap_flag_EstadoProc1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__RespConsultarAfiliado *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__RespConsultarAfiliado, 0, sizeof(ns2__RespConsultarAfiliado), 0, soap_copy_ns2__RespConsultarAfiliado);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_datosAfiliado1 > 0 || soap_flag_EstadoProc1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__RespConsultarAfiliado::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__RespConsultarAfiliado);
	if (this->soap_out(soap, tag?tag:"ns2:RespConsultarAfiliado", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__RespConsultarAfiliado::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__RespConsultarAfiliado(soap, this, tag, type);
}

SOAP_FMAC3 ns2__RespConsultarAfiliado * SOAP_FMAC4 soap_get_ns2__RespConsultarAfiliado(struct soap *soap, ns2__RespConsultarAfiliado *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__RespConsultarAfiliado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__RespConsultarAfiliado * SOAP_FMAC2 soap_instantiate_ns2__RespConsultarAfiliado(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__RespConsultarAfiliado(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__RespConsultarAfiliado, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__RespConsultarAfiliado);
		if (size)
			*size = sizeof(ns2__RespConsultarAfiliado);
		((ns2__RespConsultarAfiliado*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__RespConsultarAfiliado, n);
		if (size)
			*size = n * sizeof(ns2__RespConsultarAfiliado);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__RespConsultarAfiliado*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__RespConsultarAfiliado*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__RespConsultarAfiliado(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__RespConsultarAfiliado %p -> %p\n", q, p));
	*(ns2__RespConsultarAfiliado*)p = *(ns2__RespConsultarAfiliado*)q;
}

void ns2__Afiliado::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__Afiliado::cApellidoPaterno);
	soap_default_string(soap, &this->ns2__Afiliado::cApellidoMaterno);
	soap_default_string(soap, &this->ns2__Afiliado::cNombre);
	soap_default_string(soap, &this->ns2__Afiliado::cCurp);
	soap_default_string(soap, &this->ns2__Afiliado::cNss);
	soap_default_string(soap, &this->ns2__Afiliado::cFechaServicio);
	soap_default_string(soap, &this->ns2__Afiliado::cFechaNacimiento);
	soap_default_string(soap, &this->ns2__Afiliado::cEntidadNacimiento);
	soap_default_int(soap, &this->ns2__Afiliado::iSexo);
	/* transient soap skipped */
}

void ns2__Afiliado::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__Afiliado::cApellidoPaterno);
	soap_serialize_string(soap, &this->ns2__Afiliado::cApellidoMaterno);
	soap_serialize_string(soap, &this->ns2__Afiliado::cNombre);
	soap_serialize_string(soap, &this->ns2__Afiliado::cCurp);
	soap_serialize_string(soap, &this->ns2__Afiliado::cNss);
	soap_serialize_string(soap, &this->ns2__Afiliado::cFechaServicio);
	soap_serialize_string(soap, &this->ns2__Afiliado::cFechaNacimiento);
	soap_serialize_string(soap, &this->ns2__Afiliado::cEntidadNacimiento);
	/* transient soap skipped */
#endif
}

int ns2__Afiliado::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__Afiliado(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__Afiliado(struct soap *soap, const char *tag, int id, const ns2__Afiliado *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__Afiliado), type))
		return soap->error;
	if (soap_out_string(soap, "cApellidoPaterno", -1, &(a->ns2__Afiliado::cApellidoPaterno), ""))
		return soap->error;
	if (soap_out_string(soap, "cApellidoMaterno", -1, &(a->ns2__Afiliado::cApellidoMaterno), ""))
		return soap->error;
	if (soap_out_string(soap, "cNombre", -1, &(a->ns2__Afiliado::cNombre), ""))
		return soap->error;
	if (soap_out_string(soap, "cCurp", -1, &(a->ns2__Afiliado::cCurp), ""))
		return soap->error;
	if (soap_out_string(soap, "cNss", -1, &(a->ns2__Afiliado::cNss), ""))
		return soap->error;
	if (soap_out_string(soap, "cFechaServicio", -1, &(a->ns2__Afiliado::cFechaServicio), ""))
		return soap->error;
	if (soap_out_string(soap, "cFechaNacimiento", -1, &(a->ns2__Afiliado::cFechaNacimiento), ""))
		return soap->error;
	if (soap_out_string(soap, "cEntidadNacimiento", -1, &(a->ns2__Afiliado::cEntidadNacimiento), ""))
		return soap->error;
	if (soap_out_int(soap, "iSexo", -1, &(a->ns2__Afiliado::iSexo), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__Afiliado::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__Afiliado(soap, tag, this, type);
}

SOAP_FMAC3 ns2__Afiliado * SOAP_FMAC4 soap_in_ns2__Afiliado(struct soap *soap, const char *tag, ns2__Afiliado *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__Afiliado *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__Afiliado, sizeof(ns2__Afiliado), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__Afiliado)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__Afiliado *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cApellidoPaterno1 = 1;
	size_t soap_flag_cApellidoMaterno1 = 1;
	size_t soap_flag_cNombre1 = 1;
	size_t soap_flag_cCurp1 = 1;
	size_t soap_flag_cNss1 = 1;
	size_t soap_flag_cFechaServicio1 = 1;
	size_t soap_flag_cFechaNacimiento1 = 1;
	size_t soap_flag_cEntidadNacimiento1 = 1;
	size_t soap_flag_iSexo1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cApellidoPaterno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cApellidoPaterno", &(a->ns2__Afiliado::cApellidoPaterno), "xsd:string"))
				{	soap_flag_cApellidoPaterno1--;
					continue;
				}
			if (soap_flag_cApellidoMaterno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cApellidoMaterno", &(a->ns2__Afiliado::cApellidoMaterno), "xsd:string"))
				{	soap_flag_cApellidoMaterno1--;
					continue;
				}
			if (soap_flag_cNombre1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cNombre", &(a->ns2__Afiliado::cNombre), "xsd:string"))
				{	soap_flag_cNombre1--;
					continue;
				}
			if (soap_flag_cCurp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cCurp", &(a->ns2__Afiliado::cCurp), "xsd:string"))
				{	soap_flag_cCurp1--;
					continue;
				}
			if (soap_flag_cNss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cNss", &(a->ns2__Afiliado::cNss), "xsd:string"))
				{	soap_flag_cNss1--;
					continue;
				}
			if (soap_flag_cFechaServicio1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cFechaServicio", &(a->ns2__Afiliado::cFechaServicio), "xsd:string"))
				{	soap_flag_cFechaServicio1--;
					continue;
				}
			if (soap_flag_cFechaNacimiento1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cFechaNacimiento", &(a->ns2__Afiliado::cFechaNacimiento), "xsd:string"))
				{	soap_flag_cFechaNacimiento1--;
					continue;
				}
			if (soap_flag_cEntidadNacimiento1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "cEntidadNacimiento", &(a->ns2__Afiliado::cEntidadNacimiento), "xsd:string"))
				{	soap_flag_cEntidadNacimiento1--;
					continue;
				}
			if (soap_flag_iSexo1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iSexo", &(a->ns2__Afiliado::iSexo), "xsd:int"))
				{	soap_flag_iSexo1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__Afiliado *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__Afiliado, 0, sizeof(ns2__Afiliado), 0, soap_copy_ns2__Afiliado);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_iSexo1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__Afiliado::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__Afiliado);
	if (this->soap_out(soap, tag?tag:"ns2:Afiliado", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__Afiliado::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__Afiliado(soap, this, tag, type);
}

SOAP_FMAC3 ns2__Afiliado * SOAP_FMAC4 soap_get_ns2__Afiliado(struct soap *soap, ns2__Afiliado *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__Afiliado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__Afiliado * SOAP_FMAC2 soap_instantiate_ns2__Afiliado(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__Afiliado(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__Afiliado, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__Afiliado);
		if (size)
			*size = sizeof(ns2__Afiliado);
		((ns2__Afiliado*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__Afiliado, n);
		if (size)
			*size = n * sizeof(ns2__Afiliado);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__Afiliado*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__Afiliado*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__Afiliado(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__Afiliado %p -> %p\n", q, p));
	*(ns2__Afiliado*)p = *(ns2__Afiliado*)q;
}

void ns2__ParametroNssTipoRetiro::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ParametroNssTipoRetiro::Nss);
	soap_default_ns2__TipoRetiroParcial(soap, &this->ns2__ParametroNssTipoRetiro::TipoRetiro);
	/* transient soap skipped */
}

void ns2__ParametroNssTipoRetiro::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParametroNssTipoRetiro::Nss);
	/* transient soap skipped */
#endif
}

int ns2__ParametroNssTipoRetiro::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParametroNssTipoRetiro(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParametroNssTipoRetiro(struct soap *soap, const char *tag, int id, const ns2__ParametroNssTipoRetiro *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParametroNssTipoRetiro), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ParametroNssTipoRetiro::Nss), ""))
		return soap->error;
	if (soap_out_ns2__TipoRetiroParcial(soap, "TipoRetiro", -1, &(a->ns2__ParametroNssTipoRetiro::TipoRetiro), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParametroNssTipoRetiro::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParametroNssTipoRetiro(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParametroNssTipoRetiro * SOAP_FMAC4 soap_in_ns2__ParametroNssTipoRetiro(struct soap *soap, const char *tag, ns2__ParametroNssTipoRetiro *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParametroNssTipoRetiro *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParametroNssTipoRetiro, sizeof(ns2__ParametroNssTipoRetiro), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParametroNssTipoRetiro)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParametroNssTipoRetiro *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_TipoRetiro1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ParametroNssTipoRetiro::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_TipoRetiro1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns2__TipoRetiroParcial(soap, "TipoRetiro", &(a->ns2__ParametroNssTipoRetiro::TipoRetiro), "ns2:TipoRetiroParcial"))
				{	soap_flag_TipoRetiro1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParametroNssTipoRetiro *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParametroNssTipoRetiro, 0, sizeof(ns2__ParametroNssTipoRetiro), 0, soap_copy_ns2__ParametroNssTipoRetiro);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TipoRetiro1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ParametroNssTipoRetiro::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParametroNssTipoRetiro);
	if (this->soap_out(soap, tag?tag:"ns2:ParametroNssTipoRetiro", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParametroNssTipoRetiro::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParametroNssTipoRetiro(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParametroNssTipoRetiro * SOAP_FMAC4 soap_get_ns2__ParametroNssTipoRetiro(struct soap *soap, ns2__ParametroNssTipoRetiro *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParametroNssTipoRetiro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParametroNssTipoRetiro * SOAP_FMAC2 soap_instantiate_ns2__ParametroNssTipoRetiro(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParametroNssTipoRetiro(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParametroNssTipoRetiro, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParametroNssTipoRetiro);
		if (size)
			*size = sizeof(ns2__ParametroNssTipoRetiro);
		((ns2__ParametroNssTipoRetiro*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParametroNssTipoRetiro, n);
		if (size)
			*size = n * sizeof(ns2__ParametroNssTipoRetiro);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParametroNssTipoRetiro*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParametroNssTipoRetiro*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParametroNssTipoRetiro(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParametroNssTipoRetiro %p -> %p\n", q, p));
	*(ns2__ParametroNssTipoRetiro*)p = *(ns2__ParametroNssTipoRetiro*)q;
}

void ns2__ParametroSaldoPmg::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ParametroSaldoPmg::Nss);
	soap_default_string(soap, &this->ns2__ParametroSaldoPmg::Secuencia);
	soap_default_int(soap, &this->ns2__ParametroSaldoPmg::EstadoViv);
	/* transient soap skipped */
}

void ns2__ParametroSaldoPmg::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParametroSaldoPmg::Nss);
	soap_serialize_string(soap, &this->ns2__ParametroSaldoPmg::Secuencia);
	/* transient soap skipped */
#endif
}

int ns2__ParametroSaldoPmg::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParametroSaldoPmg(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParametroSaldoPmg(struct soap *soap, const char *tag, int id, const ns2__ParametroSaldoPmg *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParametroSaldoPmg), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ParametroSaldoPmg::Nss), ""))
		return soap->error;
	if (soap_out_string(soap, "Secuencia", -1, &(a->ns2__ParametroSaldoPmg::Secuencia), ""))
		return soap->error;
	if (soap_out_int(soap, "EstadoViv", -1, &(a->ns2__ParametroSaldoPmg::EstadoViv), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParametroSaldoPmg::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParametroSaldoPmg(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParametroSaldoPmg * SOAP_FMAC4 soap_in_ns2__ParametroSaldoPmg(struct soap *soap, const char *tag, ns2__ParametroSaldoPmg *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParametroSaldoPmg *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParametroSaldoPmg, sizeof(ns2__ParametroSaldoPmg), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParametroSaldoPmg)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParametroSaldoPmg *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	size_t soap_flag_Secuencia1 = 1;
	size_t soap_flag_EstadoViv1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ParametroSaldoPmg::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			if (soap_flag_Secuencia1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Secuencia", &(a->ns2__ParametroSaldoPmg::Secuencia), "xsd:string"))
				{	soap_flag_Secuencia1--;
					continue;
				}
			if (soap_flag_EstadoViv1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "EstadoViv", &(a->ns2__ParametroSaldoPmg::EstadoViv), "xsd:int"))
				{	soap_flag_EstadoViv1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParametroSaldoPmg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParametroSaldoPmg, 0, sizeof(ns2__ParametroSaldoPmg), 0, soap_copy_ns2__ParametroSaldoPmg);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_EstadoViv1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ParametroSaldoPmg::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParametroSaldoPmg);
	if (this->soap_out(soap, tag?tag:"ns2:ParametroSaldoPmg", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParametroSaldoPmg::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParametroSaldoPmg(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParametroSaldoPmg * SOAP_FMAC4 soap_get_ns2__ParametroSaldoPmg(struct soap *soap, ns2__ParametroSaldoPmg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParametroSaldoPmg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParametroSaldoPmg * SOAP_FMAC2 soap_instantiate_ns2__ParametroSaldoPmg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParametroSaldoPmg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParametroSaldoPmg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParametroSaldoPmg);
		if (size)
			*size = sizeof(ns2__ParametroSaldoPmg);
		((ns2__ParametroSaldoPmg*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParametroSaldoPmg, n);
		if (size)
			*size = n * sizeof(ns2__ParametroSaldoPmg);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParametroSaldoPmg*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParametroSaldoPmg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParametroSaldoPmg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParametroSaldoPmg %p -> %p\n", q, p));
	*(ns2__ParametroSaldoPmg*)p = *(ns2__ParametroSaldoPmg*)q;
}

void ns2__ParametroNss::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_string(soap, &this->ns2__ParametroNss::Nss);
	/* transient soap skipped */
}

void ns2__ParametroNss::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__ParametroNss::Nss);
	/* transient soap skipped */
#endif
}

int ns2__ParametroNss::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParametroNss(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParametroNss(struct soap *soap, const char *tag, int id, const ns2__ParametroNss *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParametroNss), type))
		return soap->error;
	if (soap_out_string(soap, "Nss", -1, &(a->ns2__ParametroNss::Nss), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParametroNss::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParametroNss(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParametroNss * SOAP_FMAC4 soap_in_ns2__ParametroNss(struct soap *soap, const char *tag, ns2__ParametroNss *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParametroNss *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParametroNss, sizeof(ns2__ParametroNss), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParametroNss)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParametroNss *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Nss1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Nss1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "Nss", &(a->ns2__ParametroNss::Nss), "xsd:string"))
				{	soap_flag_Nss1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParametroNss *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParametroNss, 0, sizeof(ns2__ParametroNss), 0, soap_copy_ns2__ParametroNss);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int ns2__ParametroNss::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParametroNss);
	if (this->soap_out(soap, tag?tag:"ns2:ParametroNss", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParametroNss::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParametroNss(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParametroNss * SOAP_FMAC4 soap_get_ns2__ParametroNss(struct soap *soap, ns2__ParametroNss *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParametroNss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParametroNss * SOAP_FMAC2 soap_instantiate_ns2__ParametroNss(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParametroNss(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParametroNss, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParametroNss);
		if (size)
			*size = sizeof(ns2__ParametroNss);
		((ns2__ParametroNss*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParametroNss, n);
		if (size)
			*size = n * sizeof(ns2__ParametroNss);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParametroNss*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParametroNss*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParametroNss(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParametroNss %p -> %p\n", q, p));
	*(ns2__ParametroNss*)p = *(ns2__ParametroNss*)q;
}

void ns2__ParamConsultarAfiliado::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns2__ParamConsultarAfiliado::iFolioServicio);
	/* transient soap skipped */
}

void ns2__ParamConsultarAfiliado::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int ns2__ParamConsultarAfiliado::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__ParamConsultarAfiliado(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ParamConsultarAfiliado(struct soap *soap, const char *tag, int id, const ns2__ParamConsultarAfiliado *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ParamConsultarAfiliado), type))
		return soap->error;
	if (soap_out_int(soap, "iFolioServicio", -1, &(a->ns2__ParamConsultarAfiliado::iFolioServicio), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__ParamConsultarAfiliado::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__ParamConsultarAfiliado(soap, tag, this, type);
}

SOAP_FMAC3 ns2__ParamConsultarAfiliado * SOAP_FMAC4 soap_in_ns2__ParamConsultarAfiliado(struct soap *soap, const char *tag, ns2__ParamConsultarAfiliado *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__ParamConsultarAfiliado *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ParamConsultarAfiliado, sizeof(ns2__ParamConsultarAfiliado), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__ParamConsultarAfiliado)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__ParamConsultarAfiliado *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_iFolioServicio1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_iFolioServicio1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "iFolioServicio", &(a->ns2__ParamConsultarAfiliado::iFolioServicio), "xsd:int"))
				{	soap_flag_iFolioServicio1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__ParamConsultarAfiliado *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ParamConsultarAfiliado, 0, sizeof(ns2__ParamConsultarAfiliado), 0, soap_copy_ns2__ParamConsultarAfiliado);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_iFolioServicio1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__ParamConsultarAfiliado::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__ParamConsultarAfiliado);
	if (this->soap_out(soap, tag?tag:"ns2:ParamConsultarAfiliado", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__ParamConsultarAfiliado::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__ParamConsultarAfiliado(soap, this, tag, type);
}

SOAP_FMAC3 ns2__ParamConsultarAfiliado * SOAP_FMAC4 soap_get_ns2__ParamConsultarAfiliado(struct soap *soap, ns2__ParamConsultarAfiliado *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ParamConsultarAfiliado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__ParamConsultarAfiliado * SOAP_FMAC2 soap_instantiate_ns2__ParamConsultarAfiliado(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ParamConsultarAfiliado(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ParamConsultarAfiliado, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__ParamConsultarAfiliado);
		if (size)
			*size = sizeof(ns2__ParamConsultarAfiliado);
		((ns2__ParamConsultarAfiliado*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__ParamConsultarAfiliado, n);
		if (size)
			*size = n * sizeof(ns2__ParamConsultarAfiliado);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__ParamConsultarAfiliado*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__ParamConsultarAfiliado*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ParamConsultarAfiliado(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__ParamConsultarAfiliado %p -> %p\n", q, p));
	*(ns2__ParamConsultarAfiliado*)p = *(ns2__ParamConsultarAfiliado*)q;
}

void ns2__EstadoProceso::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &this->ns2__EstadoProceso::Estado);
	soap_default_string(soap, &this->ns2__EstadoProceso::DescripcionEstado);
	/* transient soap skipped */
}

void ns2__EstadoProceso::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_string(soap, &this->ns2__EstadoProceso::DescripcionEstado);
	/* transient soap skipped */
#endif
}

int ns2__EstadoProceso::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns2__EstadoProceso(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__EstadoProceso(struct soap *soap, const char *tag, int id, const ns2__EstadoProceso *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__EstadoProceso), type))
		return soap->error;
	if (soap_out_short(soap, "Estado", -1, &(a->ns2__EstadoProceso::Estado), ""))
		return soap->error;
	if (soap_out_string(soap, "DescripcionEstado", -1, &(a->ns2__EstadoProceso::DescripcionEstado), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns2__EstadoProceso::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns2__EstadoProceso(soap, tag, this, type);
}

SOAP_FMAC3 ns2__EstadoProceso * SOAP_FMAC4 soap_in_ns2__EstadoProceso(struct soap *soap, const char *tag, ns2__EstadoProceso *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns2__EstadoProceso *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__EstadoProceso, sizeof(ns2__EstadoProceso), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns2__EstadoProceso)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns2__EstadoProceso *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Estado1 = 1;
	size_t soap_flag_DescripcionEstado1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Estado1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "Estado", &(a->ns2__EstadoProceso::Estado), "xsd:short"))
				{	soap_flag_Estado1--;
					continue;
				}
			if (soap_flag_DescripcionEstado1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "DescripcionEstado", &(a->ns2__EstadoProceso::DescripcionEstado), "xsd:string"))
				{	soap_flag_DescripcionEstado1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns2__EstadoProceso *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__EstadoProceso, 0, sizeof(ns2__EstadoProceso), 0, soap_copy_ns2__EstadoProceso);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Estado1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns2__EstadoProceso::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns2__EstadoProceso);
	if (this->soap_out(soap, tag?tag:"ns2:EstadoProceso", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns2__EstadoProceso::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns2__EstadoProceso(soap, this, tag, type);
}

SOAP_FMAC3 ns2__EstadoProceso * SOAP_FMAC4 soap_get_ns2__EstadoProceso(struct soap *soap, ns2__EstadoProceso *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__EstadoProceso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns2__EstadoProceso * SOAP_FMAC2 soap_instantiate_ns2__EstadoProceso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__EstadoProceso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__EstadoProceso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns2__EstadoProceso);
		if (size)
			*size = sizeof(ns2__EstadoProceso);
		((ns2__EstadoProceso*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(ns2__EstadoProceso, n);
		if (size)
			*size = n * sizeof(ns2__EstadoProceso);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((ns2__EstadoProceso*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (ns2__EstadoProceso*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__EstadoProceso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns2__EstadoProceso %p -> %p\n", q, p));
	*(ns2__EstadoProceso*)p = *(ns2__EstadoProceso*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__consultarSaldosPenMinGar(struct soap *soap, struct ns2__consultarSaldosPenMinGar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__consultarSaldosPenMinGar(struct soap *soap, const struct ns2__consultarSaldosPenMinGar *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroNss(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__consultarSaldosPenMinGar(struct soap *soap, const char *tag, int id, const struct ns2__consultarSaldosPenMinGar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__consultarSaldosPenMinGar), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroNss(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__consultarSaldosPenMinGar * SOAP_FMAC4 soap_in_ns2__consultarSaldosPenMinGar(struct soap *soap, const char *tag, struct ns2__consultarSaldosPenMinGar *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__consultarSaldosPenMinGar *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__consultarSaldosPenMinGar, sizeof(struct ns2__consultarSaldosPenMinGar), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__consultarSaldosPenMinGar(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroNss(soap, "inParam", &a->inParam, "ns2:ParametroNss"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__consultarSaldosPenMinGar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__consultarSaldosPenMinGar, 0, sizeof(struct ns2__consultarSaldosPenMinGar), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__consultarSaldosPenMinGar(struct soap *soap, const struct ns2__consultarSaldosPenMinGar *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__consultarSaldosPenMinGar);
	if (soap_out_ns2__consultarSaldosPenMinGar(soap, tag?tag:"ns2:consultarSaldosPenMinGar", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__consultarSaldosPenMinGar * SOAP_FMAC4 soap_get_ns2__consultarSaldosPenMinGar(struct soap *soap, struct ns2__consultarSaldosPenMinGar *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__consultarSaldosPenMinGar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__consultarSaldosPenMinGar * SOAP_FMAC2 soap_instantiate_ns2__consultarSaldosPenMinGar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__consultarSaldosPenMinGar(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__consultarSaldosPenMinGar, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__consultarSaldosPenMinGar);
		if (size)
			*size = sizeof(struct ns2__consultarSaldosPenMinGar);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__consultarSaldosPenMinGar, n);
		if (size)
			*size = n * sizeof(struct ns2__consultarSaldosPenMinGar);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__consultarSaldosPenMinGar*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__consultarSaldosPenMinGar(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__consultarSaldosPenMinGar %p -> %p\n", q, p));
	*(struct ns2__consultarSaldosPenMinGar*)p = *(struct ns2__consultarSaldosPenMinGar*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__consultarSaldosPenMinGarResponse(struct soap *soap, struct ns2__consultarSaldosPenMinGarResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outSaldos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__consultarSaldosPenMinGarResponse(struct soap *soap, const struct ns2__consultarSaldosPenMinGarResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SaldoPorSubcuenta(soap, &a->outSaldos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__consultarSaldosPenMinGarResponse(struct soap *soap, const char *tag, int id, const struct ns2__consultarSaldosPenMinGarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__consultarSaldosPenMinGarResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__SaldoPorSubcuenta(soap, "outSaldos", -1, &a->outSaldos, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__consultarSaldosPenMinGarResponse * SOAP_FMAC4 soap_in_ns2__consultarSaldosPenMinGarResponse(struct soap *soap, const char *tag, struct ns2__consultarSaldosPenMinGarResponse *a, const char *type)
{
	size_t soap_flag_outSaldos = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__consultarSaldosPenMinGarResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__consultarSaldosPenMinGarResponse, sizeof(struct ns2__consultarSaldosPenMinGarResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__consultarSaldosPenMinGarResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outSaldos && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SaldoPorSubcuenta(soap, "outSaldos", &a->outSaldos, "ns2:SaldoPorSubcuenta"))
				{	soap_flag_outSaldos--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__consultarSaldosPenMinGarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__consultarSaldosPenMinGarResponse, 0, sizeof(struct ns2__consultarSaldosPenMinGarResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__consultarSaldosPenMinGarResponse(struct soap *soap, const struct ns2__consultarSaldosPenMinGarResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__consultarSaldosPenMinGarResponse);
	if (soap_out_ns2__consultarSaldosPenMinGarResponse(soap, tag?tag:"ns2:consultarSaldosPenMinGarResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__consultarSaldosPenMinGarResponse * SOAP_FMAC4 soap_get_ns2__consultarSaldosPenMinGarResponse(struct soap *soap, struct ns2__consultarSaldosPenMinGarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__consultarSaldosPenMinGarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__consultarSaldosPenMinGarResponse * SOAP_FMAC2 soap_instantiate_ns2__consultarSaldosPenMinGarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__consultarSaldosPenMinGarResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__consultarSaldosPenMinGarResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__consultarSaldosPenMinGarResponse);
		if (size)
			*size = sizeof(struct ns2__consultarSaldosPenMinGarResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__consultarSaldosPenMinGarResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__consultarSaldosPenMinGarResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__consultarSaldosPenMinGarResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__consultarSaldosPenMinGarResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__consultarSaldosPenMinGarResponse %p -> %p\n", q, p));
	*(struct ns2__consultarSaldosPenMinGarResponse*)p = *(struct ns2__consultarSaldosPenMinGarResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CConsultarNumMensualidad(struct soap *soap, struct ns2__CConsultarNumMensualidad *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CConsultarNumMensualidad(struct soap *soap, const struct ns2__CConsultarNumMensualidad *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroNss(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CConsultarNumMensualidad(struct soap *soap, const char *tag, int id, const struct ns2__CConsultarNumMensualidad *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CConsultarNumMensualidad), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroNss(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__CConsultarNumMensualidad * SOAP_FMAC4 soap_in_ns2__CConsultarNumMensualidad(struct soap *soap, const char *tag, struct ns2__CConsultarNumMensualidad *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__CConsultarNumMensualidad *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CConsultarNumMensualidad, sizeof(struct ns2__CConsultarNumMensualidad), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__CConsultarNumMensualidad(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroNss(soap, "inParam", &a->inParam, "ns2:ParametroNss"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__CConsultarNumMensualidad *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CConsultarNumMensualidad, 0, sizeof(struct ns2__CConsultarNumMensualidad), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CConsultarNumMensualidad(struct soap *soap, const struct ns2__CConsultarNumMensualidad *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CConsultarNumMensualidad);
	if (soap_out_ns2__CConsultarNumMensualidad(soap, tag?tag:"ns2:CConsultarNumMensualidad", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CConsultarNumMensualidad * SOAP_FMAC4 soap_get_ns2__CConsultarNumMensualidad(struct soap *soap, struct ns2__CConsultarNumMensualidad *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CConsultarNumMensualidad(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__CConsultarNumMensualidad * SOAP_FMAC2 soap_instantiate_ns2__CConsultarNumMensualidad(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CConsultarNumMensualidad(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CConsultarNumMensualidad, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__CConsultarNumMensualidad);
		if (size)
			*size = sizeof(struct ns2__CConsultarNumMensualidad);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__CConsultarNumMensualidad, n);
		if (size)
			*size = n * sizeof(struct ns2__CConsultarNumMensualidad);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__CConsultarNumMensualidad*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CConsultarNumMensualidad(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__CConsultarNumMensualidad %p -> %p\n", q, p));
	*(struct ns2__CConsultarNumMensualidad*)p = *(struct ns2__CConsultarNumMensualidad*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CConsultarNumMensualidadResponse(struct soap *soap, struct ns2__CConsultarNumMensualidadResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CConsultarNumMensualidadResponse(struct soap *soap, const struct ns2__CConsultarNumMensualidadResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaMensualidad(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CConsultarNumMensualidadResponse(struct soap *soap, const char *tag, int id, const struct ns2__CConsultarNumMensualidadResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CConsultarNumMensualidadResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaMensualidad(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__CConsultarNumMensualidadResponse * SOAP_FMAC4 soap_in_ns2__CConsultarNumMensualidadResponse(struct soap *soap, const char *tag, struct ns2__CConsultarNumMensualidadResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__CConsultarNumMensualidadResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CConsultarNumMensualidadResponse, sizeof(struct ns2__CConsultarNumMensualidadResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__CConsultarNumMensualidadResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaMensualidad(soap, "outParam", &a->outParam, "ns2:RespuestaMensualidad"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__CConsultarNumMensualidadResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CConsultarNumMensualidadResponse, 0, sizeof(struct ns2__CConsultarNumMensualidadResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CConsultarNumMensualidadResponse(struct soap *soap, const struct ns2__CConsultarNumMensualidadResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CConsultarNumMensualidadResponse);
	if (soap_out_ns2__CConsultarNumMensualidadResponse(soap, tag?tag:"ns2:CConsultarNumMensualidadResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CConsultarNumMensualidadResponse * SOAP_FMAC4 soap_get_ns2__CConsultarNumMensualidadResponse(struct soap *soap, struct ns2__CConsultarNumMensualidadResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CConsultarNumMensualidadResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__CConsultarNumMensualidadResponse * SOAP_FMAC2 soap_instantiate_ns2__CConsultarNumMensualidadResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CConsultarNumMensualidadResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CConsultarNumMensualidadResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__CConsultarNumMensualidadResponse);
		if (size)
			*size = sizeof(struct ns2__CConsultarNumMensualidadResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__CConsultarNumMensualidadResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__CConsultarNumMensualidadResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__CConsultarNumMensualidadResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CConsultarNumMensualidadResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__CConsultarNumMensualidadResponse %p -> %p\n", q, p));
	*(struct ns2__CConsultarNumMensualidadResponse*)p = *(struct ns2__CConsultarNumMensualidadResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CConsultarFechaLiquida(struct soap *soap, struct ns2__CConsultarFechaLiquida *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CConsultarFechaLiquida(struct soap *soap, const struct ns2__CConsultarFechaLiquida *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroNss(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CConsultarFechaLiquida(struct soap *soap, const char *tag, int id, const struct ns2__CConsultarFechaLiquida *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CConsultarFechaLiquida), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroNss(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__CConsultarFechaLiquida * SOAP_FMAC4 soap_in_ns2__CConsultarFechaLiquida(struct soap *soap, const char *tag, struct ns2__CConsultarFechaLiquida *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__CConsultarFechaLiquida *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CConsultarFechaLiquida, sizeof(struct ns2__CConsultarFechaLiquida), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__CConsultarFechaLiquida(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroNss(soap, "inParam", &a->inParam, "ns2:ParametroNss"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__CConsultarFechaLiquida *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CConsultarFechaLiquida, 0, sizeof(struct ns2__CConsultarFechaLiquida), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CConsultarFechaLiquida(struct soap *soap, const struct ns2__CConsultarFechaLiquida *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CConsultarFechaLiquida);
	if (soap_out_ns2__CConsultarFechaLiquida(soap, tag?tag:"ns2:CConsultarFechaLiquida", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CConsultarFechaLiquida * SOAP_FMAC4 soap_get_ns2__CConsultarFechaLiquida(struct soap *soap, struct ns2__CConsultarFechaLiquida *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CConsultarFechaLiquida(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__CConsultarFechaLiquida * SOAP_FMAC2 soap_instantiate_ns2__CConsultarFechaLiquida(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CConsultarFechaLiquida(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CConsultarFechaLiquida, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__CConsultarFechaLiquida);
		if (size)
			*size = sizeof(struct ns2__CConsultarFechaLiquida);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__CConsultarFechaLiquida, n);
		if (size)
			*size = n * sizeof(struct ns2__CConsultarFechaLiquida);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__CConsultarFechaLiquida*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CConsultarFechaLiquida(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__CConsultarFechaLiquida %p -> %p\n", q, p));
	*(struct ns2__CConsultarFechaLiquida*)p = *(struct ns2__CConsultarFechaLiquida*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CConsultarFechaLiquidaResponse(struct soap *soap, struct ns2__CConsultarFechaLiquidaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CConsultarFechaLiquidaResponse(struct soap *soap, const struct ns2__CConsultarFechaLiquidaResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaFechaLiquida(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CConsultarFechaLiquidaResponse(struct soap *soap, const char *tag, int id, const struct ns2__CConsultarFechaLiquidaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CConsultarFechaLiquidaResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaFechaLiquida(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__CConsultarFechaLiquidaResponse * SOAP_FMAC4 soap_in_ns2__CConsultarFechaLiquidaResponse(struct soap *soap, const char *tag, struct ns2__CConsultarFechaLiquidaResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__CConsultarFechaLiquidaResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CConsultarFechaLiquidaResponse, sizeof(struct ns2__CConsultarFechaLiquidaResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__CConsultarFechaLiquidaResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaFechaLiquida(soap, "outParam", &a->outParam, "ns2:RespuestaFechaLiquida"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__CConsultarFechaLiquidaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CConsultarFechaLiquidaResponse, 0, sizeof(struct ns2__CConsultarFechaLiquidaResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CConsultarFechaLiquidaResponse(struct soap *soap, const struct ns2__CConsultarFechaLiquidaResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CConsultarFechaLiquidaResponse);
	if (soap_out_ns2__CConsultarFechaLiquidaResponse(soap, tag?tag:"ns2:CConsultarFechaLiquidaResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CConsultarFechaLiquidaResponse * SOAP_FMAC4 soap_get_ns2__CConsultarFechaLiquidaResponse(struct soap *soap, struct ns2__CConsultarFechaLiquidaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CConsultarFechaLiquidaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__CConsultarFechaLiquidaResponse * SOAP_FMAC2 soap_instantiate_ns2__CConsultarFechaLiquidaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CConsultarFechaLiquidaResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CConsultarFechaLiquidaResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__CConsultarFechaLiquidaResponse);
		if (size)
			*size = sizeof(struct ns2__CConsultarFechaLiquidaResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__CConsultarFechaLiquidaResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__CConsultarFechaLiquidaResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__CConsultarFechaLiquidaResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CConsultarFechaLiquidaResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__CConsultarFechaLiquidaResponse %p -> %p\n", q, p));
	*(struct ns2__CConsultarFechaLiquidaResponse*)p = *(struct ns2__CConsultarFechaLiquidaResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CConsultarSaldoRecuperar(struct soap *soap, struct ns2__CConsultarSaldoRecuperar *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CConsultarSaldoRecuperar(struct soap *soap, const struct ns2__CConsultarSaldoRecuperar *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroNss(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CConsultarSaldoRecuperar(struct soap *soap, const char *tag, int id, const struct ns2__CConsultarSaldoRecuperar *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CConsultarSaldoRecuperar), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroNss(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__CConsultarSaldoRecuperar * SOAP_FMAC4 soap_in_ns2__CConsultarSaldoRecuperar(struct soap *soap, const char *tag, struct ns2__CConsultarSaldoRecuperar *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__CConsultarSaldoRecuperar *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CConsultarSaldoRecuperar, sizeof(struct ns2__CConsultarSaldoRecuperar), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__CConsultarSaldoRecuperar(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroNss(soap, "inParam", &a->inParam, "ns2:ParametroNss"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__CConsultarSaldoRecuperar *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CConsultarSaldoRecuperar, 0, sizeof(struct ns2__CConsultarSaldoRecuperar), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CConsultarSaldoRecuperar(struct soap *soap, const struct ns2__CConsultarSaldoRecuperar *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CConsultarSaldoRecuperar);
	if (soap_out_ns2__CConsultarSaldoRecuperar(soap, tag?tag:"ns2:CConsultarSaldoRecuperar", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CConsultarSaldoRecuperar * SOAP_FMAC4 soap_get_ns2__CConsultarSaldoRecuperar(struct soap *soap, struct ns2__CConsultarSaldoRecuperar *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CConsultarSaldoRecuperar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__CConsultarSaldoRecuperar * SOAP_FMAC2 soap_instantiate_ns2__CConsultarSaldoRecuperar(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CConsultarSaldoRecuperar(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CConsultarSaldoRecuperar, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__CConsultarSaldoRecuperar);
		if (size)
			*size = sizeof(struct ns2__CConsultarSaldoRecuperar);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__CConsultarSaldoRecuperar, n);
		if (size)
			*size = n * sizeof(struct ns2__CConsultarSaldoRecuperar);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__CConsultarSaldoRecuperar*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CConsultarSaldoRecuperar(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__CConsultarSaldoRecuperar %p -> %p\n", q, p));
	*(struct ns2__CConsultarSaldoRecuperar*)p = *(struct ns2__CConsultarSaldoRecuperar*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CConsultarSaldoRecuperarResponse(struct soap *soap, struct ns2__CConsultarSaldoRecuperarResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CConsultarSaldoRecuperarResponse(struct soap *soap, const struct ns2__CConsultarSaldoRecuperarResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaSaldoRecuperar(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CConsultarSaldoRecuperarResponse(struct soap *soap, const char *tag, int id, const struct ns2__CConsultarSaldoRecuperarResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CConsultarSaldoRecuperarResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaSaldoRecuperar(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__CConsultarSaldoRecuperarResponse * SOAP_FMAC4 soap_in_ns2__CConsultarSaldoRecuperarResponse(struct soap *soap, const char *tag, struct ns2__CConsultarSaldoRecuperarResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__CConsultarSaldoRecuperarResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CConsultarSaldoRecuperarResponse, sizeof(struct ns2__CConsultarSaldoRecuperarResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__CConsultarSaldoRecuperarResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaSaldoRecuperar(soap, "outParam", &a->outParam, "ns2:RespuestaSaldoRecuperar"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__CConsultarSaldoRecuperarResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CConsultarSaldoRecuperarResponse, 0, sizeof(struct ns2__CConsultarSaldoRecuperarResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CConsultarSaldoRecuperarResponse(struct soap *soap, const struct ns2__CConsultarSaldoRecuperarResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CConsultarSaldoRecuperarResponse);
	if (soap_out_ns2__CConsultarSaldoRecuperarResponse(soap, tag?tag:"ns2:CConsultarSaldoRecuperarResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CConsultarSaldoRecuperarResponse * SOAP_FMAC4 soap_get_ns2__CConsultarSaldoRecuperarResponse(struct soap *soap, struct ns2__CConsultarSaldoRecuperarResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CConsultarSaldoRecuperarResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__CConsultarSaldoRecuperarResponse * SOAP_FMAC2 soap_instantiate_ns2__CConsultarSaldoRecuperarResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CConsultarSaldoRecuperarResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CConsultarSaldoRecuperarResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__CConsultarSaldoRecuperarResponse);
		if (size)
			*size = sizeof(struct ns2__CConsultarSaldoRecuperarResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__CConsultarSaldoRecuperarResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__CConsultarSaldoRecuperarResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__CConsultarSaldoRecuperarResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CConsultarSaldoRecuperarResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__CConsultarSaldoRecuperarResponse %p -> %p\n", q, p));
	*(struct ns2__CConsultarSaldoRecuperarResponse*)p = *(struct ns2__CConsultarSaldoRecuperarResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CConsultarResolusionRetAportaciones(struct soap *soap, struct ns2__CConsultarResolusionRetAportaciones *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CConsultarResolusionRetAportaciones(struct soap *soap, const struct ns2__CConsultarResolusionRetAportaciones *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroCurpNss(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CConsultarResolusionRetAportaciones(struct soap *soap, const char *tag, int id, const struct ns2__CConsultarResolusionRetAportaciones *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CConsultarResolusionRetAportaciones), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroCurpNss(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__CConsultarResolusionRetAportaciones * SOAP_FMAC4 soap_in_ns2__CConsultarResolusionRetAportaciones(struct soap *soap, const char *tag, struct ns2__CConsultarResolusionRetAportaciones *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__CConsultarResolusionRetAportaciones *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CConsultarResolusionRetAportaciones, sizeof(struct ns2__CConsultarResolusionRetAportaciones), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__CConsultarResolusionRetAportaciones(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroCurpNss(soap, "inParam", &a->inParam, "ns2:ParametroCurpNss"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__CConsultarResolusionRetAportaciones *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CConsultarResolusionRetAportaciones, 0, sizeof(struct ns2__CConsultarResolusionRetAportaciones), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CConsultarResolusionRetAportaciones(struct soap *soap, const struct ns2__CConsultarResolusionRetAportaciones *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CConsultarResolusionRetAportaciones);
	if (soap_out_ns2__CConsultarResolusionRetAportaciones(soap, tag?tag:"ns2:CConsultarResolusionRetAportaciones", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CConsultarResolusionRetAportaciones * SOAP_FMAC4 soap_get_ns2__CConsultarResolusionRetAportaciones(struct soap *soap, struct ns2__CConsultarResolusionRetAportaciones *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CConsultarResolusionRetAportaciones(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__CConsultarResolusionRetAportaciones * SOAP_FMAC2 soap_instantiate_ns2__CConsultarResolusionRetAportaciones(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CConsultarResolusionRetAportaciones(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CConsultarResolusionRetAportaciones, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__CConsultarResolusionRetAportaciones);
		if (size)
			*size = sizeof(struct ns2__CConsultarResolusionRetAportaciones);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__CConsultarResolusionRetAportaciones, n);
		if (size)
			*size = n * sizeof(struct ns2__CConsultarResolusionRetAportaciones);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__CConsultarResolusionRetAportaciones*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CConsultarResolusionRetAportaciones(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__CConsultarResolusionRetAportaciones %p -> %p\n", q, p));
	*(struct ns2__CConsultarResolusionRetAportaciones*)p = *(struct ns2__CConsultarResolusionRetAportaciones*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__CConsultarResolusionRetAportacionesResponse(struct soap *soap, struct ns2__CConsultarResolusionRetAportacionesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__CConsultarResolusionRetAportacionesResponse(struct soap *soap, const struct ns2__CConsultarResolusionRetAportacionesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaTipoSolicitante(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__CConsultarResolusionRetAportacionesResponse(struct soap *soap, const char *tag, int id, const struct ns2__CConsultarResolusionRetAportacionesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__CConsultarResolusionRetAportacionesResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaTipoSolicitante(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__CConsultarResolusionRetAportacionesResponse * SOAP_FMAC4 soap_in_ns2__CConsultarResolusionRetAportacionesResponse(struct soap *soap, const char *tag, struct ns2__CConsultarResolusionRetAportacionesResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__CConsultarResolusionRetAportacionesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__CConsultarResolusionRetAportacionesResponse, sizeof(struct ns2__CConsultarResolusionRetAportacionesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__CConsultarResolusionRetAportacionesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaTipoSolicitante(soap, "outParam", &a->outParam, "ns2:RespuestaTipoSolicitante"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__CConsultarResolusionRetAportacionesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__CConsultarResolusionRetAportacionesResponse, 0, sizeof(struct ns2__CConsultarResolusionRetAportacionesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__CConsultarResolusionRetAportacionesResponse(struct soap *soap, const struct ns2__CConsultarResolusionRetAportacionesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__CConsultarResolusionRetAportacionesResponse);
	if (soap_out_ns2__CConsultarResolusionRetAportacionesResponse(soap, tag?tag:"ns2:CConsultarResolusionRetAportacionesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__CConsultarResolusionRetAportacionesResponse * SOAP_FMAC4 soap_get_ns2__CConsultarResolusionRetAportacionesResponse(struct soap *soap, struct ns2__CConsultarResolusionRetAportacionesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__CConsultarResolusionRetAportacionesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__CConsultarResolusionRetAportacionesResponse * SOAP_FMAC2 soap_instantiate_ns2__CConsultarResolusionRetAportacionesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__CConsultarResolusionRetAportacionesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__CConsultarResolusionRetAportacionesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__CConsultarResolusionRetAportacionesResponse);
		if (size)
			*size = sizeof(struct ns2__CConsultarResolusionRetAportacionesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__CConsultarResolusionRetAportacionesResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__CConsultarResolusionRetAportacionesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__CConsultarResolusionRetAportacionesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__CConsultarResolusionRetAportacionesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__CConsultarResolusionRetAportacionesResponse %p -> %p\n", q, p));
	*(struct ns2__CConsultarResolusionRetAportacionesResponse*)p = *(struct ns2__CConsultarResolusionRetAportacionesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultaAportacionesPosteriores(struct soap *soap, struct ns2__ConsultaAportacionesPosteriores *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultaAportacionesPosteriores(struct soap *soap, const struct ns2__ConsultaAportacionesPosteriores *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroAportacionesPost(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultaAportacionesPosteriores(struct soap *soap, const char *tag, int id, const struct ns2__ConsultaAportacionesPosteriores *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultaAportacionesPosteriores), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroAportacionesPost(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultaAportacionesPosteriores * SOAP_FMAC4 soap_in_ns2__ConsultaAportacionesPosteriores(struct soap *soap, const char *tag, struct ns2__ConsultaAportacionesPosteriores *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultaAportacionesPosteriores *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultaAportacionesPosteriores, sizeof(struct ns2__ConsultaAportacionesPosteriores), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultaAportacionesPosteriores(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroAportacionesPost(soap, "inParam", &a->inParam, "ns2:ParametroAportacionesPost"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultaAportacionesPosteriores *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultaAportacionesPosteriores, 0, sizeof(struct ns2__ConsultaAportacionesPosteriores), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultaAportacionesPosteriores(struct soap *soap, const struct ns2__ConsultaAportacionesPosteriores *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultaAportacionesPosteriores);
	if (soap_out_ns2__ConsultaAportacionesPosteriores(soap, tag?tag:"ns2:ConsultaAportacionesPosteriores", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultaAportacionesPosteriores * SOAP_FMAC4 soap_get_ns2__ConsultaAportacionesPosteriores(struct soap *soap, struct ns2__ConsultaAportacionesPosteriores *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultaAportacionesPosteriores(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultaAportacionesPosteriores * SOAP_FMAC2 soap_instantiate_ns2__ConsultaAportacionesPosteriores(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultaAportacionesPosteriores(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultaAportacionesPosteriores, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultaAportacionesPosteriores);
		if (size)
			*size = sizeof(struct ns2__ConsultaAportacionesPosteriores);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultaAportacionesPosteriores, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultaAportacionesPosteriores);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultaAportacionesPosteriores*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultaAportacionesPosteriores(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultaAportacionesPosteriores %p -> %p\n", q, p));
	*(struct ns2__ConsultaAportacionesPosteriores*)p = *(struct ns2__ConsultaAportacionesPosteriores*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultaAportacionesPosterioresResponse(struct soap *soap, struct ns2__ConsultaAportacionesPosterioresResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultaAportacionesPosterioresResponse(struct soap *soap, const struct ns2__ConsultaAportacionesPosterioresResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaAportacionesPosteriores(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultaAportacionesPosterioresResponse(struct soap *soap, const char *tag, int id, const struct ns2__ConsultaAportacionesPosterioresResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultaAportacionesPosterioresResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaAportacionesPosteriores(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultaAportacionesPosterioresResponse * SOAP_FMAC4 soap_in_ns2__ConsultaAportacionesPosterioresResponse(struct soap *soap, const char *tag, struct ns2__ConsultaAportacionesPosterioresResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultaAportacionesPosterioresResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultaAportacionesPosterioresResponse, sizeof(struct ns2__ConsultaAportacionesPosterioresResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultaAportacionesPosterioresResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaAportacionesPosteriores(soap, "outParam", &a->outParam, "ns2:RespuestaAportacionesPosteriores"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultaAportacionesPosterioresResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultaAportacionesPosterioresResponse, 0, sizeof(struct ns2__ConsultaAportacionesPosterioresResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultaAportacionesPosterioresResponse(struct soap *soap, const struct ns2__ConsultaAportacionesPosterioresResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultaAportacionesPosterioresResponse);
	if (soap_out_ns2__ConsultaAportacionesPosterioresResponse(soap, tag?tag:"ns2:ConsultaAportacionesPosterioresResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultaAportacionesPosterioresResponse * SOAP_FMAC4 soap_get_ns2__ConsultaAportacionesPosterioresResponse(struct soap *soap, struct ns2__ConsultaAportacionesPosterioresResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultaAportacionesPosterioresResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultaAportacionesPosterioresResponse * SOAP_FMAC2 soap_instantiate_ns2__ConsultaAportacionesPosterioresResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultaAportacionesPosterioresResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultaAportacionesPosterioresResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultaAportacionesPosterioresResponse);
		if (size)
			*size = sizeof(struct ns2__ConsultaAportacionesPosterioresResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultaAportacionesPosterioresResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultaAportacionesPosterioresResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultaAportacionesPosterioresResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultaAportacionesPosterioresResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultaAportacionesPosterioresResponse %p -> %p\n", q, p));
	*(struct ns2__ConsultaAportacionesPosterioresResponse*)p = *(struct ns2__ConsultaAportacionesPosterioresResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultaSaldoVivienda(struct soap *soap, struct ns2__ConsultaSaldoVivienda *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultaSaldoVivienda(struct soap *soap, const struct ns2__ConsultaSaldoVivienda *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParamConsultaSaldoVivienda(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultaSaldoVivienda(struct soap *soap, const char *tag, int id, const struct ns2__ConsultaSaldoVivienda *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultaSaldoVivienda), type))
		return soap->error;
	if (soap_out_PointerTons2__ParamConsultaSaldoVivienda(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultaSaldoVivienda * SOAP_FMAC4 soap_in_ns2__ConsultaSaldoVivienda(struct soap *soap, const char *tag, struct ns2__ConsultaSaldoVivienda *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultaSaldoVivienda *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultaSaldoVivienda, sizeof(struct ns2__ConsultaSaldoVivienda), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultaSaldoVivienda(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParamConsultaSaldoVivienda(soap, "inParam", &a->inParam, "ns2:ParamConsultaSaldoVivienda"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultaSaldoVivienda *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultaSaldoVivienda, 0, sizeof(struct ns2__ConsultaSaldoVivienda), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultaSaldoVivienda(struct soap *soap, const struct ns2__ConsultaSaldoVivienda *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultaSaldoVivienda);
	if (soap_out_ns2__ConsultaSaldoVivienda(soap, tag?tag:"ns2:ConsultaSaldoVivienda", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultaSaldoVivienda * SOAP_FMAC4 soap_get_ns2__ConsultaSaldoVivienda(struct soap *soap, struct ns2__ConsultaSaldoVivienda *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultaSaldoVivienda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultaSaldoVivienda * SOAP_FMAC2 soap_instantiate_ns2__ConsultaSaldoVivienda(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultaSaldoVivienda(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultaSaldoVivienda, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultaSaldoVivienda);
		if (size)
			*size = sizeof(struct ns2__ConsultaSaldoVivienda);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultaSaldoVivienda, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultaSaldoVivienda);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultaSaldoVivienda*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultaSaldoVivienda(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultaSaldoVivienda %p -> %p\n", q, p));
	*(struct ns2__ConsultaSaldoVivienda*)p = *(struct ns2__ConsultaSaldoVivienda*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultaSaldoViviendaResponse(struct soap *soap, struct ns2__ConsultaSaldoViviendaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultaSaldoViviendaResponse(struct soap *soap, const struct ns2__ConsultaSaldoViviendaResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaConsultaSaldoVivienda(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultaSaldoViviendaResponse(struct soap *soap, const char *tag, int id, const struct ns2__ConsultaSaldoViviendaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultaSaldoViviendaResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaConsultaSaldoVivienda(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultaSaldoViviendaResponse * SOAP_FMAC4 soap_in_ns2__ConsultaSaldoViviendaResponse(struct soap *soap, const char *tag, struct ns2__ConsultaSaldoViviendaResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultaSaldoViviendaResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultaSaldoViviendaResponse, sizeof(struct ns2__ConsultaSaldoViviendaResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultaSaldoViviendaResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaConsultaSaldoVivienda(soap, "outParam", &a->outParam, "ns2:RespuestaConsultaSaldoVivienda"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultaSaldoViviendaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultaSaldoViviendaResponse, 0, sizeof(struct ns2__ConsultaSaldoViviendaResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultaSaldoViviendaResponse(struct soap *soap, const struct ns2__ConsultaSaldoViviendaResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultaSaldoViviendaResponse);
	if (soap_out_ns2__ConsultaSaldoViviendaResponse(soap, tag?tag:"ns2:ConsultaSaldoViviendaResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultaSaldoViviendaResponse * SOAP_FMAC4 soap_get_ns2__ConsultaSaldoViviendaResponse(struct soap *soap, struct ns2__ConsultaSaldoViviendaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultaSaldoViviendaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultaSaldoViviendaResponse * SOAP_FMAC2 soap_instantiate_ns2__ConsultaSaldoViviendaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultaSaldoViviendaResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultaSaldoViviendaResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultaSaldoViviendaResponse);
		if (size)
			*size = sizeof(struct ns2__ConsultaSaldoViviendaResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultaSaldoViviendaResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultaSaldoViviendaResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultaSaldoViviendaResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultaSaldoViviendaResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultaSaldoViviendaResponse %p -> %p\n", q, p));
	*(struct ns2__ConsultaSaldoViviendaResponse*)p = *(struct ns2__ConsultaSaldoViviendaResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultarSaldoVol(struct soap *soap, struct ns2__ConsultarSaldoVol *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultarSaldoVol(struct soap *soap, const struct ns2__ConsultarSaldoVol *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroNss(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarSaldoVol(struct soap *soap, const char *tag, int id, const struct ns2__ConsultarSaldoVol *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarSaldoVol), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroNss(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultarSaldoVol * SOAP_FMAC4 soap_in_ns2__ConsultarSaldoVol(struct soap *soap, const char *tag, struct ns2__ConsultarSaldoVol *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultarSaldoVol *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarSaldoVol, sizeof(struct ns2__ConsultarSaldoVol), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultarSaldoVol(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroNss(soap, "inParam", &a->inParam, "ns2:ParametroNss"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultarSaldoVol *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarSaldoVol, 0, sizeof(struct ns2__ConsultarSaldoVol), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultarSaldoVol(struct soap *soap, const struct ns2__ConsultarSaldoVol *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarSaldoVol);
	if (soap_out_ns2__ConsultarSaldoVol(soap, tag?tag:"ns2:ConsultarSaldoVol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultarSaldoVol * SOAP_FMAC4 soap_get_ns2__ConsultarSaldoVol(struct soap *soap, struct ns2__ConsultarSaldoVol *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarSaldoVol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultarSaldoVol * SOAP_FMAC2 soap_instantiate_ns2__ConsultarSaldoVol(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarSaldoVol(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarSaldoVol, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultarSaldoVol);
		if (size)
			*size = sizeof(struct ns2__ConsultarSaldoVol);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultarSaldoVol, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultarSaldoVol);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultarSaldoVol*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarSaldoVol(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultarSaldoVol %p -> %p\n", q, p));
	*(struct ns2__ConsultarSaldoVol*)p = *(struct ns2__ConsultarSaldoVol*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultarSaldoVolResponse(struct soap *soap, struct ns2__ConsultarSaldoVolResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultarSaldoVolResponse(struct soap *soap, const struct ns2__ConsultarSaldoVolResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaCtaSaldoVol(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarSaldoVolResponse(struct soap *soap, const char *tag, int id, const struct ns2__ConsultarSaldoVolResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarSaldoVolResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaCtaSaldoVol(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultarSaldoVolResponse * SOAP_FMAC4 soap_in_ns2__ConsultarSaldoVolResponse(struct soap *soap, const char *tag, struct ns2__ConsultarSaldoVolResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultarSaldoVolResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarSaldoVolResponse, sizeof(struct ns2__ConsultarSaldoVolResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultarSaldoVolResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaCtaSaldoVol(soap, "outParam", &a->outParam, "ns2:RespuestaCtaSaldoVol"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultarSaldoVolResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarSaldoVolResponse, 0, sizeof(struct ns2__ConsultarSaldoVolResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultarSaldoVolResponse(struct soap *soap, const struct ns2__ConsultarSaldoVolResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarSaldoVolResponse);
	if (soap_out_ns2__ConsultarSaldoVolResponse(soap, tag?tag:"ns2:ConsultarSaldoVolResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultarSaldoVolResponse * SOAP_FMAC4 soap_get_ns2__ConsultarSaldoVolResponse(struct soap *soap, struct ns2__ConsultarSaldoVolResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarSaldoVolResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultarSaldoVolResponse * SOAP_FMAC2 soap_instantiate_ns2__ConsultarSaldoVolResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarSaldoVolResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarSaldoVolResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultarSaldoVolResponse);
		if (size)
			*size = sizeof(struct ns2__ConsultarSaldoVolResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultarSaldoVolResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultarSaldoVolResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultarSaldoVolResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarSaldoVolResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultarSaldoVolResponse %p -> %p\n", q, p));
	*(struct ns2__ConsultarSaldoVolResponse*)p = *(struct ns2__ConsultarSaldoVolResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultarSieforeCtaRegimen(struct soap *soap, struct ns2__ConsultarSieforeCtaRegimen *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultarSieforeCtaRegimen(struct soap *soap, const struct ns2__ConsultarSieforeCtaRegimen *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParamNssCtaRegimen(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarSieforeCtaRegimen(struct soap *soap, const char *tag, int id, const struct ns2__ConsultarSieforeCtaRegimen *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarSieforeCtaRegimen), type))
		return soap->error;
	if (soap_out_PointerTons2__ParamNssCtaRegimen(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultarSieforeCtaRegimen * SOAP_FMAC4 soap_in_ns2__ConsultarSieforeCtaRegimen(struct soap *soap, const char *tag, struct ns2__ConsultarSieforeCtaRegimen *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultarSieforeCtaRegimen *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarSieforeCtaRegimen, sizeof(struct ns2__ConsultarSieforeCtaRegimen), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultarSieforeCtaRegimen(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParamNssCtaRegimen(soap, "inParam", &a->inParam, "ns2:ParamNssCtaRegimen"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultarSieforeCtaRegimen *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarSieforeCtaRegimen, 0, sizeof(struct ns2__ConsultarSieforeCtaRegimen), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultarSieforeCtaRegimen(struct soap *soap, const struct ns2__ConsultarSieforeCtaRegimen *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarSieforeCtaRegimen);
	if (soap_out_ns2__ConsultarSieforeCtaRegimen(soap, tag?tag:"ns2:ConsultarSieforeCtaRegimen", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultarSieforeCtaRegimen * SOAP_FMAC4 soap_get_ns2__ConsultarSieforeCtaRegimen(struct soap *soap, struct ns2__ConsultarSieforeCtaRegimen *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarSieforeCtaRegimen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultarSieforeCtaRegimen * SOAP_FMAC2 soap_instantiate_ns2__ConsultarSieforeCtaRegimen(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarSieforeCtaRegimen(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarSieforeCtaRegimen, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultarSieforeCtaRegimen);
		if (size)
			*size = sizeof(struct ns2__ConsultarSieforeCtaRegimen);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultarSieforeCtaRegimen, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultarSieforeCtaRegimen);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultarSieforeCtaRegimen*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarSieforeCtaRegimen(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultarSieforeCtaRegimen %p -> %p\n", q, p));
	*(struct ns2__ConsultarSieforeCtaRegimen*)p = *(struct ns2__ConsultarSieforeCtaRegimen*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultarSieforeCtaRegimenResponse(struct soap *soap, struct ns2__ConsultarSieforeCtaRegimenResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultarSieforeCtaRegimenResponse(struct soap *soap, const struct ns2__ConsultarSieforeCtaRegimenResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaSieforeCtaRegimen(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarSieforeCtaRegimenResponse(struct soap *soap, const char *tag, int id, const struct ns2__ConsultarSieforeCtaRegimenResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarSieforeCtaRegimenResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaSieforeCtaRegimen(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultarSieforeCtaRegimenResponse * SOAP_FMAC4 soap_in_ns2__ConsultarSieforeCtaRegimenResponse(struct soap *soap, const char *tag, struct ns2__ConsultarSieforeCtaRegimenResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultarSieforeCtaRegimenResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarSieforeCtaRegimenResponse, sizeof(struct ns2__ConsultarSieforeCtaRegimenResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultarSieforeCtaRegimenResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaSieforeCtaRegimen(soap, "outParam", &a->outParam, "ns2:RespuestaSieforeCtaRegimen"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultarSieforeCtaRegimenResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarSieforeCtaRegimenResponse, 0, sizeof(struct ns2__ConsultarSieforeCtaRegimenResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultarSieforeCtaRegimenResponse(struct soap *soap, const struct ns2__ConsultarSieforeCtaRegimenResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarSieforeCtaRegimenResponse);
	if (soap_out_ns2__ConsultarSieforeCtaRegimenResponse(soap, tag?tag:"ns2:ConsultarSieforeCtaRegimenResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultarSieforeCtaRegimenResponse * SOAP_FMAC4 soap_get_ns2__ConsultarSieforeCtaRegimenResponse(struct soap *soap, struct ns2__ConsultarSieforeCtaRegimenResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarSieforeCtaRegimenResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultarSieforeCtaRegimenResponse * SOAP_FMAC2 soap_instantiate_ns2__ConsultarSieforeCtaRegimenResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarSieforeCtaRegimenResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarSieforeCtaRegimenResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultarSieforeCtaRegimenResponse);
		if (size)
			*size = sizeof(struct ns2__ConsultarSieforeCtaRegimenResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultarSieforeCtaRegimenResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultarSieforeCtaRegimenResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultarSieforeCtaRegimenResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarSieforeCtaRegimenResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultarSieforeCtaRegimenResponse %p -> %p\n", q, p));
	*(struct ns2__ConsultarSieforeCtaRegimenResponse*)p = *(struct ns2__ConsultarSieforeCtaRegimenResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultarResolucionTotalImssRI(struct soap *soap, struct ns2__ConsultarResolucionTotalImssRI *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultarResolucionTotalImssRI(struct soap *soap, const struct ns2__ConsultarResolucionTotalImssRI *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParamResolucionTotalImssRI(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarResolucionTotalImssRI(struct soap *soap, const char *tag, int id, const struct ns2__ConsultarResolucionTotalImssRI *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarResolucionTotalImssRI), type))
		return soap->error;
	if (soap_out_PointerTons2__ParamResolucionTotalImssRI(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultarResolucionTotalImssRI * SOAP_FMAC4 soap_in_ns2__ConsultarResolucionTotalImssRI(struct soap *soap, const char *tag, struct ns2__ConsultarResolucionTotalImssRI *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultarResolucionTotalImssRI *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarResolucionTotalImssRI, sizeof(struct ns2__ConsultarResolucionTotalImssRI), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultarResolucionTotalImssRI(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParamResolucionTotalImssRI(soap, "inParam", &a->inParam, "ns2:ParamResolucionTotalImssRI"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultarResolucionTotalImssRI *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarResolucionTotalImssRI, 0, sizeof(struct ns2__ConsultarResolucionTotalImssRI), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultarResolucionTotalImssRI(struct soap *soap, const struct ns2__ConsultarResolucionTotalImssRI *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarResolucionTotalImssRI);
	if (soap_out_ns2__ConsultarResolucionTotalImssRI(soap, tag?tag:"ns2:ConsultarResolucionTotalImssRI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultarResolucionTotalImssRI * SOAP_FMAC4 soap_get_ns2__ConsultarResolucionTotalImssRI(struct soap *soap, struct ns2__ConsultarResolucionTotalImssRI *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarResolucionTotalImssRI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultarResolucionTotalImssRI * SOAP_FMAC2 soap_instantiate_ns2__ConsultarResolucionTotalImssRI(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarResolucionTotalImssRI(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarResolucionTotalImssRI, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultarResolucionTotalImssRI);
		if (size)
			*size = sizeof(struct ns2__ConsultarResolucionTotalImssRI);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultarResolucionTotalImssRI, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultarResolucionTotalImssRI);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultarResolucionTotalImssRI*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarResolucionTotalImssRI(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultarResolucionTotalImssRI %p -> %p\n", q, p));
	*(struct ns2__ConsultarResolucionTotalImssRI*)p = *(struct ns2__ConsultarResolucionTotalImssRI*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultarResolucionTotalImssRIResponse(struct soap *soap, struct ns2__ConsultarResolucionTotalImssRIResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultarResolucionTotalImssRIResponse(struct soap *soap, const struct ns2__ConsultarResolucionTotalImssRIResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaResolucionTotalImss(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarResolucionTotalImssRIResponse(struct soap *soap, const char *tag, int id, const struct ns2__ConsultarResolucionTotalImssRIResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarResolucionTotalImssRIResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaResolucionTotalImss(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultarResolucionTotalImssRIResponse * SOAP_FMAC4 soap_in_ns2__ConsultarResolucionTotalImssRIResponse(struct soap *soap, const char *tag, struct ns2__ConsultarResolucionTotalImssRIResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultarResolucionTotalImssRIResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarResolucionTotalImssRIResponse, sizeof(struct ns2__ConsultarResolucionTotalImssRIResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultarResolucionTotalImssRIResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaResolucionTotalImss(soap, "outParam", &a->outParam, "ns2:RespuestaResolucionTotalImss"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultarResolucionTotalImssRIResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarResolucionTotalImssRIResponse, 0, sizeof(struct ns2__ConsultarResolucionTotalImssRIResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultarResolucionTotalImssRIResponse(struct soap *soap, const struct ns2__ConsultarResolucionTotalImssRIResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarResolucionTotalImssRIResponse);
	if (soap_out_ns2__ConsultarResolucionTotalImssRIResponse(soap, tag?tag:"ns2:ConsultarResolucionTotalImssRIResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultarResolucionTotalImssRIResponse * SOAP_FMAC4 soap_get_ns2__ConsultarResolucionTotalImssRIResponse(struct soap *soap, struct ns2__ConsultarResolucionTotalImssRIResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarResolucionTotalImssRIResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultarResolucionTotalImssRIResponse * SOAP_FMAC2 soap_instantiate_ns2__ConsultarResolucionTotalImssRIResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarResolucionTotalImssRIResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarResolucionTotalImssRIResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultarResolucionTotalImssRIResponse);
		if (size)
			*size = sizeof(struct ns2__ConsultarResolucionTotalImssRIResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultarResolucionTotalImssRIResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultarResolucionTotalImssRIResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultarResolucionTotalImssRIResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarResolucionTotalImssRIResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultarResolucionTotalImssRIResponse %p -> %p\n", q, p));
	*(struct ns2__ConsultarResolucionTotalImssRIResponse*)p = *(struct ns2__ConsultarResolucionTotalImssRIResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__consultarAportaciones(struct soap *soap, struct ns2__consultarAportaciones *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__consultarAportaciones(struct soap *soap, const struct ns2__consultarAportaciones *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParamAportacionesPosteriores(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__consultarAportaciones(struct soap *soap, const char *tag, int id, const struct ns2__consultarAportaciones *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__consultarAportaciones), type))
		return soap->error;
	if (soap_out_PointerTons2__ParamAportacionesPosteriores(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__consultarAportaciones * SOAP_FMAC4 soap_in_ns2__consultarAportaciones(struct soap *soap, const char *tag, struct ns2__consultarAportaciones *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__consultarAportaciones *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__consultarAportaciones, sizeof(struct ns2__consultarAportaciones), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__consultarAportaciones(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParamAportacionesPosteriores(soap, "inParam", &a->inParam, "ns2:ParamAportacionesPosteriores"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__consultarAportaciones *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__consultarAportaciones, 0, sizeof(struct ns2__consultarAportaciones), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__consultarAportaciones(struct soap *soap, const struct ns2__consultarAportaciones *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__consultarAportaciones);
	if (soap_out_ns2__consultarAportaciones(soap, tag?tag:"ns2:consultarAportaciones", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__consultarAportaciones * SOAP_FMAC4 soap_get_ns2__consultarAportaciones(struct soap *soap, struct ns2__consultarAportaciones *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__consultarAportaciones(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__consultarAportaciones * SOAP_FMAC2 soap_instantiate_ns2__consultarAportaciones(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__consultarAportaciones(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__consultarAportaciones, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__consultarAportaciones);
		if (size)
			*size = sizeof(struct ns2__consultarAportaciones);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__consultarAportaciones, n);
		if (size)
			*size = n * sizeof(struct ns2__consultarAportaciones);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__consultarAportaciones*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__consultarAportaciones(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__consultarAportaciones %p -> %p\n", q, p));
	*(struct ns2__consultarAportaciones*)p = *(struct ns2__consultarAportaciones*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__consultarAportacionesResponse(struct soap *soap, struct ns2__consultarAportacionesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__consultarAportacionesResponse(struct soap *soap, const struct ns2__consultarAportacionesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaAportacionesPosteriores(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__consultarAportacionesResponse(struct soap *soap, const char *tag, int id, const struct ns2__consultarAportacionesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__consultarAportacionesResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaAportacionesPosteriores(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__consultarAportacionesResponse * SOAP_FMAC4 soap_in_ns2__consultarAportacionesResponse(struct soap *soap, const char *tag, struct ns2__consultarAportacionesResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__consultarAportacionesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__consultarAportacionesResponse, sizeof(struct ns2__consultarAportacionesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__consultarAportacionesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaAportacionesPosteriores(soap, "outParam", &a->outParam, "ns2:RespuestaAportacionesPosteriores"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__consultarAportacionesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__consultarAportacionesResponse, 0, sizeof(struct ns2__consultarAportacionesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__consultarAportacionesResponse(struct soap *soap, const struct ns2__consultarAportacionesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__consultarAportacionesResponse);
	if (soap_out_ns2__consultarAportacionesResponse(soap, tag?tag:"ns2:consultarAportacionesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__consultarAportacionesResponse * SOAP_FMAC4 soap_get_ns2__consultarAportacionesResponse(struct soap *soap, struct ns2__consultarAportacionesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__consultarAportacionesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__consultarAportacionesResponse * SOAP_FMAC2 soap_instantiate_ns2__consultarAportacionesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__consultarAportacionesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__consultarAportacionesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__consultarAportacionesResponse);
		if (size)
			*size = sizeof(struct ns2__consultarAportacionesResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__consultarAportacionesResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__consultarAportacionesResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__consultarAportacionesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__consultarAportacionesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__consultarAportacionesResponse %p -> %p\n", q, p));
	*(struct ns2__consultarAportacionesResponse*)p = *(struct ns2__consultarAportacionesResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__consultarSaldosPmg(struct soap *soap, struct ns2__consultarSaldosPmg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__consultarSaldosPmg(struct soap *soap, const struct ns2__consultarSaldosPmg *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroSaldoPmg(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__consultarSaldosPmg(struct soap *soap, const char *tag, int id, const struct ns2__consultarSaldosPmg *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__consultarSaldosPmg), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroSaldoPmg(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__consultarSaldosPmg * SOAP_FMAC4 soap_in_ns2__consultarSaldosPmg(struct soap *soap, const char *tag, struct ns2__consultarSaldosPmg *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__consultarSaldosPmg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__consultarSaldosPmg, sizeof(struct ns2__consultarSaldosPmg), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__consultarSaldosPmg(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroSaldoPmg(soap, "inParam", &a->inParam, "ns2:ParametroSaldoPmg"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__consultarSaldosPmg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__consultarSaldosPmg, 0, sizeof(struct ns2__consultarSaldosPmg), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__consultarSaldosPmg(struct soap *soap, const struct ns2__consultarSaldosPmg *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__consultarSaldosPmg);
	if (soap_out_ns2__consultarSaldosPmg(soap, tag?tag:"ns2:consultarSaldosPmg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__consultarSaldosPmg * SOAP_FMAC4 soap_get_ns2__consultarSaldosPmg(struct soap *soap, struct ns2__consultarSaldosPmg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__consultarSaldosPmg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__consultarSaldosPmg * SOAP_FMAC2 soap_instantiate_ns2__consultarSaldosPmg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__consultarSaldosPmg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__consultarSaldosPmg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__consultarSaldosPmg);
		if (size)
			*size = sizeof(struct ns2__consultarSaldosPmg);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__consultarSaldosPmg, n);
		if (size)
			*size = n * sizeof(struct ns2__consultarSaldosPmg);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__consultarSaldosPmg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__consultarSaldosPmg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__consultarSaldosPmg %p -> %p\n", q, p));
	*(struct ns2__consultarSaldosPmg*)p = *(struct ns2__consultarSaldosPmg*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__consultarSaldosPmgResponse(struct soap *soap, struct ns2__consultarSaldosPmgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outSaldosPmg = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__consultarSaldosPmgResponse(struct soap *soap, const struct ns2__consultarSaldosPmgResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SaldoPorSubcuentaPmg(soap, &a->outSaldosPmg);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__consultarSaldosPmgResponse(struct soap *soap, const char *tag, int id, const struct ns2__consultarSaldosPmgResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__consultarSaldosPmgResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__SaldoPorSubcuentaPmg(soap, "outSaldosPmg", -1, &a->outSaldosPmg, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__consultarSaldosPmgResponse * SOAP_FMAC4 soap_in_ns2__consultarSaldosPmgResponse(struct soap *soap, const char *tag, struct ns2__consultarSaldosPmgResponse *a, const char *type)
{
	size_t soap_flag_outSaldosPmg = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__consultarSaldosPmgResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__consultarSaldosPmgResponse, sizeof(struct ns2__consultarSaldosPmgResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__consultarSaldosPmgResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outSaldosPmg && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SaldoPorSubcuentaPmg(soap, "outSaldosPmg", &a->outSaldosPmg, "ns2:SaldoPorSubcuentaPmg"))
				{	soap_flag_outSaldosPmg--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__consultarSaldosPmgResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__consultarSaldosPmgResponse, 0, sizeof(struct ns2__consultarSaldosPmgResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__consultarSaldosPmgResponse(struct soap *soap, const struct ns2__consultarSaldosPmgResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__consultarSaldosPmgResponse);
	if (soap_out_ns2__consultarSaldosPmgResponse(soap, tag?tag:"ns2:consultarSaldosPmgResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__consultarSaldosPmgResponse * SOAP_FMAC4 soap_get_ns2__consultarSaldosPmgResponse(struct soap *soap, struct ns2__consultarSaldosPmgResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__consultarSaldosPmgResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__consultarSaldosPmgResponse * SOAP_FMAC2 soap_instantiate_ns2__consultarSaldosPmgResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__consultarSaldosPmgResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__consultarSaldosPmgResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__consultarSaldosPmgResponse);
		if (size)
			*size = sizeof(struct ns2__consultarSaldosPmgResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__consultarSaldosPmgResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__consultarSaldosPmgResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__consultarSaldosPmgResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__consultarSaldosPmgResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__consultarSaldosPmgResponse %p -> %p\n", q, p));
	*(struct ns2__consultarSaldosPmgResponse*)p = *(struct ns2__consultarSaldosPmgResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultarResolucionTotalIssste(struct soap *soap, struct ns2__ConsultarResolucionTotalIssste *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultarResolucionTotalIssste(struct soap *soap, const struct ns2__ConsultarResolucionTotalIssste *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParamResolucionTotalIssste(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarResolucionTotalIssste(struct soap *soap, const char *tag, int id, const struct ns2__ConsultarResolucionTotalIssste *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarResolucionTotalIssste), type))
		return soap->error;
	if (soap_out_PointerTons2__ParamResolucionTotalIssste(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultarResolucionTotalIssste * SOAP_FMAC4 soap_in_ns2__ConsultarResolucionTotalIssste(struct soap *soap, const char *tag, struct ns2__ConsultarResolucionTotalIssste *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultarResolucionTotalIssste *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarResolucionTotalIssste, sizeof(struct ns2__ConsultarResolucionTotalIssste), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultarResolucionTotalIssste(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParamResolucionTotalIssste(soap, "inParam", &a->inParam, "ns2:ParamResolucionTotalIssste"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultarResolucionTotalIssste *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarResolucionTotalIssste, 0, sizeof(struct ns2__ConsultarResolucionTotalIssste), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultarResolucionTotalIssste(struct soap *soap, const struct ns2__ConsultarResolucionTotalIssste *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarResolucionTotalIssste);
	if (soap_out_ns2__ConsultarResolucionTotalIssste(soap, tag?tag:"ns2:ConsultarResolucionTotalIssste", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultarResolucionTotalIssste * SOAP_FMAC4 soap_get_ns2__ConsultarResolucionTotalIssste(struct soap *soap, struct ns2__ConsultarResolucionTotalIssste *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarResolucionTotalIssste(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultarResolucionTotalIssste * SOAP_FMAC2 soap_instantiate_ns2__ConsultarResolucionTotalIssste(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarResolucionTotalIssste(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarResolucionTotalIssste, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultarResolucionTotalIssste);
		if (size)
			*size = sizeof(struct ns2__ConsultarResolucionTotalIssste);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultarResolucionTotalIssste, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultarResolucionTotalIssste);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultarResolucionTotalIssste*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarResolucionTotalIssste(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultarResolucionTotalIssste %p -> %p\n", q, p));
	*(struct ns2__ConsultarResolucionTotalIssste*)p = *(struct ns2__ConsultarResolucionTotalIssste*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultarResolucionTotalIsssteResponse(struct soap *soap, struct ns2__ConsultarResolucionTotalIsssteResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultarResolucionTotalIsssteResponse(struct soap *soap, const struct ns2__ConsultarResolucionTotalIsssteResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaResolucionTotalIssste(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarResolucionTotalIsssteResponse(struct soap *soap, const char *tag, int id, const struct ns2__ConsultarResolucionTotalIsssteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarResolucionTotalIsssteResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaResolucionTotalIssste(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultarResolucionTotalIsssteResponse * SOAP_FMAC4 soap_in_ns2__ConsultarResolucionTotalIsssteResponse(struct soap *soap, const char *tag, struct ns2__ConsultarResolucionTotalIsssteResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultarResolucionTotalIsssteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarResolucionTotalIsssteResponse, sizeof(struct ns2__ConsultarResolucionTotalIsssteResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultarResolucionTotalIsssteResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaResolucionTotalIssste(soap, "outParam", &a->outParam, "ns2:RespuestaResolucionTotalIssste"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultarResolucionTotalIsssteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarResolucionTotalIsssteResponse, 0, sizeof(struct ns2__ConsultarResolucionTotalIsssteResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultarResolucionTotalIsssteResponse(struct soap *soap, const struct ns2__ConsultarResolucionTotalIsssteResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarResolucionTotalIsssteResponse);
	if (soap_out_ns2__ConsultarResolucionTotalIsssteResponse(soap, tag?tag:"ns2:ConsultarResolucionTotalIsssteResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultarResolucionTotalIsssteResponse * SOAP_FMAC4 soap_get_ns2__ConsultarResolucionTotalIsssteResponse(struct soap *soap, struct ns2__ConsultarResolucionTotalIsssteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarResolucionTotalIsssteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultarResolucionTotalIsssteResponse * SOAP_FMAC2 soap_instantiate_ns2__ConsultarResolucionTotalIsssteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarResolucionTotalIsssteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarResolucionTotalIsssteResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultarResolucionTotalIsssteResponse);
		if (size)
			*size = sizeof(struct ns2__ConsultarResolucionTotalIsssteResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultarResolucionTotalIsssteResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultarResolucionTotalIsssteResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultarResolucionTotalIsssteResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarResolucionTotalIsssteResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultarResolucionTotalIsssteResponse %p -> %p\n", q, p));
	*(struct ns2__ConsultarResolucionTotalIsssteResponse*)p = *(struct ns2__ConsultarResolucionTotalIsssteResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__movimientosCuentas(struct soap *soap, struct ns2__movimientosCuentas *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__movimientosCuentas(struct soap *soap, const struct ns2__movimientosCuentas *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParamMovimientosCuentas(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__movimientosCuentas(struct soap *soap, const char *tag, int id, const struct ns2__movimientosCuentas *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__movimientosCuentas), type))
		return soap->error;
	if (soap_out_PointerTons2__ParamMovimientosCuentas(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__movimientosCuentas * SOAP_FMAC4 soap_in_ns2__movimientosCuentas(struct soap *soap, const char *tag, struct ns2__movimientosCuentas *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__movimientosCuentas *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__movimientosCuentas, sizeof(struct ns2__movimientosCuentas), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__movimientosCuentas(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParamMovimientosCuentas(soap, "inParam", &a->inParam, "ns2:ParamMovimientosCuentas"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__movimientosCuentas *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__movimientosCuentas, 0, sizeof(struct ns2__movimientosCuentas), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__movimientosCuentas(struct soap *soap, const struct ns2__movimientosCuentas *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__movimientosCuentas);
	if (soap_out_ns2__movimientosCuentas(soap, tag?tag:"ns2:movimientosCuentas", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__movimientosCuentas * SOAP_FMAC4 soap_get_ns2__movimientosCuentas(struct soap *soap, struct ns2__movimientosCuentas *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__movimientosCuentas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__movimientosCuentas * SOAP_FMAC2 soap_instantiate_ns2__movimientosCuentas(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__movimientosCuentas(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__movimientosCuentas, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__movimientosCuentas);
		if (size)
			*size = sizeof(struct ns2__movimientosCuentas);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__movimientosCuentas, n);
		if (size)
			*size = n * sizeof(struct ns2__movimientosCuentas);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__movimientosCuentas*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__movimientosCuentas(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__movimientosCuentas %p -> %p\n", q, p));
	*(struct ns2__movimientosCuentas*)p = *(struct ns2__movimientosCuentas*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__movimientosCuentasResponse(struct soap *soap, struct ns2__movimientosCuentasResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__movimientosCuentasResponse(struct soap *soap, const struct ns2__movimientosCuentasResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaMovimientosCuentas(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__movimientosCuentasResponse(struct soap *soap, const char *tag, int id, const struct ns2__movimientosCuentasResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__movimientosCuentasResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaMovimientosCuentas(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__movimientosCuentasResponse * SOAP_FMAC4 soap_in_ns2__movimientosCuentasResponse(struct soap *soap, const char *tag, struct ns2__movimientosCuentasResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__movimientosCuentasResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__movimientosCuentasResponse, sizeof(struct ns2__movimientosCuentasResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__movimientosCuentasResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaMovimientosCuentas(soap, "outParam", &a->outParam, "ns2:RespuestaMovimientosCuentas"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__movimientosCuentasResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__movimientosCuentasResponse, 0, sizeof(struct ns2__movimientosCuentasResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__movimientosCuentasResponse(struct soap *soap, const struct ns2__movimientosCuentasResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__movimientosCuentasResponse);
	if (soap_out_ns2__movimientosCuentasResponse(soap, tag?tag:"ns2:movimientosCuentasResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__movimientosCuentasResponse * SOAP_FMAC4 soap_get_ns2__movimientosCuentasResponse(struct soap *soap, struct ns2__movimientosCuentasResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__movimientosCuentasResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__movimientosCuentasResponse * SOAP_FMAC2 soap_instantiate_ns2__movimientosCuentasResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__movimientosCuentasResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__movimientosCuentasResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__movimientosCuentasResponse);
		if (size)
			*size = sizeof(struct ns2__movimientosCuentasResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__movimientosCuentasResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__movimientosCuentasResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__movimientosCuentasResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__movimientosCuentasResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__movimientosCuentasResponse %p -> %p\n", q, p));
	*(struct ns2__movimientosCuentasResponse*)p = *(struct ns2__movimientosCuentasResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__COperacionesPmg(struct soap *soap, struct ns2__COperacionesPmg *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__COperacionesPmg(struct soap *soap, const struct ns2__COperacionesPmg *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParamOperacionPmgImss(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__COperacionesPmg(struct soap *soap, const char *tag, int id, const struct ns2__COperacionesPmg *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__COperacionesPmg), type))
		return soap->error;
	if (soap_out_PointerTons2__ParamOperacionPmgImss(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__COperacionesPmg * SOAP_FMAC4 soap_in_ns2__COperacionesPmg(struct soap *soap, const char *tag, struct ns2__COperacionesPmg *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__COperacionesPmg *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__COperacionesPmg, sizeof(struct ns2__COperacionesPmg), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__COperacionesPmg(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParamOperacionPmgImss(soap, "inParam", &a->inParam, "ns2:ParamOperacionPmgImss"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__COperacionesPmg *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__COperacionesPmg, 0, sizeof(struct ns2__COperacionesPmg), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__COperacionesPmg(struct soap *soap, const struct ns2__COperacionesPmg *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__COperacionesPmg);
	if (soap_out_ns2__COperacionesPmg(soap, tag?tag:"ns2:COperacionesPmg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__COperacionesPmg * SOAP_FMAC4 soap_get_ns2__COperacionesPmg(struct soap *soap, struct ns2__COperacionesPmg *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__COperacionesPmg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__COperacionesPmg * SOAP_FMAC2 soap_instantiate_ns2__COperacionesPmg(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__COperacionesPmg(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__COperacionesPmg, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__COperacionesPmg);
		if (size)
			*size = sizeof(struct ns2__COperacionesPmg);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__COperacionesPmg, n);
		if (size)
			*size = n * sizeof(struct ns2__COperacionesPmg);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__COperacionesPmg*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__COperacionesPmg(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__COperacionesPmg %p -> %p\n", q, p));
	*(struct ns2__COperacionesPmg*)p = *(struct ns2__COperacionesPmg*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__COperacionesPmgResponse(struct soap *soap, struct ns2__COperacionesPmgResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__COperacionesPmgResponse(struct soap *soap, const struct ns2__COperacionesPmgResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaCOperacionesPmgImss(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__COperacionesPmgResponse(struct soap *soap, const char *tag, int id, const struct ns2__COperacionesPmgResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__COperacionesPmgResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaCOperacionesPmgImss(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__COperacionesPmgResponse * SOAP_FMAC4 soap_in_ns2__COperacionesPmgResponse(struct soap *soap, const char *tag, struct ns2__COperacionesPmgResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__COperacionesPmgResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__COperacionesPmgResponse, sizeof(struct ns2__COperacionesPmgResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__COperacionesPmgResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaCOperacionesPmgImss(soap, "outParam", &a->outParam, "ns2:RespuestaCOperacionesPmgImss"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__COperacionesPmgResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__COperacionesPmgResponse, 0, sizeof(struct ns2__COperacionesPmgResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__COperacionesPmgResponse(struct soap *soap, const struct ns2__COperacionesPmgResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__COperacionesPmgResponse);
	if (soap_out_ns2__COperacionesPmgResponse(soap, tag?tag:"ns2:COperacionesPmgResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__COperacionesPmgResponse * SOAP_FMAC4 soap_get_ns2__COperacionesPmgResponse(struct soap *soap, struct ns2__COperacionesPmgResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__COperacionesPmgResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__COperacionesPmgResponse * SOAP_FMAC2 soap_instantiate_ns2__COperacionesPmgResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__COperacionesPmgResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__COperacionesPmgResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__COperacionesPmgResponse);
		if (size)
			*size = sizeof(struct ns2__COperacionesPmgResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__COperacionesPmgResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__COperacionesPmgResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__COperacionesPmgResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__COperacionesPmgResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__COperacionesPmgResponse %p -> %p\n", q, p));
	*(struct ns2__COperacionesPmgResponse*)p = *(struct ns2__COperacionesPmgResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultarResolucionTotalImss(struct soap *soap, struct ns2__ConsultarResolucionTotalImss *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultarResolucionTotalImss(struct soap *soap, const struct ns2__ConsultarResolucionTotalImss *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParamResolucionTotalImss(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarResolucionTotalImss(struct soap *soap, const char *tag, int id, const struct ns2__ConsultarResolucionTotalImss *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarResolucionTotalImss), type))
		return soap->error;
	if (soap_out_PointerTons2__ParamResolucionTotalImss(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultarResolucionTotalImss * SOAP_FMAC4 soap_in_ns2__ConsultarResolucionTotalImss(struct soap *soap, const char *tag, struct ns2__ConsultarResolucionTotalImss *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultarResolucionTotalImss *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarResolucionTotalImss, sizeof(struct ns2__ConsultarResolucionTotalImss), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultarResolucionTotalImss(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParamResolucionTotalImss(soap, "inParam", &a->inParam, "ns2:ParamResolucionTotalImss"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultarResolucionTotalImss *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarResolucionTotalImss, 0, sizeof(struct ns2__ConsultarResolucionTotalImss), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultarResolucionTotalImss(struct soap *soap, const struct ns2__ConsultarResolucionTotalImss *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarResolucionTotalImss);
	if (soap_out_ns2__ConsultarResolucionTotalImss(soap, tag?tag:"ns2:ConsultarResolucionTotalImss", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultarResolucionTotalImss * SOAP_FMAC4 soap_get_ns2__ConsultarResolucionTotalImss(struct soap *soap, struct ns2__ConsultarResolucionTotalImss *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarResolucionTotalImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultarResolucionTotalImss * SOAP_FMAC2 soap_instantiate_ns2__ConsultarResolucionTotalImss(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarResolucionTotalImss(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarResolucionTotalImss, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultarResolucionTotalImss);
		if (size)
			*size = sizeof(struct ns2__ConsultarResolucionTotalImss);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultarResolucionTotalImss, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultarResolucionTotalImss);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultarResolucionTotalImss*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarResolucionTotalImss(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultarResolucionTotalImss %p -> %p\n", q, p));
	*(struct ns2__ConsultarResolucionTotalImss*)p = *(struct ns2__ConsultarResolucionTotalImss*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultarResolucionTotalImssResponse(struct soap *soap, struct ns2__ConsultarResolucionTotalImssResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultarResolucionTotalImssResponse(struct soap *soap, const struct ns2__ConsultarResolucionTotalImssResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaResolucionTotalImss(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarResolucionTotalImssResponse(struct soap *soap, const char *tag, int id, const struct ns2__ConsultarResolucionTotalImssResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarResolucionTotalImssResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaResolucionTotalImss(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultarResolucionTotalImssResponse * SOAP_FMAC4 soap_in_ns2__ConsultarResolucionTotalImssResponse(struct soap *soap, const char *tag, struct ns2__ConsultarResolucionTotalImssResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultarResolucionTotalImssResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarResolucionTotalImssResponse, sizeof(struct ns2__ConsultarResolucionTotalImssResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultarResolucionTotalImssResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaResolucionTotalImss(soap, "outParam", &a->outParam, "ns2:RespuestaResolucionTotalImss"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultarResolucionTotalImssResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarResolucionTotalImssResponse, 0, sizeof(struct ns2__ConsultarResolucionTotalImssResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultarResolucionTotalImssResponse(struct soap *soap, const struct ns2__ConsultarResolucionTotalImssResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarResolucionTotalImssResponse);
	if (soap_out_ns2__ConsultarResolucionTotalImssResponse(soap, tag?tag:"ns2:ConsultarResolucionTotalImssResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultarResolucionTotalImssResponse * SOAP_FMAC4 soap_get_ns2__ConsultarResolucionTotalImssResponse(struct soap *soap, struct ns2__ConsultarResolucionTotalImssResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarResolucionTotalImssResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultarResolucionTotalImssResponse * SOAP_FMAC2 soap_instantiate_ns2__ConsultarResolucionTotalImssResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarResolucionTotalImssResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarResolucionTotalImssResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultarResolucionTotalImssResponse);
		if (size)
			*size = sizeof(struct ns2__ConsultarResolucionTotalImssResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultarResolucionTotalImssResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultarResolucionTotalImssResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultarResolucionTotalImssResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarResolucionTotalImssResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultarResolucionTotalImssResponse %p -> %p\n", q, p));
	*(struct ns2__ConsultarResolucionTotalImssResponse*)p = *(struct ns2__ConsultarResolucionTotalImssResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultarComplementoResolucion(struct soap *soap, struct ns2__ConsultarComplementoResolucion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultarComplementoResolucion(struct soap *soap, const struct ns2__ConsultarComplementoResolucion *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroNssTipoRetiro(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarComplementoResolucion(struct soap *soap, const char *tag, int id, const struct ns2__ConsultarComplementoResolucion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarComplementoResolucion), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroNssTipoRetiro(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultarComplementoResolucion * SOAP_FMAC4 soap_in_ns2__ConsultarComplementoResolucion(struct soap *soap, const char *tag, struct ns2__ConsultarComplementoResolucion *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultarComplementoResolucion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarComplementoResolucion, sizeof(struct ns2__ConsultarComplementoResolucion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultarComplementoResolucion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroNssTipoRetiro(soap, "inParam", &a->inParam, "ns2:ParametroNssTipoRetiro"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultarComplementoResolucion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarComplementoResolucion, 0, sizeof(struct ns2__ConsultarComplementoResolucion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultarComplementoResolucion(struct soap *soap, const struct ns2__ConsultarComplementoResolucion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarComplementoResolucion);
	if (soap_out_ns2__ConsultarComplementoResolucion(soap, tag?tag:"ns2:ConsultarComplementoResolucion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultarComplementoResolucion * SOAP_FMAC4 soap_get_ns2__ConsultarComplementoResolucion(struct soap *soap, struct ns2__ConsultarComplementoResolucion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarComplementoResolucion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultarComplementoResolucion * SOAP_FMAC2 soap_instantiate_ns2__ConsultarComplementoResolucion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarComplementoResolucion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarComplementoResolucion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultarComplementoResolucion);
		if (size)
			*size = sizeof(struct ns2__ConsultarComplementoResolucion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultarComplementoResolucion, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultarComplementoResolucion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultarComplementoResolucion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarComplementoResolucion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultarComplementoResolucion %p -> %p\n", q, p));
	*(struct ns2__ConsultarComplementoResolucion*)p = *(struct ns2__ConsultarComplementoResolucion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ConsultarComplementoResolucionResponse(struct soap *soap, struct ns2__ConsultarComplementoResolucionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ConsultarComplementoResolucionResponse(struct soap *soap, const struct ns2__ConsultarComplementoResolucionResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaComplementoResolucion(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ConsultarComplementoResolucionResponse(struct soap *soap, const char *tag, int id, const struct ns2__ConsultarComplementoResolucionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ConsultarComplementoResolucionResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaComplementoResolucion(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ConsultarComplementoResolucionResponse * SOAP_FMAC4 soap_in_ns2__ConsultarComplementoResolucionResponse(struct soap *soap, const char *tag, struct ns2__ConsultarComplementoResolucionResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ConsultarComplementoResolucionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ConsultarComplementoResolucionResponse, sizeof(struct ns2__ConsultarComplementoResolucionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ConsultarComplementoResolucionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaComplementoResolucion(soap, "outParam", &a->outParam, "ns2:RespuestaComplementoResolucion"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ConsultarComplementoResolucionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ConsultarComplementoResolucionResponse, 0, sizeof(struct ns2__ConsultarComplementoResolucionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ConsultarComplementoResolucionResponse(struct soap *soap, const struct ns2__ConsultarComplementoResolucionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ConsultarComplementoResolucionResponse);
	if (soap_out_ns2__ConsultarComplementoResolucionResponse(soap, tag?tag:"ns2:ConsultarComplementoResolucionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ConsultarComplementoResolucionResponse * SOAP_FMAC4 soap_get_ns2__ConsultarComplementoResolucionResponse(struct soap *soap, struct ns2__ConsultarComplementoResolucionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ConsultarComplementoResolucionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ConsultarComplementoResolucionResponse * SOAP_FMAC2 soap_instantiate_ns2__ConsultarComplementoResolucionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ConsultarComplementoResolucionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ConsultarComplementoResolucionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ConsultarComplementoResolucionResponse);
		if (size)
			*size = sizeof(struct ns2__ConsultarComplementoResolucionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ConsultarComplementoResolucionResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__ConsultarComplementoResolucionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ConsultarComplementoResolucionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ConsultarComplementoResolucionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ConsultarComplementoResolucionResponse %p -> %p\n", q, p));
	*(struct ns2__ConsultarComplementoResolucionResponse*)p = *(struct ns2__ConsultarComplementoResolucionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__consultarResolucion(struct soap *soap, struct ns2__consultarResolucion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__consultarResolucion(struct soap *soap, const struct ns2__consultarResolucion *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroNssTipoRetiro(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__consultarResolucion(struct soap *soap, const char *tag, int id, const struct ns2__consultarResolucion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__consultarResolucion), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroNssTipoRetiro(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__consultarResolucion * SOAP_FMAC4 soap_in_ns2__consultarResolucion(struct soap *soap, const char *tag, struct ns2__consultarResolucion *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__consultarResolucion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__consultarResolucion, sizeof(struct ns2__consultarResolucion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__consultarResolucion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroNssTipoRetiro(soap, "inParam", &a->inParam, "ns2:ParametroNssTipoRetiro"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__consultarResolucion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__consultarResolucion, 0, sizeof(struct ns2__consultarResolucion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__consultarResolucion(struct soap *soap, const struct ns2__consultarResolucion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__consultarResolucion);
	if (soap_out_ns2__consultarResolucion(soap, tag?tag:"ns2:consultarResolucion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__consultarResolucion * SOAP_FMAC4 soap_get_ns2__consultarResolucion(struct soap *soap, struct ns2__consultarResolucion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__consultarResolucion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__consultarResolucion * SOAP_FMAC2 soap_instantiate_ns2__consultarResolucion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__consultarResolucion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__consultarResolucion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__consultarResolucion);
		if (size)
			*size = sizeof(struct ns2__consultarResolucion);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__consultarResolucion, n);
		if (size)
			*size = n * sizeof(struct ns2__consultarResolucion);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__consultarResolucion*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__consultarResolucion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__consultarResolucion %p -> %p\n", q, p));
	*(struct ns2__consultarResolucion*)p = *(struct ns2__consultarResolucion*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__consultarResolucionResponse(struct soap *soap, struct ns2__consultarResolucionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__consultarResolucionResponse(struct soap *soap, const struct ns2__consultarResolucionResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaDatosResolucion(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__consultarResolucionResponse(struct soap *soap, const char *tag, int id, const struct ns2__consultarResolucionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__consultarResolucionResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaDatosResolucion(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__consultarResolucionResponse * SOAP_FMAC4 soap_in_ns2__consultarResolucionResponse(struct soap *soap, const char *tag, struct ns2__consultarResolucionResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__consultarResolucionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__consultarResolucionResponse, sizeof(struct ns2__consultarResolucionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__consultarResolucionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaDatosResolucion(soap, "outParam", &a->outParam, "ns2:RespuestaDatosResolucion"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__consultarResolucionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__consultarResolucionResponse, 0, sizeof(struct ns2__consultarResolucionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__consultarResolucionResponse(struct soap *soap, const struct ns2__consultarResolucionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__consultarResolucionResponse);
	if (soap_out_ns2__consultarResolucionResponse(soap, tag?tag:"ns2:consultarResolucionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__consultarResolucionResponse * SOAP_FMAC4 soap_get_ns2__consultarResolucionResponse(struct soap *soap, struct ns2__consultarResolucionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__consultarResolucionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__consultarResolucionResponse * SOAP_FMAC2 soap_instantiate_ns2__consultarResolucionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__consultarResolucionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__consultarResolucionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__consultarResolucionResponse);
		if (size)
			*size = sizeof(struct ns2__consultarResolucionResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__consultarResolucionResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__consultarResolucionResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__consultarResolucionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__consultarResolucionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__consultarResolucionResponse %p -> %p\n", q, p));
	*(struct ns2__consultarResolucionResponse*)p = *(struct ns2__consultarResolucionResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MontosFechasDatamart_(struct soap *soap, struct ns2__MontosFechasDatamart_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MontosFechasDatamart_(struct soap *soap, const struct ns2__MontosFechasDatamart_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroNssTipoRetiro(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MontosFechasDatamart_(struct soap *soap, const char *tag, int id, const struct ns2__MontosFechasDatamart_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MontosFechasDatamart_), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroNssTipoRetiro(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MontosFechasDatamart_ * SOAP_FMAC4 soap_in_ns2__MontosFechasDatamart_(struct soap *soap, const char *tag, struct ns2__MontosFechasDatamart_ *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MontosFechasDatamart_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MontosFechasDatamart_, sizeof(struct ns2__MontosFechasDatamart_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MontosFechasDatamart_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroNssTipoRetiro(soap, "inParam", &a->inParam, "ns2:ParametroNssTipoRetiro"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MontosFechasDatamart_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MontosFechasDatamart_, 0, sizeof(struct ns2__MontosFechasDatamart_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MontosFechasDatamart_(struct soap *soap, const struct ns2__MontosFechasDatamart_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MontosFechasDatamart_);
	if (soap_out_ns2__MontosFechasDatamart_(soap, tag?tag:"ns2:MontosFechasDatamart", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MontosFechasDatamart_ * SOAP_FMAC4 soap_get_ns2__MontosFechasDatamart_(struct soap *soap, struct ns2__MontosFechasDatamart_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MontosFechasDatamart_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__MontosFechasDatamart_ * SOAP_FMAC2 soap_instantiate_ns2__MontosFechasDatamart_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MontosFechasDatamart_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MontosFechasDatamart_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__MontosFechasDatamart_);
		if (size)
			*size = sizeof(struct ns2__MontosFechasDatamart_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__MontosFechasDatamart_, n);
		if (size)
			*size = n * sizeof(struct ns2__MontosFechasDatamart_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__MontosFechasDatamart_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MontosFechasDatamart_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__MontosFechasDatamart_ %p -> %p\n", q, p));
	*(struct ns2__MontosFechasDatamart_*)p = *(struct ns2__MontosFechasDatamart_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__MontosFechasDatamartResponse(struct soap *soap, struct ns2__MontosFechasDatamartResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__MontosFechasDatamartResponse(struct soap *soap, const struct ns2__MontosFechasDatamartResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaMontosFechasDatamart(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__MontosFechasDatamartResponse(struct soap *soap, const char *tag, int id, const struct ns2__MontosFechasDatamartResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__MontosFechasDatamartResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaMontosFechasDatamart(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__MontosFechasDatamartResponse * SOAP_FMAC4 soap_in_ns2__MontosFechasDatamartResponse(struct soap *soap, const char *tag, struct ns2__MontosFechasDatamartResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__MontosFechasDatamartResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__MontosFechasDatamartResponse, sizeof(struct ns2__MontosFechasDatamartResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__MontosFechasDatamartResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaMontosFechasDatamart(soap, "outParam", &a->outParam, "ns2:RespuestaMontosFechasDatamart"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__MontosFechasDatamartResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__MontosFechasDatamartResponse, 0, sizeof(struct ns2__MontosFechasDatamartResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__MontosFechasDatamartResponse(struct soap *soap, const struct ns2__MontosFechasDatamartResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__MontosFechasDatamartResponse);
	if (soap_out_ns2__MontosFechasDatamartResponse(soap, tag?tag:"ns2:MontosFechasDatamartResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__MontosFechasDatamartResponse * SOAP_FMAC4 soap_get_ns2__MontosFechasDatamartResponse(struct soap *soap, struct ns2__MontosFechasDatamartResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__MontosFechasDatamartResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__MontosFechasDatamartResponse * SOAP_FMAC2 soap_instantiate_ns2__MontosFechasDatamartResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__MontosFechasDatamartResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__MontosFechasDatamartResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__MontosFechasDatamartResponse);
		if (size)
			*size = sizeof(struct ns2__MontosFechasDatamartResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__MontosFechasDatamartResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__MontosFechasDatamartResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__MontosFechasDatamartResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__MontosFechasDatamartResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__MontosFechasDatamartResponse %p -> %p\n", q, p));
	*(struct ns2__MontosFechasDatamartResponse*)p = *(struct ns2__MontosFechasDatamartResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ValidarResolucionImss_(struct soap *soap, struct ns2__ValidarResolucionImss_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ValidarResolucionImss_(struct soap *soap, const struct ns2__ValidarResolucionImss_ *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroNssTipoRetiro(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValidarResolucionImss_(struct soap *soap, const char *tag, int id, const struct ns2__ValidarResolucionImss_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValidarResolucionImss_), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroNssTipoRetiro(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ValidarResolucionImss_ * SOAP_FMAC4 soap_in_ns2__ValidarResolucionImss_(struct soap *soap, const char *tag, struct ns2__ValidarResolucionImss_ *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ValidarResolucionImss_ *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValidarResolucionImss_, sizeof(struct ns2__ValidarResolucionImss_), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ValidarResolucionImss_(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroNssTipoRetiro(soap, "inParam", &a->inParam, "ns2:ParametroNssTipoRetiro"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ValidarResolucionImss_ *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValidarResolucionImss_, 0, sizeof(struct ns2__ValidarResolucionImss_), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ValidarResolucionImss_(struct soap *soap, const struct ns2__ValidarResolucionImss_ *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ValidarResolucionImss_);
	if (soap_out_ns2__ValidarResolucionImss_(soap, tag?tag:"ns2:ValidarResolucionImss", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ValidarResolucionImss_ * SOAP_FMAC4 soap_get_ns2__ValidarResolucionImss_(struct soap *soap, struct ns2__ValidarResolucionImss_ *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValidarResolucionImss_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ValidarResolucionImss_ * SOAP_FMAC2 soap_instantiate_ns2__ValidarResolucionImss_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValidarResolucionImss_(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValidarResolucionImss_, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ValidarResolucionImss_);
		if (size)
			*size = sizeof(struct ns2__ValidarResolucionImss_);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ValidarResolucionImss_, n);
		if (size)
			*size = n * sizeof(struct ns2__ValidarResolucionImss_);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ValidarResolucionImss_*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValidarResolucionImss_(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ValidarResolucionImss_ %p -> %p\n", q, p));
	*(struct ns2__ValidarResolucionImss_*)p = *(struct ns2__ValidarResolucionImss_*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ValidarResolucionImssResponse(struct soap *soap, struct ns2__ValidarResolucionImssResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ValidarResolucionImssResponse(struct soap *soap, const struct ns2__ValidarResolucionImssResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaValidarResolucionImss(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValidarResolucionImssResponse(struct soap *soap, const char *tag, int id, const struct ns2__ValidarResolucionImssResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValidarResolucionImssResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaValidarResolucionImss(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ValidarResolucionImssResponse * SOAP_FMAC4 soap_in_ns2__ValidarResolucionImssResponse(struct soap *soap, const char *tag, struct ns2__ValidarResolucionImssResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ValidarResolucionImssResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValidarResolucionImssResponse, sizeof(struct ns2__ValidarResolucionImssResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ValidarResolucionImssResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaValidarResolucionImss(soap, "outParam", &a->outParam, "ns2:RespuestaValidarResolucionImss"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ValidarResolucionImssResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValidarResolucionImssResponse, 0, sizeof(struct ns2__ValidarResolucionImssResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ValidarResolucionImssResponse(struct soap *soap, const struct ns2__ValidarResolucionImssResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ValidarResolucionImssResponse);
	if (soap_out_ns2__ValidarResolucionImssResponse(soap, tag?tag:"ns2:ValidarResolucionImssResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ValidarResolucionImssResponse * SOAP_FMAC4 soap_get_ns2__ValidarResolucionImssResponse(struct soap *soap, struct ns2__ValidarResolucionImssResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValidarResolucionImssResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ValidarResolucionImssResponse * SOAP_FMAC2 soap_instantiate_ns2__ValidarResolucionImssResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValidarResolucionImssResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValidarResolucionImssResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ValidarResolucionImssResponse);
		if (size)
			*size = sizeof(struct ns2__ValidarResolucionImssResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ValidarResolucionImssResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__ValidarResolucionImssResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ValidarResolucionImssResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValidarResolucionImssResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ValidarResolucionImssResponse %p -> %p\n", q, p));
	*(struct ns2__ValidarResolucionImssResponse*)p = *(struct ns2__ValidarResolucionImssResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ObtenerSaldoDiarioRetiroParcial(struct soap *soap, struct ns2__ObtenerSaldoDiarioRetiroParcial *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ObtenerSaldoDiarioRetiroParcial(struct soap *soap, const struct ns2__ObtenerSaldoDiarioRetiroParcial *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ConsultaSaldoDiarioRetiroParcial(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ObtenerSaldoDiarioRetiroParcial(struct soap *soap, const char *tag, int id, const struct ns2__ObtenerSaldoDiarioRetiroParcial *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcial), type))
		return soap->error;
	if (soap_out_PointerTons2__ConsultaSaldoDiarioRetiroParcial(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ObtenerSaldoDiarioRetiroParcial * SOAP_FMAC4 soap_in_ns2__ObtenerSaldoDiarioRetiroParcial(struct soap *soap, const char *tag, struct ns2__ObtenerSaldoDiarioRetiroParcial *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ObtenerSaldoDiarioRetiroParcial *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcial, sizeof(struct ns2__ObtenerSaldoDiarioRetiroParcial), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ObtenerSaldoDiarioRetiroParcial(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ConsultaSaldoDiarioRetiroParcial(soap, "inParam", &a->inParam, "ns2:ConsultaSaldoDiarioRetiroParcial"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ObtenerSaldoDiarioRetiroParcial *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcial, 0, sizeof(struct ns2__ObtenerSaldoDiarioRetiroParcial), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ObtenerSaldoDiarioRetiroParcial(struct soap *soap, const struct ns2__ObtenerSaldoDiarioRetiroParcial *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcial);
	if (soap_out_ns2__ObtenerSaldoDiarioRetiroParcial(soap, tag?tag:"ns2:ObtenerSaldoDiarioRetiroParcial", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ObtenerSaldoDiarioRetiroParcial * SOAP_FMAC4 soap_get_ns2__ObtenerSaldoDiarioRetiroParcial(struct soap *soap, struct ns2__ObtenerSaldoDiarioRetiroParcial *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ObtenerSaldoDiarioRetiroParcial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ObtenerSaldoDiarioRetiroParcial * SOAP_FMAC2 soap_instantiate_ns2__ObtenerSaldoDiarioRetiroParcial(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ObtenerSaldoDiarioRetiroParcial(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcial, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ObtenerSaldoDiarioRetiroParcial);
		if (size)
			*size = sizeof(struct ns2__ObtenerSaldoDiarioRetiroParcial);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ObtenerSaldoDiarioRetiroParcial, n);
		if (size)
			*size = n * sizeof(struct ns2__ObtenerSaldoDiarioRetiroParcial);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ObtenerSaldoDiarioRetiroParcial*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ObtenerSaldoDiarioRetiroParcial(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ObtenerSaldoDiarioRetiroParcial %p -> %p\n", q, p));
	*(struct ns2__ObtenerSaldoDiarioRetiroParcial*)p = *(struct ns2__ObtenerSaldoDiarioRetiroParcial*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ObtenerSaldoDiarioRetiroParcialResponse(struct soap *soap, struct ns2__ObtenerSaldoDiarioRetiroParcialResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ObtenerSaldoDiarioRetiroParcialResponse(struct soap *soap, const struct ns2__ObtenerSaldoDiarioRetiroParcialResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SaldoDiarioRetiroParcial(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ObtenerSaldoDiarioRetiroParcialResponse(struct soap *soap, const char *tag, int id, const struct ns2__ObtenerSaldoDiarioRetiroParcialResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcialResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__SaldoDiarioRetiroParcial(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ObtenerSaldoDiarioRetiroParcialResponse * SOAP_FMAC4 soap_in_ns2__ObtenerSaldoDiarioRetiroParcialResponse(struct soap *soap, const char *tag, struct ns2__ObtenerSaldoDiarioRetiroParcialResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ObtenerSaldoDiarioRetiroParcialResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcialResponse, sizeof(struct ns2__ObtenerSaldoDiarioRetiroParcialResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ObtenerSaldoDiarioRetiroParcialResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SaldoDiarioRetiroParcial(soap, "outParam", &a->outParam, "ns2:SaldoDiarioRetiroParcial"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ObtenerSaldoDiarioRetiroParcialResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcialResponse, 0, sizeof(struct ns2__ObtenerSaldoDiarioRetiroParcialResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ObtenerSaldoDiarioRetiroParcialResponse(struct soap *soap, const struct ns2__ObtenerSaldoDiarioRetiroParcialResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcialResponse);
	if (soap_out_ns2__ObtenerSaldoDiarioRetiroParcialResponse(soap, tag?tag:"ns2:ObtenerSaldoDiarioRetiroParcialResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ObtenerSaldoDiarioRetiroParcialResponse * SOAP_FMAC4 soap_get_ns2__ObtenerSaldoDiarioRetiroParcialResponse(struct soap *soap, struct ns2__ObtenerSaldoDiarioRetiroParcialResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ObtenerSaldoDiarioRetiroParcialResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ObtenerSaldoDiarioRetiroParcialResponse * SOAP_FMAC2 soap_instantiate_ns2__ObtenerSaldoDiarioRetiroParcialResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ObtenerSaldoDiarioRetiroParcialResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ObtenerSaldoDiarioRetiroParcialResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ObtenerSaldoDiarioRetiroParcialResponse);
		if (size)
			*size = sizeof(struct ns2__ObtenerSaldoDiarioRetiroParcialResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ObtenerSaldoDiarioRetiroParcialResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__ObtenerSaldoDiarioRetiroParcialResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ObtenerSaldoDiarioRetiroParcialResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ObtenerSaldoDiarioRetiroParcialResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ObtenerSaldoDiarioRetiroParcialResponse %p -> %p\n", q, p));
	*(struct ns2__ObtenerSaldoDiarioRetiroParcialResponse*)p = *(struct ns2__ObtenerSaldoDiarioRetiroParcialResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ValidarConvivenciaMarcaOperativa(struct soap *soap, struct ns2__ValidarConvivenciaMarcaOperativa *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ValidarConvivenciaMarcaOperativa(struct soap *soap, const struct ns2__ValidarConvivenciaMarcaOperativa *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ConvivenciaMarcas(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValidarConvivenciaMarcaOperativa(struct soap *soap, const char *tag, int id, const struct ns2__ValidarConvivenciaMarcaOperativa *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativa), type))
		return soap->error;
	if (soap_out_PointerTons2__ConvivenciaMarcas(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ValidarConvivenciaMarcaOperativa * SOAP_FMAC4 soap_in_ns2__ValidarConvivenciaMarcaOperativa(struct soap *soap, const char *tag, struct ns2__ValidarConvivenciaMarcaOperativa *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ValidarConvivenciaMarcaOperativa *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativa, sizeof(struct ns2__ValidarConvivenciaMarcaOperativa), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ValidarConvivenciaMarcaOperativa(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ConvivenciaMarcas(soap, "inParam", &a->inParam, "ns2:ConvivenciaMarcas"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ValidarConvivenciaMarcaOperativa *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativa, 0, sizeof(struct ns2__ValidarConvivenciaMarcaOperativa), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ValidarConvivenciaMarcaOperativa(struct soap *soap, const struct ns2__ValidarConvivenciaMarcaOperativa *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativa);
	if (soap_out_ns2__ValidarConvivenciaMarcaOperativa(soap, tag?tag:"ns2:ValidarConvivenciaMarcaOperativa", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ValidarConvivenciaMarcaOperativa * SOAP_FMAC4 soap_get_ns2__ValidarConvivenciaMarcaOperativa(struct soap *soap, struct ns2__ValidarConvivenciaMarcaOperativa *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValidarConvivenciaMarcaOperativa(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ValidarConvivenciaMarcaOperativa * SOAP_FMAC2 soap_instantiate_ns2__ValidarConvivenciaMarcaOperativa(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValidarConvivenciaMarcaOperativa(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativa, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ValidarConvivenciaMarcaOperativa);
		if (size)
			*size = sizeof(struct ns2__ValidarConvivenciaMarcaOperativa);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ValidarConvivenciaMarcaOperativa, n);
		if (size)
			*size = n * sizeof(struct ns2__ValidarConvivenciaMarcaOperativa);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ValidarConvivenciaMarcaOperativa*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValidarConvivenciaMarcaOperativa(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ValidarConvivenciaMarcaOperativa %p -> %p\n", q, p));
	*(struct ns2__ValidarConvivenciaMarcaOperativa*)p = *(struct ns2__ValidarConvivenciaMarcaOperativa*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ValidarConvivenciaMarcaOperativaResponse(struct soap *soap, struct ns2__ValidarConvivenciaMarcaOperativaResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ValidarConvivenciaMarcaOperativaResponse(struct soap *soap, const struct ns2__ValidarConvivenciaMarcaOperativaResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespuestaConvivenciaMarca(soap, &a->outParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ValidarConvivenciaMarcaOperativaResponse(struct soap *soap, const char *tag, int id, const struct ns2__ValidarConvivenciaMarcaOperativaResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativaResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespuestaConvivenciaMarca(soap, "outParam", -1, &a->outParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ValidarConvivenciaMarcaOperativaResponse * SOAP_FMAC4 soap_in_ns2__ValidarConvivenciaMarcaOperativaResponse(struct soap *soap, const char *tag, struct ns2__ValidarConvivenciaMarcaOperativaResponse *a, const char *type)
{
	size_t soap_flag_outParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ValidarConvivenciaMarcaOperativaResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativaResponse, sizeof(struct ns2__ValidarConvivenciaMarcaOperativaResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ValidarConvivenciaMarcaOperativaResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespuestaConvivenciaMarca(soap, "outParam", &a->outParam, "ns2:RespuestaConvivenciaMarca"))
				{	soap_flag_outParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ValidarConvivenciaMarcaOperativaResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativaResponse, 0, sizeof(struct ns2__ValidarConvivenciaMarcaOperativaResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ValidarConvivenciaMarcaOperativaResponse(struct soap *soap, const struct ns2__ValidarConvivenciaMarcaOperativaResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativaResponse);
	if (soap_out_ns2__ValidarConvivenciaMarcaOperativaResponse(soap, tag?tag:"ns2:ValidarConvivenciaMarcaOperativaResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ValidarConvivenciaMarcaOperativaResponse * SOAP_FMAC4 soap_get_ns2__ValidarConvivenciaMarcaOperativaResponse(struct soap *soap, struct ns2__ValidarConvivenciaMarcaOperativaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ValidarConvivenciaMarcaOperativaResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ValidarConvivenciaMarcaOperativaResponse * SOAP_FMAC2 soap_instantiate_ns2__ValidarConvivenciaMarcaOperativaResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ValidarConvivenciaMarcaOperativaResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ValidarConvivenciaMarcaOperativaResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ValidarConvivenciaMarcaOperativaResponse);
		if (size)
			*size = sizeof(struct ns2__ValidarConvivenciaMarcaOperativaResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ValidarConvivenciaMarcaOperativaResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__ValidarConvivenciaMarcaOperativaResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ValidarConvivenciaMarcaOperativaResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ValidarConvivenciaMarcaOperativaResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ValidarConvivenciaMarcaOperativaResponse %p -> %p\n", q, p));
	*(struct ns2__ValidarConvivenciaMarcaOperativaResponse*)p = *(struct ns2__ValidarConvivenciaMarcaOperativaResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ObtenerFolioServicio(struct soap *soap, struct ns2__ObtenerFolioServicio *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inFoliador = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ObtenerFolioServicio(struct soap *soap, const struct ns2__ObtenerFolioServicio *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__FoliadorServicio(soap, &a->inFoliador);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ObtenerFolioServicio(struct soap *soap, const char *tag, int id, const struct ns2__ObtenerFolioServicio *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ObtenerFolioServicio), type))
		return soap->error;
	if (soap_out_PointerTons2__FoliadorServicio(soap, "inFoliador", -1, &a->inFoliador, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ObtenerFolioServicio * SOAP_FMAC4 soap_in_ns2__ObtenerFolioServicio(struct soap *soap, const char *tag, struct ns2__ObtenerFolioServicio *a, const char *type)
{
	size_t soap_flag_inFoliador = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ObtenerFolioServicio *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ObtenerFolioServicio, sizeof(struct ns2__ObtenerFolioServicio), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ObtenerFolioServicio(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inFoliador && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FoliadorServicio(soap, "inFoliador", &a->inFoliador, "ns2:FoliadorServicio"))
				{	soap_flag_inFoliador--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ObtenerFolioServicio *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ObtenerFolioServicio, 0, sizeof(struct ns2__ObtenerFolioServicio), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ObtenerFolioServicio(struct soap *soap, const struct ns2__ObtenerFolioServicio *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ObtenerFolioServicio);
	if (soap_out_ns2__ObtenerFolioServicio(soap, tag?tag:"ns2:ObtenerFolioServicio", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ObtenerFolioServicio * SOAP_FMAC4 soap_get_ns2__ObtenerFolioServicio(struct soap *soap, struct ns2__ObtenerFolioServicio *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ObtenerFolioServicio(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ObtenerFolioServicio * SOAP_FMAC2 soap_instantiate_ns2__ObtenerFolioServicio(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ObtenerFolioServicio(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ObtenerFolioServicio, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ObtenerFolioServicio);
		if (size)
			*size = sizeof(struct ns2__ObtenerFolioServicio);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ObtenerFolioServicio, n);
		if (size)
			*size = n * sizeof(struct ns2__ObtenerFolioServicio);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ObtenerFolioServicio*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ObtenerFolioServicio(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ObtenerFolioServicio %p -> %p\n", q, p));
	*(struct ns2__ObtenerFolioServicio*)p = *(struct ns2__ObtenerFolioServicio*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__ObtenerFolioServicioResponse(struct soap *soap, struct ns2__ObtenerFolioServicioResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outFolioServ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__ObtenerFolioServicioResponse(struct soap *soap, const struct ns2__ObtenerFolioServicioResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__FolioServicio(soap, &a->outFolioServ);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__ObtenerFolioServicioResponse(struct soap *soap, const char *tag, int id, const struct ns2__ObtenerFolioServicioResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__ObtenerFolioServicioResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__FolioServicio(soap, "outFolioServ", -1, &a->outFolioServ, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__ObtenerFolioServicioResponse * SOAP_FMAC4 soap_in_ns2__ObtenerFolioServicioResponse(struct soap *soap, const char *tag, struct ns2__ObtenerFolioServicioResponse *a, const char *type)
{
	size_t soap_flag_outFolioServ = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__ObtenerFolioServicioResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__ObtenerFolioServicioResponse, sizeof(struct ns2__ObtenerFolioServicioResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__ObtenerFolioServicioResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outFolioServ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__FolioServicio(soap, "outFolioServ", &a->outFolioServ, "ns2:FolioServicio"))
				{	soap_flag_outFolioServ--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__ObtenerFolioServicioResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__ObtenerFolioServicioResponse, 0, sizeof(struct ns2__ObtenerFolioServicioResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__ObtenerFolioServicioResponse(struct soap *soap, const struct ns2__ObtenerFolioServicioResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__ObtenerFolioServicioResponse);
	if (soap_out_ns2__ObtenerFolioServicioResponse(soap, tag?tag:"ns2:ObtenerFolioServicioResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__ObtenerFolioServicioResponse * SOAP_FMAC4 soap_get_ns2__ObtenerFolioServicioResponse(struct soap *soap, struct ns2__ObtenerFolioServicioResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__ObtenerFolioServicioResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__ObtenerFolioServicioResponse * SOAP_FMAC2 soap_instantiate_ns2__ObtenerFolioServicioResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__ObtenerFolioServicioResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__ObtenerFolioServicioResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__ObtenerFolioServicioResponse);
		if (size)
			*size = sizeof(struct ns2__ObtenerFolioServicioResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__ObtenerFolioServicioResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__ObtenerFolioServicioResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__ObtenerFolioServicioResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__ObtenerFolioServicioResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__ObtenerFolioServicioResponse %p -> %p\n", q, p));
	*(struct ns2__ObtenerFolioServicioResponse*)p = *(struct ns2__ObtenerFolioServicioResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__consultarSaldos(struct soap *soap, struct ns2__consultarSaldos *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->inParam = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__consultarSaldos(struct soap *soap, const struct ns2__consultarSaldos *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParametroNss(soap, &a->inParam);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__consultarSaldos(struct soap *soap, const char *tag, int id, const struct ns2__consultarSaldos *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__consultarSaldos), type))
		return soap->error;
	if (soap_out_PointerTons2__ParametroNss(soap, "inParam", -1, &a->inParam, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__consultarSaldos * SOAP_FMAC4 soap_in_ns2__consultarSaldos(struct soap *soap, const char *tag, struct ns2__consultarSaldos *a, const char *type)
{
	size_t soap_flag_inParam = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__consultarSaldos *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__consultarSaldos, sizeof(struct ns2__consultarSaldos), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__consultarSaldos(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_inParam && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParametroNss(soap, "inParam", &a->inParam, "ns2:ParametroNss"))
				{	soap_flag_inParam--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__consultarSaldos *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__consultarSaldos, 0, sizeof(struct ns2__consultarSaldos), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__consultarSaldos(struct soap *soap, const struct ns2__consultarSaldos *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__consultarSaldos);
	if (soap_out_ns2__consultarSaldos(soap, tag?tag:"ns2:consultarSaldos", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__consultarSaldos * SOAP_FMAC4 soap_get_ns2__consultarSaldos(struct soap *soap, struct ns2__consultarSaldos *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__consultarSaldos(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__consultarSaldos * SOAP_FMAC2 soap_instantiate_ns2__consultarSaldos(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__consultarSaldos(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__consultarSaldos, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__consultarSaldos);
		if (size)
			*size = sizeof(struct ns2__consultarSaldos);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__consultarSaldos, n);
		if (size)
			*size = n * sizeof(struct ns2__consultarSaldos);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__consultarSaldos*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__consultarSaldos(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__consultarSaldos %p -> %p\n", q, p));
	*(struct ns2__consultarSaldos*)p = *(struct ns2__consultarSaldos*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__consultarSaldosResponse(struct soap *soap, struct ns2__consultarSaldosResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->outSaldos = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__consultarSaldosResponse(struct soap *soap, const struct ns2__consultarSaldosResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__SaldoPorSubcuenta(soap, &a->outSaldos);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__consultarSaldosResponse(struct soap *soap, const char *tag, int id, const struct ns2__consultarSaldosResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__consultarSaldosResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__SaldoPorSubcuenta(soap, "outSaldos", -1, &a->outSaldos, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__consultarSaldosResponse * SOAP_FMAC4 soap_in_ns2__consultarSaldosResponse(struct soap *soap, const char *tag, struct ns2__consultarSaldosResponse *a, const char *type)
{
	size_t soap_flag_outSaldos = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__consultarSaldosResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__consultarSaldosResponse, sizeof(struct ns2__consultarSaldosResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__consultarSaldosResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_outSaldos && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__SaldoPorSubcuenta(soap, "outSaldos", &a->outSaldos, "ns2:SaldoPorSubcuenta"))
				{	soap_flag_outSaldos--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__consultarSaldosResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__consultarSaldosResponse, 0, sizeof(struct ns2__consultarSaldosResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__consultarSaldosResponse(struct soap *soap, const struct ns2__consultarSaldosResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__consultarSaldosResponse);
	if (soap_out_ns2__consultarSaldosResponse(soap, tag?tag:"ns2:consultarSaldosResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__consultarSaldosResponse * SOAP_FMAC4 soap_get_ns2__consultarSaldosResponse(struct soap *soap, struct ns2__consultarSaldosResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__consultarSaldosResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__consultarSaldosResponse * SOAP_FMAC2 soap_instantiate_ns2__consultarSaldosResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__consultarSaldosResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__consultarSaldosResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__consultarSaldosResponse);
		if (size)
			*size = sizeof(struct ns2__consultarSaldosResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__consultarSaldosResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__consultarSaldosResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__consultarSaldosResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__consultarSaldosResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__consultarSaldosResponse %p -> %p\n", q, p));
	*(struct ns2__consultarSaldosResponse*)p = *(struct ns2__consultarSaldosResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__consultarAfiliado(struct soap *soap, struct ns2__consultarAfiliado *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->in = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__consultarAfiliado(struct soap *soap, const struct ns2__consultarAfiliado *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__ParamConsultarAfiliado(soap, &a->in);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__consultarAfiliado(struct soap *soap, const char *tag, int id, const struct ns2__consultarAfiliado *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__consultarAfiliado), type))
		return soap->error;
	if (soap_out_PointerTons2__ParamConsultarAfiliado(soap, "in", -1, &a->in, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__consultarAfiliado * SOAP_FMAC4 soap_in_ns2__consultarAfiliado(struct soap *soap, const char *tag, struct ns2__consultarAfiliado *a, const char *type)
{
	size_t soap_flag_in = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__consultarAfiliado *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__consultarAfiliado, sizeof(struct ns2__consultarAfiliado), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__consultarAfiliado(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__ParamConsultarAfiliado(soap, "in", &a->in, "ns2:ParamConsultarAfiliado"))
				{	soap_flag_in--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__consultarAfiliado *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__consultarAfiliado, 0, sizeof(struct ns2__consultarAfiliado), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__consultarAfiliado(struct soap *soap, const struct ns2__consultarAfiliado *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__consultarAfiliado);
	if (soap_out_ns2__consultarAfiliado(soap, tag?tag:"ns2:consultarAfiliado", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__consultarAfiliado * SOAP_FMAC4 soap_get_ns2__consultarAfiliado(struct soap *soap, struct ns2__consultarAfiliado *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__consultarAfiliado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__consultarAfiliado * SOAP_FMAC2 soap_instantiate_ns2__consultarAfiliado(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__consultarAfiliado(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__consultarAfiliado, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__consultarAfiliado);
		if (size)
			*size = sizeof(struct ns2__consultarAfiliado);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__consultarAfiliado, n);
		if (size)
			*size = n * sizeof(struct ns2__consultarAfiliado);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__consultarAfiliado*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__consultarAfiliado(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__consultarAfiliado %p -> %p\n", q, p));
	*(struct ns2__consultarAfiliado*)p = *(struct ns2__consultarAfiliado*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns2__consultarAfiliadoResponse(struct soap *soap, struct ns2__consultarAfiliadoResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->out = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns2__consultarAfiliadoResponse(struct soap *soap, const struct ns2__consultarAfiliadoResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons2__RespConsultarAfiliado(soap, &a->out);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns2__consultarAfiliadoResponse(struct soap *soap, const char *tag, int id, const struct ns2__consultarAfiliadoResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns2__consultarAfiliadoResponse), type))
		return soap->error;
	if (soap_out_PointerTons2__RespConsultarAfiliado(soap, "out", -1, &a->out, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns2__consultarAfiliadoResponse * SOAP_FMAC4 soap_in_ns2__consultarAfiliadoResponse(struct soap *soap, const char *tag, struct ns2__consultarAfiliadoResponse *a, const char *type)
{
	size_t soap_flag_out = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns2__consultarAfiliadoResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns2__consultarAfiliadoResponse, sizeof(struct ns2__consultarAfiliadoResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns2__consultarAfiliadoResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_out && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons2__RespConsultarAfiliado(soap, "out", &a->out, "ns2:RespConsultarAfiliado"))
				{	soap_flag_out--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns2__consultarAfiliadoResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns2__consultarAfiliadoResponse, 0, sizeof(struct ns2__consultarAfiliadoResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns2__consultarAfiliadoResponse(struct soap *soap, const struct ns2__consultarAfiliadoResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns2__consultarAfiliadoResponse);
	if (soap_out_ns2__consultarAfiliadoResponse(soap, tag?tag:"ns2:consultarAfiliadoResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns2__consultarAfiliadoResponse * SOAP_FMAC4 soap_get_ns2__consultarAfiliadoResponse(struct soap *soap, struct ns2__consultarAfiliadoResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns2__consultarAfiliadoResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ns2__consultarAfiliadoResponse * SOAP_FMAC2 soap_instantiate_ns2__consultarAfiliadoResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns2__consultarAfiliadoResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns2__consultarAfiliadoResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ns2__consultarAfiliadoResponse);
		if (size)
			*size = sizeof(struct ns2__consultarAfiliadoResponse);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ns2__consultarAfiliadoResponse, n);
		if (size)
			*size = n * sizeof(struct ns2__consultarAfiliadoResponse);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ns2__consultarAfiliadoResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns2__consultarAfiliadoResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ns2__consultarAfiliadoResponse %p -> %p\n", q, p));
	*(struct ns2__consultarAfiliadoResponse*)p = *(struct ns2__consultarAfiliadoResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaMensualidad(struct soap *soap, ns2__RespuestaMensualidad *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaMensualidad))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaMensualidad(struct soap *soap, const char *tag, int id, ns2__RespuestaMensualidad *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaMensualidad);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaMensualidad ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaMensualidad(struct soap *soap, const char *tag, ns2__RespuestaMensualidad **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaMensualidad **)soap_malloc(soap, sizeof(ns2__RespuestaMensualidad *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaMensualidad *)soap_instantiate_ns2__RespuestaMensualidad(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaMensualidad ** p = (ns2__RespuestaMensualidad **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaMensualidad, sizeof(ns2__RespuestaMensualidad), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaMensualidad(struct soap *soap, ns2__RespuestaMensualidad *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaMensualidad);
	if (soap_out_PointerTons2__RespuestaMensualidad(soap, tag?tag:"ns2:RespuestaMensualidad", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaMensualidad ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaMensualidad(struct soap *soap, ns2__RespuestaMensualidad **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaMensualidad(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaFechaLiquida(struct soap *soap, ns2__RespuestaFechaLiquida *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaFechaLiquida))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaFechaLiquida(struct soap *soap, const char *tag, int id, ns2__RespuestaFechaLiquida *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaFechaLiquida);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaFechaLiquida ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaFechaLiquida(struct soap *soap, const char *tag, ns2__RespuestaFechaLiquida **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaFechaLiquida **)soap_malloc(soap, sizeof(ns2__RespuestaFechaLiquida *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaFechaLiquida *)soap_instantiate_ns2__RespuestaFechaLiquida(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaFechaLiquida ** p = (ns2__RespuestaFechaLiquida **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaFechaLiquida, sizeof(ns2__RespuestaFechaLiquida), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaFechaLiquida(struct soap *soap, ns2__RespuestaFechaLiquida *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaFechaLiquida);
	if (soap_out_PointerTons2__RespuestaFechaLiquida(soap, tag?tag:"ns2:RespuestaFechaLiquida", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaFechaLiquida ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaFechaLiquida(struct soap *soap, ns2__RespuestaFechaLiquida **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaFechaLiquida(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaSaldoRecuperar(struct soap *soap, ns2__RespuestaSaldoRecuperar *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaSaldoRecuperar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaSaldoRecuperar(struct soap *soap, const char *tag, int id, ns2__RespuestaSaldoRecuperar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaSaldoRecuperar);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaSaldoRecuperar ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaSaldoRecuperar(struct soap *soap, const char *tag, ns2__RespuestaSaldoRecuperar **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaSaldoRecuperar **)soap_malloc(soap, sizeof(ns2__RespuestaSaldoRecuperar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaSaldoRecuperar *)soap_instantiate_ns2__RespuestaSaldoRecuperar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaSaldoRecuperar ** p = (ns2__RespuestaSaldoRecuperar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaSaldoRecuperar, sizeof(ns2__RespuestaSaldoRecuperar), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaSaldoRecuperar(struct soap *soap, ns2__RespuestaSaldoRecuperar *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaSaldoRecuperar);
	if (soap_out_PointerTons2__RespuestaSaldoRecuperar(soap, tag?tag:"ns2:RespuestaSaldoRecuperar", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaSaldoRecuperar ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaSaldoRecuperar(struct soap *soap, ns2__RespuestaSaldoRecuperar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaSaldoRecuperar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParametroCurpNss(struct soap *soap, ns2__ParametroCurpNss *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParametroCurpNss))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParametroCurpNss(struct soap *soap, const char *tag, int id, ns2__ParametroCurpNss *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParametroCurpNss);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParametroCurpNss ** SOAP_FMAC4 soap_in_PointerTons2__ParametroCurpNss(struct soap *soap, const char *tag, ns2__ParametroCurpNss **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParametroCurpNss **)soap_malloc(soap, sizeof(ns2__ParametroCurpNss *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParametroCurpNss *)soap_instantiate_ns2__ParametroCurpNss(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParametroCurpNss ** p = (ns2__ParametroCurpNss **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParametroCurpNss, sizeof(ns2__ParametroCurpNss), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParametroCurpNss(struct soap *soap, ns2__ParametroCurpNss *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParametroCurpNss);
	if (soap_out_PointerTons2__ParametroCurpNss(soap, tag?tag:"ns2:ParametroCurpNss", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParametroCurpNss ** SOAP_FMAC4 soap_get_PointerTons2__ParametroCurpNss(struct soap *soap, ns2__ParametroCurpNss **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParametroCurpNss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaTipoSolicitante(struct soap *soap, ns2__RespuestaTipoSolicitante *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaTipoSolicitante))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaTipoSolicitante(struct soap *soap, const char *tag, int id, ns2__RespuestaTipoSolicitante *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaTipoSolicitante);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaTipoSolicitante ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaTipoSolicitante(struct soap *soap, const char *tag, ns2__RespuestaTipoSolicitante **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaTipoSolicitante **)soap_malloc(soap, sizeof(ns2__RespuestaTipoSolicitante *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaTipoSolicitante *)soap_instantiate_ns2__RespuestaTipoSolicitante(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaTipoSolicitante ** p = (ns2__RespuestaTipoSolicitante **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaTipoSolicitante, sizeof(ns2__RespuestaTipoSolicitante), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaTipoSolicitante(struct soap *soap, ns2__RespuestaTipoSolicitante *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaTipoSolicitante);
	if (soap_out_PointerTons2__RespuestaTipoSolicitante(soap, tag?tag:"ns2:RespuestaTipoSolicitante", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaTipoSolicitante ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaTipoSolicitante(struct soap *soap, ns2__RespuestaTipoSolicitante **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaTipoSolicitante(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParametroAportacionesPost(struct soap *soap, ns2__ParametroAportacionesPost *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParametroAportacionesPost))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParametroAportacionesPost(struct soap *soap, const char *tag, int id, ns2__ParametroAportacionesPost *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParametroAportacionesPost);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParametroAportacionesPost ** SOAP_FMAC4 soap_in_PointerTons2__ParametroAportacionesPost(struct soap *soap, const char *tag, ns2__ParametroAportacionesPost **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParametroAportacionesPost **)soap_malloc(soap, sizeof(ns2__ParametroAportacionesPost *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParametroAportacionesPost *)soap_instantiate_ns2__ParametroAportacionesPost(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParametroAportacionesPost ** p = (ns2__ParametroAportacionesPost **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParametroAportacionesPost, sizeof(ns2__ParametroAportacionesPost), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParametroAportacionesPost(struct soap *soap, ns2__ParametroAportacionesPost *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParametroAportacionesPost);
	if (soap_out_PointerTons2__ParametroAportacionesPost(soap, tag?tag:"ns2:ParametroAportacionesPost", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParametroAportacionesPost ** SOAP_FMAC4 soap_get_PointerTons2__ParametroAportacionesPost(struct soap *soap, ns2__ParametroAportacionesPost **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParametroAportacionesPost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParamConsultaSaldoVivienda(struct soap *soap, ns2__ParamConsultaSaldoVivienda *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParamConsultaSaldoVivienda))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParamConsultaSaldoVivienda(struct soap *soap, const char *tag, int id, ns2__ParamConsultaSaldoVivienda *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParamConsultaSaldoVivienda);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParamConsultaSaldoVivienda ** SOAP_FMAC4 soap_in_PointerTons2__ParamConsultaSaldoVivienda(struct soap *soap, const char *tag, ns2__ParamConsultaSaldoVivienda **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParamConsultaSaldoVivienda **)soap_malloc(soap, sizeof(ns2__ParamConsultaSaldoVivienda *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParamConsultaSaldoVivienda *)soap_instantiate_ns2__ParamConsultaSaldoVivienda(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParamConsultaSaldoVivienda ** p = (ns2__ParamConsultaSaldoVivienda **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParamConsultaSaldoVivienda, sizeof(ns2__ParamConsultaSaldoVivienda), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParamConsultaSaldoVivienda(struct soap *soap, ns2__ParamConsultaSaldoVivienda *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParamConsultaSaldoVivienda);
	if (soap_out_PointerTons2__ParamConsultaSaldoVivienda(soap, tag?tag:"ns2:ParamConsultaSaldoVivienda", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParamConsultaSaldoVivienda ** SOAP_FMAC4 soap_get_PointerTons2__ParamConsultaSaldoVivienda(struct soap *soap, ns2__ParamConsultaSaldoVivienda **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParamConsultaSaldoVivienda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaConsultaSaldoVivienda(struct soap *soap, ns2__RespuestaConsultaSaldoVivienda *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaConsultaSaldoVivienda(struct soap *soap, const char *tag, int id, ns2__RespuestaConsultaSaldoVivienda *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaConsultaSaldoVivienda ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaConsultaSaldoVivienda(struct soap *soap, const char *tag, ns2__RespuestaConsultaSaldoVivienda **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaConsultaSaldoVivienda **)soap_malloc(soap, sizeof(ns2__RespuestaConsultaSaldoVivienda *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaConsultaSaldoVivienda *)soap_instantiate_ns2__RespuestaConsultaSaldoVivienda(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaConsultaSaldoVivienda ** p = (ns2__RespuestaConsultaSaldoVivienda **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaConsultaSaldoVivienda, sizeof(ns2__RespuestaConsultaSaldoVivienda), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaConsultaSaldoVivienda(struct soap *soap, ns2__RespuestaConsultaSaldoVivienda *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaConsultaSaldoVivienda);
	if (soap_out_PointerTons2__RespuestaConsultaSaldoVivienda(soap, tag?tag:"ns2:RespuestaConsultaSaldoVivienda", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaConsultaSaldoVivienda ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaConsultaSaldoVivienda(struct soap *soap, ns2__RespuestaConsultaSaldoVivienda **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaConsultaSaldoVivienda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaCtaSaldoVol(struct soap *soap, ns2__RespuestaCtaSaldoVol *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaCtaSaldoVol))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaCtaSaldoVol(struct soap *soap, const char *tag, int id, ns2__RespuestaCtaSaldoVol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaCtaSaldoVol);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaCtaSaldoVol ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaCtaSaldoVol(struct soap *soap, const char *tag, ns2__RespuestaCtaSaldoVol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaCtaSaldoVol **)soap_malloc(soap, sizeof(ns2__RespuestaCtaSaldoVol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaCtaSaldoVol *)soap_instantiate_ns2__RespuestaCtaSaldoVol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaCtaSaldoVol ** p = (ns2__RespuestaCtaSaldoVol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaCtaSaldoVol, sizeof(ns2__RespuestaCtaSaldoVol), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaCtaSaldoVol(struct soap *soap, ns2__RespuestaCtaSaldoVol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaCtaSaldoVol);
	if (soap_out_PointerTons2__RespuestaCtaSaldoVol(soap, tag?tag:"ns2:RespuestaCtaSaldoVol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaCtaSaldoVol ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaCtaSaldoVol(struct soap *soap, ns2__RespuestaCtaSaldoVol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaCtaSaldoVol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParamNssCtaRegimen(struct soap *soap, ns2__ParamNssCtaRegimen *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParamNssCtaRegimen))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParamNssCtaRegimen(struct soap *soap, const char *tag, int id, ns2__ParamNssCtaRegimen *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParamNssCtaRegimen);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParamNssCtaRegimen ** SOAP_FMAC4 soap_in_PointerTons2__ParamNssCtaRegimen(struct soap *soap, const char *tag, ns2__ParamNssCtaRegimen **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParamNssCtaRegimen **)soap_malloc(soap, sizeof(ns2__ParamNssCtaRegimen *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParamNssCtaRegimen *)soap_instantiate_ns2__ParamNssCtaRegimen(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParamNssCtaRegimen ** p = (ns2__ParamNssCtaRegimen **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParamNssCtaRegimen, sizeof(ns2__ParamNssCtaRegimen), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParamNssCtaRegimen(struct soap *soap, ns2__ParamNssCtaRegimen *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParamNssCtaRegimen);
	if (soap_out_PointerTons2__ParamNssCtaRegimen(soap, tag?tag:"ns2:ParamNssCtaRegimen", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParamNssCtaRegimen ** SOAP_FMAC4 soap_get_PointerTons2__ParamNssCtaRegimen(struct soap *soap, ns2__ParamNssCtaRegimen **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParamNssCtaRegimen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaSieforeCtaRegimen(struct soap *soap, ns2__RespuestaSieforeCtaRegimen *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaSieforeCtaRegimen(struct soap *soap, const char *tag, int id, ns2__RespuestaSieforeCtaRegimen *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaSieforeCtaRegimen ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaSieforeCtaRegimen(struct soap *soap, const char *tag, ns2__RespuestaSieforeCtaRegimen **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaSieforeCtaRegimen **)soap_malloc(soap, sizeof(ns2__RespuestaSieforeCtaRegimen *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaSieforeCtaRegimen *)soap_instantiate_ns2__RespuestaSieforeCtaRegimen(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaSieforeCtaRegimen ** p = (ns2__RespuestaSieforeCtaRegimen **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaSieforeCtaRegimen, sizeof(ns2__RespuestaSieforeCtaRegimen), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaSieforeCtaRegimen(struct soap *soap, ns2__RespuestaSieforeCtaRegimen *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaSieforeCtaRegimen);
	if (soap_out_PointerTons2__RespuestaSieforeCtaRegimen(soap, tag?tag:"ns2:RespuestaSieforeCtaRegimen", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaSieforeCtaRegimen ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaSieforeCtaRegimen(struct soap *soap, ns2__RespuestaSieforeCtaRegimen **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaSieforeCtaRegimen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParamResolucionTotalImssRI(struct soap *soap, ns2__ParamResolucionTotalImssRI *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParamResolucionTotalImssRI))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParamResolucionTotalImssRI(struct soap *soap, const char *tag, int id, ns2__ParamResolucionTotalImssRI *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParamResolucionTotalImssRI);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParamResolucionTotalImssRI ** SOAP_FMAC4 soap_in_PointerTons2__ParamResolucionTotalImssRI(struct soap *soap, const char *tag, ns2__ParamResolucionTotalImssRI **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParamResolucionTotalImssRI **)soap_malloc(soap, sizeof(ns2__ParamResolucionTotalImssRI *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParamResolucionTotalImssRI *)soap_instantiate_ns2__ParamResolucionTotalImssRI(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParamResolucionTotalImssRI ** p = (ns2__ParamResolucionTotalImssRI **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParamResolucionTotalImssRI, sizeof(ns2__ParamResolucionTotalImssRI), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParamResolucionTotalImssRI(struct soap *soap, ns2__ParamResolucionTotalImssRI *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParamResolucionTotalImssRI);
	if (soap_out_PointerTons2__ParamResolucionTotalImssRI(soap, tag?tag:"ns2:ParamResolucionTotalImssRI", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParamResolucionTotalImssRI ** SOAP_FMAC4 soap_get_PointerTons2__ParamResolucionTotalImssRI(struct soap *soap, ns2__ParamResolucionTotalImssRI **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParamResolucionTotalImssRI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParamAportacionesPosteriores(struct soap *soap, ns2__ParamAportacionesPosteriores *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParamAportacionesPosteriores))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParamAportacionesPosteriores(struct soap *soap, const char *tag, int id, ns2__ParamAportacionesPosteriores *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParamAportacionesPosteriores);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParamAportacionesPosteriores ** SOAP_FMAC4 soap_in_PointerTons2__ParamAportacionesPosteriores(struct soap *soap, const char *tag, ns2__ParamAportacionesPosteriores **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParamAportacionesPosteriores **)soap_malloc(soap, sizeof(ns2__ParamAportacionesPosteriores *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParamAportacionesPosteriores *)soap_instantiate_ns2__ParamAportacionesPosteriores(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParamAportacionesPosteriores ** p = (ns2__ParamAportacionesPosteriores **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParamAportacionesPosteriores, sizeof(ns2__ParamAportacionesPosteriores), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParamAportacionesPosteriores(struct soap *soap, ns2__ParamAportacionesPosteriores *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParamAportacionesPosteriores);
	if (soap_out_PointerTons2__ParamAportacionesPosteriores(soap, tag?tag:"ns2:ParamAportacionesPosteriores", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParamAportacionesPosteriores ** SOAP_FMAC4 soap_get_PointerTons2__ParamAportacionesPosteriores(struct soap *soap, ns2__ParamAportacionesPosteriores **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParamAportacionesPosteriores(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaAportacionesPosteriores(struct soap *soap, ns2__RespuestaAportacionesPosteriores *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaAportacionesPosteriores))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaAportacionesPosteriores(struct soap *soap, const char *tag, int id, ns2__RespuestaAportacionesPosteriores *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaAportacionesPosteriores);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaAportacionesPosteriores ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaAportacionesPosteriores(struct soap *soap, const char *tag, ns2__RespuestaAportacionesPosteriores **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaAportacionesPosteriores **)soap_malloc(soap, sizeof(ns2__RespuestaAportacionesPosteriores *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaAportacionesPosteriores *)soap_instantiate_ns2__RespuestaAportacionesPosteriores(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaAportacionesPosteriores ** p = (ns2__RespuestaAportacionesPosteriores **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaAportacionesPosteriores, sizeof(ns2__RespuestaAportacionesPosteriores), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaAportacionesPosteriores(struct soap *soap, ns2__RespuestaAportacionesPosteriores *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaAportacionesPosteriores);
	if (soap_out_PointerTons2__RespuestaAportacionesPosteriores(soap, tag?tag:"ns2:RespuestaAportacionesPosteriores", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaAportacionesPosteriores ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaAportacionesPosteriores(struct soap *soap, ns2__RespuestaAportacionesPosteriores **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaAportacionesPosteriores(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParametroSaldoPmg(struct soap *soap, ns2__ParametroSaldoPmg *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParametroSaldoPmg))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParametroSaldoPmg(struct soap *soap, const char *tag, int id, ns2__ParametroSaldoPmg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParametroSaldoPmg);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParametroSaldoPmg ** SOAP_FMAC4 soap_in_PointerTons2__ParametroSaldoPmg(struct soap *soap, const char *tag, ns2__ParametroSaldoPmg **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParametroSaldoPmg **)soap_malloc(soap, sizeof(ns2__ParametroSaldoPmg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParametroSaldoPmg *)soap_instantiate_ns2__ParametroSaldoPmg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParametroSaldoPmg ** p = (ns2__ParametroSaldoPmg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParametroSaldoPmg, sizeof(ns2__ParametroSaldoPmg), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParametroSaldoPmg(struct soap *soap, ns2__ParametroSaldoPmg *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParametroSaldoPmg);
	if (soap_out_PointerTons2__ParametroSaldoPmg(soap, tag?tag:"ns2:ParametroSaldoPmg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParametroSaldoPmg ** SOAP_FMAC4 soap_get_PointerTons2__ParametroSaldoPmg(struct soap *soap, ns2__ParametroSaldoPmg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParametroSaldoPmg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SaldoPorSubcuentaPmg(struct soap *soap, ns2__SaldoPorSubcuentaPmg *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SaldoPorSubcuentaPmg))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SaldoPorSubcuentaPmg(struct soap *soap, const char *tag, int id, ns2__SaldoPorSubcuentaPmg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SaldoPorSubcuentaPmg);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SaldoPorSubcuentaPmg ** SOAP_FMAC4 soap_in_PointerTons2__SaldoPorSubcuentaPmg(struct soap *soap, const char *tag, ns2__SaldoPorSubcuentaPmg **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SaldoPorSubcuentaPmg **)soap_malloc(soap, sizeof(ns2__SaldoPorSubcuentaPmg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SaldoPorSubcuentaPmg *)soap_instantiate_ns2__SaldoPorSubcuentaPmg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SaldoPorSubcuentaPmg ** p = (ns2__SaldoPorSubcuentaPmg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SaldoPorSubcuentaPmg, sizeof(ns2__SaldoPorSubcuentaPmg), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SaldoPorSubcuentaPmg(struct soap *soap, ns2__SaldoPorSubcuentaPmg *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SaldoPorSubcuentaPmg);
	if (soap_out_PointerTons2__SaldoPorSubcuentaPmg(soap, tag?tag:"ns2:SaldoPorSubcuentaPmg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SaldoPorSubcuentaPmg ** SOAP_FMAC4 soap_get_PointerTons2__SaldoPorSubcuentaPmg(struct soap *soap, ns2__SaldoPorSubcuentaPmg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SaldoPorSubcuentaPmg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParamResolucionTotalIssste(struct soap *soap, ns2__ParamResolucionTotalIssste *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParamResolucionTotalIssste))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParamResolucionTotalIssste(struct soap *soap, const char *tag, int id, ns2__ParamResolucionTotalIssste *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParamResolucionTotalIssste);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParamResolucionTotalIssste ** SOAP_FMAC4 soap_in_PointerTons2__ParamResolucionTotalIssste(struct soap *soap, const char *tag, ns2__ParamResolucionTotalIssste **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParamResolucionTotalIssste **)soap_malloc(soap, sizeof(ns2__ParamResolucionTotalIssste *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParamResolucionTotalIssste *)soap_instantiate_ns2__ParamResolucionTotalIssste(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParamResolucionTotalIssste ** p = (ns2__ParamResolucionTotalIssste **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParamResolucionTotalIssste, sizeof(ns2__ParamResolucionTotalIssste), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParamResolucionTotalIssste(struct soap *soap, ns2__ParamResolucionTotalIssste *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParamResolucionTotalIssste);
	if (soap_out_PointerTons2__ParamResolucionTotalIssste(soap, tag?tag:"ns2:ParamResolucionTotalIssste", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParamResolucionTotalIssste ** SOAP_FMAC4 soap_get_PointerTons2__ParamResolucionTotalIssste(struct soap *soap, ns2__ParamResolucionTotalIssste **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParamResolucionTotalIssste(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaResolucionTotalIssste(struct soap *soap, ns2__RespuestaResolucionTotalIssste *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaResolucionTotalIssste))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaResolucionTotalIssste(struct soap *soap, const char *tag, int id, ns2__RespuestaResolucionTotalIssste *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaResolucionTotalIssste);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaResolucionTotalIssste ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaResolucionTotalIssste(struct soap *soap, const char *tag, ns2__RespuestaResolucionTotalIssste **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaResolucionTotalIssste **)soap_malloc(soap, sizeof(ns2__RespuestaResolucionTotalIssste *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaResolucionTotalIssste *)soap_instantiate_ns2__RespuestaResolucionTotalIssste(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaResolucionTotalIssste ** p = (ns2__RespuestaResolucionTotalIssste **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaResolucionTotalIssste, sizeof(ns2__RespuestaResolucionTotalIssste), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaResolucionTotalIssste(struct soap *soap, ns2__RespuestaResolucionTotalIssste *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaResolucionTotalIssste);
	if (soap_out_PointerTons2__RespuestaResolucionTotalIssste(soap, tag?tag:"ns2:RespuestaResolucionTotalIssste", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaResolucionTotalIssste ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaResolucionTotalIssste(struct soap *soap, ns2__RespuestaResolucionTotalIssste **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaResolucionTotalIssste(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParamMovimientosCuentas(struct soap *soap, ns2__ParamMovimientosCuentas *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParamMovimientosCuentas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParamMovimientosCuentas(struct soap *soap, const char *tag, int id, ns2__ParamMovimientosCuentas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParamMovimientosCuentas);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParamMovimientosCuentas ** SOAP_FMAC4 soap_in_PointerTons2__ParamMovimientosCuentas(struct soap *soap, const char *tag, ns2__ParamMovimientosCuentas **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParamMovimientosCuentas **)soap_malloc(soap, sizeof(ns2__ParamMovimientosCuentas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParamMovimientosCuentas *)soap_instantiate_ns2__ParamMovimientosCuentas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParamMovimientosCuentas ** p = (ns2__ParamMovimientosCuentas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParamMovimientosCuentas, sizeof(ns2__ParamMovimientosCuentas), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParamMovimientosCuentas(struct soap *soap, ns2__ParamMovimientosCuentas *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParamMovimientosCuentas);
	if (soap_out_PointerTons2__ParamMovimientosCuentas(soap, tag?tag:"ns2:ParamMovimientosCuentas", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParamMovimientosCuentas ** SOAP_FMAC4 soap_get_PointerTons2__ParamMovimientosCuentas(struct soap *soap, ns2__ParamMovimientosCuentas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParamMovimientosCuentas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaMovimientosCuentas(struct soap *soap, ns2__RespuestaMovimientosCuentas *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaMovimientosCuentas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaMovimientosCuentas(struct soap *soap, const char *tag, int id, ns2__RespuestaMovimientosCuentas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaMovimientosCuentas);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaMovimientosCuentas ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaMovimientosCuentas(struct soap *soap, const char *tag, ns2__RespuestaMovimientosCuentas **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaMovimientosCuentas **)soap_malloc(soap, sizeof(ns2__RespuestaMovimientosCuentas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaMovimientosCuentas *)soap_instantiate_ns2__RespuestaMovimientosCuentas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaMovimientosCuentas ** p = (ns2__RespuestaMovimientosCuentas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaMovimientosCuentas, sizeof(ns2__RespuestaMovimientosCuentas), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaMovimientosCuentas(struct soap *soap, ns2__RespuestaMovimientosCuentas *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaMovimientosCuentas);
	if (soap_out_PointerTons2__RespuestaMovimientosCuentas(soap, tag?tag:"ns2:RespuestaMovimientosCuentas", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaMovimientosCuentas ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaMovimientosCuentas(struct soap *soap, ns2__RespuestaMovimientosCuentas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaMovimientosCuentas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParamOperacionPmgImss(struct soap *soap, ns2__ParamOperacionPmgImss *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParamOperacionPmgImss))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParamOperacionPmgImss(struct soap *soap, const char *tag, int id, ns2__ParamOperacionPmgImss *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParamOperacionPmgImss);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParamOperacionPmgImss ** SOAP_FMAC4 soap_in_PointerTons2__ParamOperacionPmgImss(struct soap *soap, const char *tag, ns2__ParamOperacionPmgImss **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParamOperacionPmgImss **)soap_malloc(soap, sizeof(ns2__ParamOperacionPmgImss *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParamOperacionPmgImss *)soap_instantiate_ns2__ParamOperacionPmgImss(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParamOperacionPmgImss ** p = (ns2__ParamOperacionPmgImss **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParamOperacionPmgImss, sizeof(ns2__ParamOperacionPmgImss), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParamOperacionPmgImss(struct soap *soap, ns2__ParamOperacionPmgImss *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParamOperacionPmgImss);
	if (soap_out_PointerTons2__ParamOperacionPmgImss(soap, tag?tag:"ns2:ParamOperacionPmgImss", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParamOperacionPmgImss ** SOAP_FMAC4 soap_get_PointerTons2__ParamOperacionPmgImss(struct soap *soap, ns2__ParamOperacionPmgImss **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParamOperacionPmgImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaCOperacionesPmgImss(struct soap *soap, ns2__RespuestaCOperacionesPmgImss *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaCOperacionesPmgImss(struct soap *soap, const char *tag, int id, ns2__RespuestaCOperacionesPmgImss *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaCOperacionesPmgImss ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaCOperacionesPmgImss(struct soap *soap, const char *tag, ns2__RespuestaCOperacionesPmgImss **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaCOperacionesPmgImss **)soap_malloc(soap, sizeof(ns2__RespuestaCOperacionesPmgImss *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaCOperacionesPmgImss *)soap_instantiate_ns2__RespuestaCOperacionesPmgImss(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaCOperacionesPmgImss ** p = (ns2__RespuestaCOperacionesPmgImss **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaCOperacionesPmgImss, sizeof(ns2__RespuestaCOperacionesPmgImss), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaCOperacionesPmgImss(struct soap *soap, ns2__RespuestaCOperacionesPmgImss *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaCOperacionesPmgImss);
	if (soap_out_PointerTons2__RespuestaCOperacionesPmgImss(soap, tag?tag:"ns2:RespuestaCOperacionesPmgImss", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaCOperacionesPmgImss ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaCOperacionesPmgImss(struct soap *soap, ns2__RespuestaCOperacionesPmgImss **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaCOperacionesPmgImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParamResolucionTotalImss(struct soap *soap, ns2__ParamResolucionTotalImss *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParamResolucionTotalImss))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParamResolucionTotalImss(struct soap *soap, const char *tag, int id, ns2__ParamResolucionTotalImss *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParamResolucionTotalImss);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParamResolucionTotalImss ** SOAP_FMAC4 soap_in_PointerTons2__ParamResolucionTotalImss(struct soap *soap, const char *tag, ns2__ParamResolucionTotalImss **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParamResolucionTotalImss **)soap_malloc(soap, sizeof(ns2__ParamResolucionTotalImss *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParamResolucionTotalImss *)soap_instantiate_ns2__ParamResolucionTotalImss(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParamResolucionTotalImss ** p = (ns2__ParamResolucionTotalImss **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParamResolucionTotalImss, sizeof(ns2__ParamResolucionTotalImss), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParamResolucionTotalImss(struct soap *soap, ns2__ParamResolucionTotalImss *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParamResolucionTotalImss);
	if (soap_out_PointerTons2__ParamResolucionTotalImss(soap, tag?tag:"ns2:ParamResolucionTotalImss", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParamResolucionTotalImss ** SOAP_FMAC4 soap_get_PointerTons2__ParamResolucionTotalImss(struct soap *soap, ns2__ParamResolucionTotalImss **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParamResolucionTotalImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaResolucionTotalImss(struct soap *soap, ns2__RespuestaResolucionTotalImss *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaResolucionTotalImss))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaResolucionTotalImss(struct soap *soap, const char *tag, int id, ns2__RespuestaResolucionTotalImss *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaResolucionTotalImss);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaResolucionTotalImss ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaResolucionTotalImss(struct soap *soap, const char *tag, ns2__RespuestaResolucionTotalImss **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaResolucionTotalImss **)soap_malloc(soap, sizeof(ns2__RespuestaResolucionTotalImss *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaResolucionTotalImss *)soap_instantiate_ns2__RespuestaResolucionTotalImss(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaResolucionTotalImss ** p = (ns2__RespuestaResolucionTotalImss **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaResolucionTotalImss, sizeof(ns2__RespuestaResolucionTotalImss), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaResolucionTotalImss(struct soap *soap, ns2__RespuestaResolucionTotalImss *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaResolucionTotalImss);
	if (soap_out_PointerTons2__RespuestaResolucionTotalImss(soap, tag?tag:"ns2:RespuestaResolucionTotalImss", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaResolucionTotalImss ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaResolucionTotalImss(struct soap *soap, ns2__RespuestaResolucionTotalImss **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaResolucionTotalImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaComplementoResolucion(struct soap *soap, ns2__RespuestaComplementoResolucion *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaComplementoResolucion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaComplementoResolucion(struct soap *soap, const char *tag, int id, ns2__RespuestaComplementoResolucion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaComplementoResolucion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaComplementoResolucion ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaComplementoResolucion(struct soap *soap, const char *tag, ns2__RespuestaComplementoResolucion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaComplementoResolucion **)soap_malloc(soap, sizeof(ns2__RespuestaComplementoResolucion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaComplementoResolucion *)soap_instantiate_ns2__RespuestaComplementoResolucion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaComplementoResolucion ** p = (ns2__RespuestaComplementoResolucion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaComplementoResolucion, sizeof(ns2__RespuestaComplementoResolucion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaComplementoResolucion(struct soap *soap, ns2__RespuestaComplementoResolucion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaComplementoResolucion);
	if (soap_out_PointerTons2__RespuestaComplementoResolucion(soap, tag?tag:"ns2:RespuestaComplementoResolucion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaComplementoResolucion ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaComplementoResolucion(struct soap *soap, ns2__RespuestaComplementoResolucion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaComplementoResolucion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaDatosResolucion(struct soap *soap, ns2__RespuestaDatosResolucion *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaDatosResolucion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaDatosResolucion(struct soap *soap, const char *tag, int id, ns2__RespuestaDatosResolucion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaDatosResolucion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaDatosResolucion ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaDatosResolucion(struct soap *soap, const char *tag, ns2__RespuestaDatosResolucion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaDatosResolucion **)soap_malloc(soap, sizeof(ns2__RespuestaDatosResolucion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaDatosResolucion *)soap_instantiate_ns2__RespuestaDatosResolucion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaDatosResolucion ** p = (ns2__RespuestaDatosResolucion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaDatosResolucion, sizeof(ns2__RespuestaDatosResolucion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaDatosResolucion(struct soap *soap, ns2__RespuestaDatosResolucion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaDatosResolucion);
	if (soap_out_PointerTons2__RespuestaDatosResolucion(soap, tag?tag:"ns2:RespuestaDatosResolucion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaDatosResolucion ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaDatosResolucion(struct soap *soap, ns2__RespuestaDatosResolucion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaDatosResolucion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaMontosFechasDatamart(struct soap *soap, ns2__RespuestaMontosFechasDatamart *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaMontosFechasDatamart))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaMontosFechasDatamart(struct soap *soap, const char *tag, int id, ns2__RespuestaMontosFechasDatamart *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaMontosFechasDatamart);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaMontosFechasDatamart ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaMontosFechasDatamart(struct soap *soap, const char *tag, ns2__RespuestaMontosFechasDatamart **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaMontosFechasDatamart **)soap_malloc(soap, sizeof(ns2__RespuestaMontosFechasDatamart *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaMontosFechasDatamart *)soap_instantiate_ns2__RespuestaMontosFechasDatamart(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaMontosFechasDatamart ** p = (ns2__RespuestaMontosFechasDatamart **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaMontosFechasDatamart, sizeof(ns2__RespuestaMontosFechasDatamart), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaMontosFechasDatamart(struct soap *soap, ns2__RespuestaMontosFechasDatamart *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaMontosFechasDatamart);
	if (soap_out_PointerTons2__RespuestaMontosFechasDatamart(soap, tag?tag:"ns2:RespuestaMontosFechasDatamart", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaMontosFechasDatamart ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaMontosFechasDatamart(struct soap *soap, ns2__RespuestaMontosFechasDatamart **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaMontosFechasDatamart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParametroNssTipoRetiro(struct soap *soap, ns2__ParametroNssTipoRetiro *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParametroNssTipoRetiro))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParametroNssTipoRetiro(struct soap *soap, const char *tag, int id, ns2__ParametroNssTipoRetiro *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParametroNssTipoRetiro);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParametroNssTipoRetiro ** SOAP_FMAC4 soap_in_PointerTons2__ParametroNssTipoRetiro(struct soap *soap, const char *tag, ns2__ParametroNssTipoRetiro **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParametroNssTipoRetiro **)soap_malloc(soap, sizeof(ns2__ParametroNssTipoRetiro *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParametroNssTipoRetiro *)soap_instantiate_ns2__ParametroNssTipoRetiro(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParametroNssTipoRetiro ** p = (ns2__ParametroNssTipoRetiro **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParametroNssTipoRetiro, sizeof(ns2__ParametroNssTipoRetiro), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParametroNssTipoRetiro(struct soap *soap, ns2__ParametroNssTipoRetiro *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParametroNssTipoRetiro);
	if (soap_out_PointerTons2__ParametroNssTipoRetiro(soap, tag?tag:"ns2:ParametroNssTipoRetiro", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParametroNssTipoRetiro ** SOAP_FMAC4 soap_get_PointerTons2__ParametroNssTipoRetiro(struct soap *soap, ns2__ParametroNssTipoRetiro **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParametroNssTipoRetiro(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaValidarResolucionImss(struct soap *soap, ns2__RespuestaValidarResolucionImss *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaValidarResolucionImss))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaValidarResolucionImss(struct soap *soap, const char *tag, int id, ns2__RespuestaValidarResolucionImss *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaValidarResolucionImss);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaValidarResolucionImss ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaValidarResolucionImss(struct soap *soap, const char *tag, ns2__RespuestaValidarResolucionImss **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaValidarResolucionImss **)soap_malloc(soap, sizeof(ns2__RespuestaValidarResolucionImss *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaValidarResolucionImss *)soap_instantiate_ns2__RespuestaValidarResolucionImss(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaValidarResolucionImss ** p = (ns2__RespuestaValidarResolucionImss **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaValidarResolucionImss, sizeof(ns2__RespuestaValidarResolucionImss), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaValidarResolucionImss(struct soap *soap, ns2__RespuestaValidarResolucionImss *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaValidarResolucionImss);
	if (soap_out_PointerTons2__RespuestaValidarResolucionImss(soap, tag?tag:"ns2:RespuestaValidarResolucionImss", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaValidarResolucionImss ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaValidarResolucionImss(struct soap *soap, ns2__RespuestaValidarResolucionImss **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaValidarResolucionImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ConsultaSaldoDiarioRetiroParcial(struct soap *soap, ns2__ConsultaSaldoDiarioRetiroParcial *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ConsultaSaldoDiarioRetiroParcial(struct soap *soap, const char *tag, int id, ns2__ConsultaSaldoDiarioRetiroParcial *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ConsultaSaldoDiarioRetiroParcial ** SOAP_FMAC4 soap_in_PointerTons2__ConsultaSaldoDiarioRetiroParcial(struct soap *soap, const char *tag, ns2__ConsultaSaldoDiarioRetiroParcial **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ConsultaSaldoDiarioRetiroParcial **)soap_malloc(soap, sizeof(ns2__ConsultaSaldoDiarioRetiroParcial *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ConsultaSaldoDiarioRetiroParcial *)soap_instantiate_ns2__ConsultaSaldoDiarioRetiroParcial(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ConsultaSaldoDiarioRetiroParcial ** p = (ns2__ConsultaSaldoDiarioRetiroParcial **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ConsultaSaldoDiarioRetiroParcial, sizeof(ns2__ConsultaSaldoDiarioRetiroParcial), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ConsultaSaldoDiarioRetiroParcial(struct soap *soap, ns2__ConsultaSaldoDiarioRetiroParcial *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ConsultaSaldoDiarioRetiroParcial);
	if (soap_out_PointerTons2__ConsultaSaldoDiarioRetiroParcial(soap, tag?tag:"ns2:ConsultaSaldoDiarioRetiroParcial", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ConsultaSaldoDiarioRetiroParcial ** SOAP_FMAC4 soap_get_PointerTons2__ConsultaSaldoDiarioRetiroParcial(struct soap *soap, ns2__ConsultaSaldoDiarioRetiroParcial **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ConsultaSaldoDiarioRetiroParcial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SaldoDiarioRetiroParcial(struct soap *soap, ns2__SaldoDiarioRetiroParcial *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SaldoDiarioRetiroParcial))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SaldoDiarioRetiroParcial(struct soap *soap, const char *tag, int id, ns2__SaldoDiarioRetiroParcial *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SaldoDiarioRetiroParcial);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SaldoDiarioRetiroParcial ** SOAP_FMAC4 soap_in_PointerTons2__SaldoDiarioRetiroParcial(struct soap *soap, const char *tag, ns2__SaldoDiarioRetiroParcial **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SaldoDiarioRetiroParcial **)soap_malloc(soap, sizeof(ns2__SaldoDiarioRetiroParcial *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SaldoDiarioRetiroParcial *)soap_instantiate_ns2__SaldoDiarioRetiroParcial(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SaldoDiarioRetiroParcial ** p = (ns2__SaldoDiarioRetiroParcial **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SaldoDiarioRetiroParcial, sizeof(ns2__SaldoDiarioRetiroParcial), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SaldoDiarioRetiroParcial(struct soap *soap, ns2__SaldoDiarioRetiroParcial *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SaldoDiarioRetiroParcial);
	if (soap_out_PointerTons2__SaldoDiarioRetiroParcial(soap, tag?tag:"ns2:SaldoDiarioRetiroParcial", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SaldoDiarioRetiroParcial ** SOAP_FMAC4 soap_get_PointerTons2__SaldoDiarioRetiroParcial(struct soap *soap, ns2__SaldoDiarioRetiroParcial **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SaldoDiarioRetiroParcial(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ConvivenciaMarcas(struct soap *soap, ns2__ConvivenciaMarcas *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ConvivenciaMarcas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ConvivenciaMarcas(struct soap *soap, const char *tag, int id, ns2__ConvivenciaMarcas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ConvivenciaMarcas);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ConvivenciaMarcas ** SOAP_FMAC4 soap_in_PointerTons2__ConvivenciaMarcas(struct soap *soap, const char *tag, ns2__ConvivenciaMarcas **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ConvivenciaMarcas **)soap_malloc(soap, sizeof(ns2__ConvivenciaMarcas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ConvivenciaMarcas *)soap_instantiate_ns2__ConvivenciaMarcas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ConvivenciaMarcas ** p = (ns2__ConvivenciaMarcas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ConvivenciaMarcas, sizeof(ns2__ConvivenciaMarcas), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ConvivenciaMarcas(struct soap *soap, ns2__ConvivenciaMarcas *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ConvivenciaMarcas);
	if (soap_out_PointerTons2__ConvivenciaMarcas(soap, tag?tag:"ns2:ConvivenciaMarcas", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ConvivenciaMarcas ** SOAP_FMAC4 soap_get_PointerTons2__ConvivenciaMarcas(struct soap *soap, ns2__ConvivenciaMarcas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ConvivenciaMarcas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespuestaConvivenciaMarca(struct soap *soap, ns2__RespuestaConvivenciaMarca *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespuestaConvivenciaMarca))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespuestaConvivenciaMarca(struct soap *soap, const char *tag, int id, ns2__RespuestaConvivenciaMarca *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespuestaConvivenciaMarca);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespuestaConvivenciaMarca ** SOAP_FMAC4 soap_in_PointerTons2__RespuestaConvivenciaMarca(struct soap *soap, const char *tag, ns2__RespuestaConvivenciaMarca **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespuestaConvivenciaMarca **)soap_malloc(soap, sizeof(ns2__RespuestaConvivenciaMarca *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespuestaConvivenciaMarca *)soap_instantiate_ns2__RespuestaConvivenciaMarca(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespuestaConvivenciaMarca ** p = (ns2__RespuestaConvivenciaMarca **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespuestaConvivenciaMarca, sizeof(ns2__RespuestaConvivenciaMarca), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespuestaConvivenciaMarca(struct soap *soap, ns2__RespuestaConvivenciaMarca *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespuestaConvivenciaMarca);
	if (soap_out_PointerTons2__RespuestaConvivenciaMarca(soap, tag?tag:"ns2:RespuestaConvivenciaMarca", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespuestaConvivenciaMarca ** SOAP_FMAC4 soap_get_PointerTons2__RespuestaConvivenciaMarca(struct soap *soap, ns2__RespuestaConvivenciaMarca **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespuestaConvivenciaMarca(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FoliadorServicio(struct soap *soap, ns2__FoliadorServicio *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FoliadorServicio))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FoliadorServicio(struct soap *soap, const char *tag, int id, ns2__FoliadorServicio *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FoliadorServicio);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FoliadorServicio ** SOAP_FMAC4 soap_in_PointerTons2__FoliadorServicio(struct soap *soap, const char *tag, ns2__FoliadorServicio **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FoliadorServicio **)soap_malloc(soap, sizeof(ns2__FoliadorServicio *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FoliadorServicio *)soap_instantiate_ns2__FoliadorServicio(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__FoliadorServicio ** p = (ns2__FoliadorServicio **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FoliadorServicio, sizeof(ns2__FoliadorServicio), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FoliadorServicio(struct soap *soap, ns2__FoliadorServicio *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FoliadorServicio);
	if (soap_out_PointerTons2__FoliadorServicio(soap, tag?tag:"ns2:FoliadorServicio", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FoliadorServicio ** SOAP_FMAC4 soap_get_PointerTons2__FoliadorServicio(struct soap *soap, ns2__FoliadorServicio **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FoliadorServicio(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FolioServicio(struct soap *soap, ns2__FolioServicio *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FolioServicio))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FolioServicio(struct soap *soap, const char *tag, int id, ns2__FolioServicio *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FolioServicio);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FolioServicio ** SOAP_FMAC4 soap_in_PointerTons2__FolioServicio(struct soap *soap, const char *tag, ns2__FolioServicio **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FolioServicio **)soap_malloc(soap, sizeof(ns2__FolioServicio *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FolioServicio *)soap_instantiate_ns2__FolioServicio(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__FolioServicio ** p = (ns2__FolioServicio **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FolioServicio, sizeof(ns2__FolioServicio), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FolioServicio(struct soap *soap, ns2__FolioServicio *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FolioServicio);
	if (soap_out_PointerTons2__FolioServicio(soap, tag?tag:"ns2:FolioServicio", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FolioServicio ** SOAP_FMAC4 soap_get_PointerTons2__FolioServicio(struct soap *soap, ns2__FolioServicio **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FolioServicio(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParametroNss(struct soap *soap, ns2__ParametroNss *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParametroNss))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParametroNss(struct soap *soap, const char *tag, int id, ns2__ParametroNss *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParametroNss);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParametroNss ** SOAP_FMAC4 soap_in_PointerTons2__ParametroNss(struct soap *soap, const char *tag, ns2__ParametroNss **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParametroNss **)soap_malloc(soap, sizeof(ns2__ParametroNss *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParametroNss *)soap_instantiate_ns2__ParametroNss(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParametroNss ** p = (ns2__ParametroNss **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParametroNss, sizeof(ns2__ParametroNss), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParametroNss(struct soap *soap, ns2__ParametroNss *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParametroNss);
	if (soap_out_PointerTons2__ParametroNss(soap, tag?tag:"ns2:ParametroNss", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParametroNss ** SOAP_FMAC4 soap_get_PointerTons2__ParametroNss(struct soap *soap, ns2__ParametroNss **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParametroNss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SaldoPorSubcuenta(struct soap *soap, ns2__SaldoPorSubcuenta *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SaldoPorSubcuenta))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SaldoPorSubcuenta(struct soap *soap, const char *tag, int id, ns2__SaldoPorSubcuenta *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SaldoPorSubcuenta);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SaldoPorSubcuenta ** SOAP_FMAC4 soap_in_PointerTons2__SaldoPorSubcuenta(struct soap *soap, const char *tag, ns2__SaldoPorSubcuenta **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SaldoPorSubcuenta **)soap_malloc(soap, sizeof(ns2__SaldoPorSubcuenta *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SaldoPorSubcuenta *)soap_instantiate_ns2__SaldoPorSubcuenta(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SaldoPorSubcuenta ** p = (ns2__SaldoPorSubcuenta **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SaldoPorSubcuenta, sizeof(ns2__SaldoPorSubcuenta), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SaldoPorSubcuenta(struct soap *soap, ns2__SaldoPorSubcuenta *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SaldoPorSubcuenta);
	if (soap_out_PointerTons2__SaldoPorSubcuenta(soap, tag?tag:"ns2:SaldoPorSubcuenta", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SaldoPorSubcuenta ** SOAP_FMAC4 soap_get_PointerTons2__SaldoPorSubcuenta(struct soap *soap, ns2__SaldoPorSubcuenta **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SaldoPorSubcuenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ParamConsultarAfiliado(struct soap *soap, ns2__ParamConsultarAfiliado *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ParamConsultarAfiliado))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ParamConsultarAfiliado(struct soap *soap, const char *tag, int id, ns2__ParamConsultarAfiliado *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ParamConsultarAfiliado);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ParamConsultarAfiliado ** SOAP_FMAC4 soap_in_PointerTons2__ParamConsultarAfiliado(struct soap *soap, const char *tag, ns2__ParamConsultarAfiliado **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ParamConsultarAfiliado **)soap_malloc(soap, sizeof(ns2__ParamConsultarAfiliado *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ParamConsultarAfiliado *)soap_instantiate_ns2__ParamConsultarAfiliado(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ParamConsultarAfiliado ** p = (ns2__ParamConsultarAfiliado **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ParamConsultarAfiliado, sizeof(ns2__ParamConsultarAfiliado), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ParamConsultarAfiliado(struct soap *soap, ns2__ParamConsultarAfiliado *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ParamConsultarAfiliado);
	if (soap_out_PointerTons2__ParamConsultarAfiliado(soap, tag?tag:"ns2:ParamConsultarAfiliado", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ParamConsultarAfiliado ** SOAP_FMAC4 soap_get_PointerTons2__ParamConsultarAfiliado(struct soap *soap, ns2__ParamConsultarAfiliado **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ParamConsultarAfiliado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__RespConsultarAfiliado(struct soap *soap, ns2__RespConsultarAfiliado *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__RespConsultarAfiliado))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__RespConsultarAfiliado(struct soap *soap, const char *tag, int id, ns2__RespConsultarAfiliado *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__RespConsultarAfiliado);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__RespConsultarAfiliado ** SOAP_FMAC4 soap_in_PointerTons2__RespConsultarAfiliado(struct soap *soap, const char *tag, ns2__RespConsultarAfiliado **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__RespConsultarAfiliado **)soap_malloc(soap, sizeof(ns2__RespConsultarAfiliado *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__RespConsultarAfiliado *)soap_instantiate_ns2__RespConsultarAfiliado(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__RespConsultarAfiliado ** p = (ns2__RespConsultarAfiliado **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__RespConsultarAfiliado, sizeof(ns2__RespConsultarAfiliado), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__RespConsultarAfiliado(struct soap *soap, ns2__RespConsultarAfiliado *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__RespConsultarAfiliado);
	if (soap_out_PointerTons2__RespConsultarAfiliado(soap, tag?tag:"ns2:RespConsultarAfiliado", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__RespConsultarAfiliado ** SOAP_FMAC4 soap_get_PointerTons2__RespConsultarAfiliado(struct soap *soap, ns2__RespConsultarAfiliado **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__RespConsultarAfiliado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__DatosCtaSaldoVol(struct soap *soap, ns2__DatosCtaSaldoVol **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__DatosCtaSaldoVol))
		soap_serialize_PointerTons2__DatosCtaSaldoVol(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__DatosCtaSaldoVol(struct soap *soap, const char *tag, int id, ns2__DatosCtaSaldoVol **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__DatosCtaSaldoVol);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__DatosCtaSaldoVol(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__DatosCtaSaldoVol *** SOAP_FMAC4 soap_in_PointerToPointerTons2__DatosCtaSaldoVol(struct soap *soap, const char *tag, ns2__DatosCtaSaldoVol ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DatosCtaSaldoVol ***)soap_malloc(soap, sizeof(ns2__DatosCtaSaldoVol **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__DatosCtaSaldoVol(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__DatosCtaSaldoVol ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons2__DatosCtaSaldoVol, sizeof(ns2__DatosCtaSaldoVol *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__DatosCtaSaldoVol(struct soap *soap, ns2__DatosCtaSaldoVol **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons2__DatosCtaSaldoVol);
	if (soap_out_PointerToPointerTons2__DatosCtaSaldoVol(soap, tag?tag:"ns2:DatosCtaSaldoVol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DatosCtaSaldoVol *** SOAP_FMAC4 soap_get_PointerToPointerTons2__DatosCtaSaldoVol(struct soap *soap, ns2__DatosCtaSaldoVol ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__DatosCtaSaldoVol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DatosCtaSaldoVol(struct soap *soap, ns2__DatosCtaSaldoVol *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DatosCtaSaldoVol))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DatosCtaSaldoVol(struct soap *soap, const char *tag, int id, ns2__DatosCtaSaldoVol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DatosCtaSaldoVol);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DatosCtaSaldoVol ** SOAP_FMAC4 soap_in_PointerTons2__DatosCtaSaldoVol(struct soap *soap, const char *tag, ns2__DatosCtaSaldoVol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DatosCtaSaldoVol **)soap_malloc(soap, sizeof(ns2__DatosCtaSaldoVol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DatosCtaSaldoVol *)soap_instantiate_ns2__DatosCtaSaldoVol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DatosCtaSaldoVol ** p = (ns2__DatosCtaSaldoVol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DatosCtaSaldoVol, sizeof(ns2__DatosCtaSaldoVol), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DatosCtaSaldoVol(struct soap *soap, ns2__DatosCtaSaldoVol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DatosCtaSaldoVol);
	if (soap_out_PointerTons2__DatosCtaSaldoVol(soap, tag?tag:"ns2:DatosCtaSaldoVol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DatosCtaSaldoVol ** SOAP_FMAC4 soap_get_PointerTons2__DatosCtaSaldoVol(struct soap *soap, ns2__DatosCtaSaldoVol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DatosCtaSaldoVol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__SieforeCtaRegimen(struct soap *soap, ns2__SieforeCtaRegimen **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__SieforeCtaRegimen))
		soap_serialize_PointerTons2__SieforeCtaRegimen(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__SieforeCtaRegimen(struct soap *soap, const char *tag, int id, ns2__SieforeCtaRegimen **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__SieforeCtaRegimen);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__SieforeCtaRegimen(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__SieforeCtaRegimen *** SOAP_FMAC4 soap_in_PointerToPointerTons2__SieforeCtaRegimen(struct soap *soap, const char *tag, ns2__SieforeCtaRegimen ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SieforeCtaRegimen ***)soap_malloc(soap, sizeof(ns2__SieforeCtaRegimen **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__SieforeCtaRegimen(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__SieforeCtaRegimen ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons2__SieforeCtaRegimen, sizeof(ns2__SieforeCtaRegimen *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__SieforeCtaRegimen(struct soap *soap, ns2__SieforeCtaRegimen **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons2__SieforeCtaRegimen);
	if (soap_out_PointerToPointerTons2__SieforeCtaRegimen(soap, tag?tag:"ns2:SieforeCtaRegimen", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SieforeCtaRegimen *** SOAP_FMAC4 soap_get_PointerToPointerTons2__SieforeCtaRegimen(struct soap *soap, ns2__SieforeCtaRegimen ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__SieforeCtaRegimen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SieforeCtaRegimen(struct soap *soap, ns2__SieforeCtaRegimen *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SieforeCtaRegimen))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SieforeCtaRegimen(struct soap *soap, const char *tag, int id, ns2__SieforeCtaRegimen *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SieforeCtaRegimen);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SieforeCtaRegimen ** SOAP_FMAC4 soap_in_PointerTons2__SieforeCtaRegimen(struct soap *soap, const char *tag, ns2__SieforeCtaRegimen **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SieforeCtaRegimen **)soap_malloc(soap, sizeof(ns2__SieforeCtaRegimen *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SieforeCtaRegimen *)soap_instantiate_ns2__SieforeCtaRegimen(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SieforeCtaRegimen ** p = (ns2__SieforeCtaRegimen **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SieforeCtaRegimen, sizeof(ns2__SieforeCtaRegimen), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SieforeCtaRegimen(struct soap *soap, ns2__SieforeCtaRegimen *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SieforeCtaRegimen);
	if (soap_out_PointerTons2__SieforeCtaRegimen(soap, tag?tag:"ns2:SieforeCtaRegimen", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SieforeCtaRegimen ** SOAP_FMAC4 soap_get_PointerTons2__SieforeCtaRegimen(struct soap *soap, ns2__SieforeCtaRegimen **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SieforeCtaRegimen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons2__SaldoSubCuenta(struct soap *soap, ns2__SaldoSubCuenta **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons2__SaldoSubCuenta))
		soap_serialize_PointerTons2__SaldoSubCuenta(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons2__SaldoSubCuenta(struct soap *soap, const char *tag, int id, ns2__SaldoSubCuenta **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons2__SaldoSubCuenta);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons2__SaldoSubCuenta(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns2__SaldoSubCuenta *** SOAP_FMAC4 soap_in_PointerToPointerTons2__SaldoSubCuenta(struct soap *soap, const char *tag, ns2__SaldoSubCuenta ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SaldoSubCuenta ***)soap_malloc(soap, sizeof(ns2__SaldoSubCuenta **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons2__SaldoSubCuenta(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns2__SaldoSubCuenta ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons2__SaldoSubCuenta, sizeof(ns2__SaldoSubCuenta *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons2__SaldoSubCuenta(struct soap *soap, ns2__SaldoSubCuenta **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons2__SaldoSubCuenta);
	if (soap_out_PointerToPointerTons2__SaldoSubCuenta(soap, tag?tag:"ns2:SaldoSubCuenta", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SaldoSubCuenta *** SOAP_FMAC4 soap_get_PointerToPointerTons2__SaldoSubCuenta(struct soap *soap, ns2__SaldoSubCuenta ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons2__SaldoSubCuenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SaldoSubCuenta(struct soap *soap, ns2__SaldoSubCuenta *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SaldoSubCuenta))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SaldoSubCuenta(struct soap *soap, const char *tag, int id, ns2__SaldoSubCuenta *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SaldoSubCuenta);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SaldoSubCuenta ** SOAP_FMAC4 soap_in_PointerTons2__SaldoSubCuenta(struct soap *soap, const char *tag, ns2__SaldoSubCuenta **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SaldoSubCuenta **)soap_malloc(soap, sizeof(ns2__SaldoSubCuenta *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SaldoSubCuenta *)soap_instantiate_ns2__SaldoSubCuenta(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SaldoSubCuenta ** p = (ns2__SaldoSubCuenta **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SaldoSubCuenta, sizeof(ns2__SaldoSubCuenta), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SaldoSubCuenta(struct soap *soap, ns2__SaldoSubCuenta *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SaldoSubCuenta);
	if (soap_out_PointerTons2__SaldoSubCuenta(soap, tag?tag:"ns2:SaldoSubCuenta", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SaldoSubCuenta ** SOAP_FMAC4 soap_get_PointerTons2__SaldoSubCuenta(struct soap *soap, ns2__SaldoSubCuenta **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SaldoSubCuenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__NumMensualidad(struct soap *soap, ns2__NumMensualidad *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__NumMensualidad))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__NumMensualidad(struct soap *soap, const char *tag, int id, ns2__NumMensualidad *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__NumMensualidad);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__NumMensualidad ** SOAP_FMAC4 soap_in_PointerTons2__NumMensualidad(struct soap *soap, const char *tag, ns2__NumMensualidad **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__NumMensualidad **)soap_malloc(soap, sizeof(ns2__NumMensualidad *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__NumMensualidad *)soap_instantiate_ns2__NumMensualidad(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__NumMensualidad ** p = (ns2__NumMensualidad **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__NumMensualidad, sizeof(ns2__NumMensualidad), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__NumMensualidad(struct soap *soap, ns2__NumMensualidad *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__NumMensualidad);
	if (soap_out_PointerTons2__NumMensualidad(soap, tag?tag:"ns2:NumMensualidad", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__NumMensualidad ** SOAP_FMAC4 soap_get_PointerTons2__NumMensualidad(struct soap *soap, ns2__NumMensualidad **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__NumMensualidad(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__FechaLiquida(struct soap *soap, ns2__FechaLiquida *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__FechaLiquida))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__FechaLiquida(struct soap *soap, const char *tag, int id, ns2__FechaLiquida *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__FechaLiquida);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__FechaLiquida ** SOAP_FMAC4 soap_in_PointerTons2__FechaLiquida(struct soap *soap, const char *tag, ns2__FechaLiquida **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__FechaLiquida **)soap_malloc(soap, sizeof(ns2__FechaLiquida *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__FechaLiquida *)soap_instantiate_ns2__FechaLiquida(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__FechaLiquida ** p = (ns2__FechaLiquida **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__FechaLiquida, sizeof(ns2__FechaLiquida), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__FechaLiquida(struct soap *soap, ns2__FechaLiquida *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__FechaLiquida);
	if (soap_out_PointerTons2__FechaLiquida(soap, tag?tag:"ns2:FechaLiquida", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__FechaLiquida ** SOAP_FMAC4 soap_get_PointerTons2__FechaLiquida(struct soap *soap, ns2__FechaLiquida **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__FechaLiquida(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SaldoRecuperar(struct soap *soap, ns2__SaldoRecuperar *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SaldoRecuperar))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SaldoRecuperar(struct soap *soap, const char *tag, int id, ns2__SaldoRecuperar *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SaldoRecuperar);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SaldoRecuperar ** SOAP_FMAC4 soap_in_PointerTons2__SaldoRecuperar(struct soap *soap, const char *tag, ns2__SaldoRecuperar **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SaldoRecuperar **)soap_malloc(soap, sizeof(ns2__SaldoRecuperar *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SaldoRecuperar *)soap_instantiate_ns2__SaldoRecuperar(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SaldoRecuperar ** p = (ns2__SaldoRecuperar **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SaldoRecuperar, sizeof(ns2__SaldoRecuperar), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SaldoRecuperar(struct soap *soap, ns2__SaldoRecuperar *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SaldoRecuperar);
	if (soap_out_PointerTons2__SaldoRecuperar(soap, tag?tag:"ns2:SaldoRecuperar", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SaldoRecuperar ** SOAP_FMAC4 soap_get_PointerTons2__SaldoRecuperar(struct soap *soap, ns2__SaldoRecuperar **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SaldoRecuperar(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ConsultarSaldoVivienda(struct soap *soap, ns2__ConsultarSaldoVivienda *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ConsultarSaldoVivienda))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ConsultarSaldoVivienda(struct soap *soap, const char *tag, int id, ns2__ConsultarSaldoVivienda *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ConsultarSaldoVivienda);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ConsultarSaldoVivienda ** SOAP_FMAC4 soap_in_PointerTons2__ConsultarSaldoVivienda(struct soap *soap, const char *tag, ns2__ConsultarSaldoVivienda **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ConsultarSaldoVivienda **)soap_malloc(soap, sizeof(ns2__ConsultarSaldoVivienda *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ConsultarSaldoVivienda *)soap_instantiate_ns2__ConsultarSaldoVivienda(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ConsultarSaldoVivienda ** p = (ns2__ConsultarSaldoVivienda **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ConsultarSaldoVivienda, sizeof(ns2__ConsultarSaldoVivienda), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ConsultarSaldoVivienda(struct soap *soap, ns2__ConsultarSaldoVivienda *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ConsultarSaldoVivienda);
	if (soap_out_PointerTons2__ConsultarSaldoVivienda(soap, tag?tag:"ns2:ConsultarSaldoVivienda", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ConsultarSaldoVivienda ** SOAP_FMAC4 soap_get_PointerTons2__ConsultarSaldoVivienda(struct soap *soap, ns2__ConsultarSaldoVivienda **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ConsultarSaldoVivienda(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfDatosCtaSaldoVol(struct soap *soap, ArrayOfDatosCtaSaldoVol *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfDatosCtaSaldoVol(struct soap *soap, const char *tag, int id, ArrayOfDatosCtaSaldoVol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptrSaldovol, 1, type, SOAP_TYPE_ArrayOfDatosCtaSaldoVol);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfDatosCtaSaldoVol ** SOAP_FMAC4 soap_in_PointerToArrayOfDatosCtaSaldoVol(struct soap *soap, const char *tag, ArrayOfDatosCtaSaldoVol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfDatosCtaSaldoVol **)soap_malloc(soap, sizeof(ArrayOfDatosCtaSaldoVol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfDatosCtaSaldoVol *)soap_instantiate_ArrayOfDatosCtaSaldoVol(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfDatosCtaSaldoVol ** p = (ArrayOfDatosCtaSaldoVol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfDatosCtaSaldoVol, sizeof(ArrayOfDatosCtaSaldoVol), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfDatosCtaSaldoVol(struct soap *soap, ArrayOfDatosCtaSaldoVol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfDatosCtaSaldoVol);
	if (soap_out_PointerToArrayOfDatosCtaSaldoVol(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfDatosCtaSaldoVol ** SOAP_FMAC4 soap_get_PointerToArrayOfDatosCtaSaldoVol(struct soap *soap, ArrayOfDatosCtaSaldoVol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfDatosCtaSaldoVol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfSieforeCtaRegimen(struct soap *soap, ArrayOfSieforeCtaRegimen *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfSieforeCtaRegimen(struct soap *soap, const char *tag, int id, ArrayOfSieforeCtaRegimen *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptrSiefore, 1, type, SOAP_TYPE_ArrayOfSieforeCtaRegimen);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfSieforeCtaRegimen ** SOAP_FMAC4 soap_in_PointerToArrayOfSieforeCtaRegimen(struct soap *soap, const char *tag, ArrayOfSieforeCtaRegimen **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfSieforeCtaRegimen **)soap_malloc(soap, sizeof(ArrayOfSieforeCtaRegimen *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfSieforeCtaRegimen *)soap_instantiate_ArrayOfSieforeCtaRegimen(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfSieforeCtaRegimen ** p = (ArrayOfSieforeCtaRegimen **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfSieforeCtaRegimen, sizeof(ArrayOfSieforeCtaRegimen), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfSieforeCtaRegimen(struct soap *soap, ArrayOfSieforeCtaRegimen *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfSieforeCtaRegimen);
	if (soap_out_PointerToArrayOfSieforeCtaRegimen(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfSieforeCtaRegimen ** SOAP_FMAC4 soap_get_PointerToArrayOfSieforeCtaRegimen(struct soap *soap, ArrayOfSieforeCtaRegimen **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfSieforeCtaRegimen(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__AportacionesPosteriores(struct soap *soap, ns2__AportacionesPosteriores *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__AportacionesPosteriores))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__AportacionesPosteriores(struct soap *soap, const char *tag, int id, ns2__AportacionesPosteriores *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__AportacionesPosteriores);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__AportacionesPosteriores ** SOAP_FMAC4 soap_in_PointerTons2__AportacionesPosteriores(struct soap *soap, const char *tag, ns2__AportacionesPosteriores **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__AportacionesPosteriores **)soap_malloc(soap, sizeof(ns2__AportacionesPosteriores *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__AportacionesPosteriores *)soap_instantiate_ns2__AportacionesPosteriores(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__AportacionesPosteriores ** p = (ns2__AportacionesPosteriores **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__AportacionesPosteriores, sizeof(ns2__AportacionesPosteriores), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__AportacionesPosteriores(struct soap *soap, ns2__AportacionesPosteriores *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__AportacionesPosteriores);
	if (soap_out_PointerTons2__AportacionesPosteriores(soap, tag?tag:"ns2:AportacionesPosteriores", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__AportacionesPosteriores ** SOAP_FMAC4 soap_get_PointerTons2__AportacionesPosteriores(struct soap *soap, ns2__AportacionesPosteriores **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__AportacionesPosteriores(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ResolucionTotalIssste(struct soap *soap, ns2__ResolucionTotalIssste *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ResolucionTotalIssste))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ResolucionTotalIssste(struct soap *soap, const char *tag, int id, ns2__ResolucionTotalIssste *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ResolucionTotalIssste);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ResolucionTotalIssste ** SOAP_FMAC4 soap_in_PointerTons2__ResolucionTotalIssste(struct soap *soap, const char *tag, ns2__ResolucionTotalIssste **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ResolucionTotalIssste **)soap_malloc(soap, sizeof(ns2__ResolucionTotalIssste *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ResolucionTotalIssste *)soap_instantiate_ns2__ResolucionTotalIssste(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ResolucionTotalIssste ** p = (ns2__ResolucionTotalIssste **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ResolucionTotalIssste, sizeof(ns2__ResolucionTotalIssste), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ResolucionTotalIssste(struct soap *soap, ns2__ResolucionTotalIssste *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ResolucionTotalIssste);
	if (soap_out_PointerTons2__ResolucionTotalIssste(soap, tag?tag:"ns2:ResolucionTotalIssste", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ResolucionTotalIssste ** SOAP_FMAC4 soap_get_PointerTons2__ResolucionTotalIssste(struct soap *soap, ns2__ResolucionTotalIssste **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ResolucionTotalIssste(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MovimientosCuentas(struct soap *soap, ns2__MovimientosCuentas *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MovimientosCuentas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MovimientosCuentas(struct soap *soap, const char *tag, int id, ns2__MovimientosCuentas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MovimientosCuentas);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MovimientosCuentas ** SOAP_FMAC4 soap_in_PointerTons2__MovimientosCuentas(struct soap *soap, const char *tag, ns2__MovimientosCuentas **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MovimientosCuentas **)soap_malloc(soap, sizeof(ns2__MovimientosCuentas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MovimientosCuentas *)soap_instantiate_ns2__MovimientosCuentas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MovimientosCuentas ** p = (ns2__MovimientosCuentas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MovimientosCuentas, sizeof(ns2__MovimientosCuentas), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MovimientosCuentas(struct soap *soap, ns2__MovimientosCuentas *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MovimientosCuentas);
	if (soap_out_PointerTons2__MovimientosCuentas(soap, tag?tag:"ns2:MovimientosCuentas", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MovimientosCuentas ** SOAP_FMAC4 soap_get_PointerTons2__MovimientosCuentas(struct soap *soap, ns2__MovimientosCuentas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MovimientosCuentas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ResolucionOperacionPmg(struct soap *soap, ns2__ResolucionOperacionPmg *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ResolucionOperacionPmg))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ResolucionOperacionPmg(struct soap *soap, const char *tag, int id, ns2__ResolucionOperacionPmg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ResolucionOperacionPmg);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ResolucionOperacionPmg ** SOAP_FMAC4 soap_in_PointerTons2__ResolucionOperacionPmg(struct soap *soap, const char *tag, ns2__ResolucionOperacionPmg **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ResolucionOperacionPmg **)soap_malloc(soap, sizeof(ns2__ResolucionOperacionPmg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ResolucionOperacionPmg *)soap_instantiate_ns2__ResolucionOperacionPmg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ResolucionOperacionPmg ** p = (ns2__ResolucionOperacionPmg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ResolucionOperacionPmg, sizeof(ns2__ResolucionOperacionPmg), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ResolucionOperacionPmg(struct soap *soap, ns2__ResolucionOperacionPmg *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ResolucionOperacionPmg);
	if (soap_out_PointerTons2__ResolucionOperacionPmg(soap, tag?tag:"ns2:ResolucionOperacionPmg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ResolucionOperacionPmg ** SOAP_FMAC4 soap_get_PointerTons2__ResolucionOperacionPmg(struct soap *soap, ns2__ResolucionOperacionPmg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ResolucionOperacionPmg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ResolucionTotalImss(struct soap *soap, ns2__ResolucionTotalImss *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ResolucionTotalImss))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ResolucionTotalImss(struct soap *soap, const char *tag, int id, ns2__ResolucionTotalImss *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ResolucionTotalImss);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ResolucionTotalImss ** SOAP_FMAC4 soap_in_PointerTons2__ResolucionTotalImss(struct soap *soap, const char *tag, ns2__ResolucionTotalImss **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ResolucionTotalImss **)soap_malloc(soap, sizeof(ns2__ResolucionTotalImss *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ResolucionTotalImss *)soap_instantiate_ns2__ResolucionTotalImss(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ResolucionTotalImss ** p = (ns2__ResolucionTotalImss **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ResolucionTotalImss, sizeof(ns2__ResolucionTotalImss), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ResolucionTotalImss(struct soap *soap, ns2__ResolucionTotalImss *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ResolucionTotalImss);
	if (soap_out_PointerTons2__ResolucionTotalImss(soap, tag?tag:"ns2:ResolucionTotalImss", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ResolucionTotalImss ** SOAP_FMAC4 soap_get_PointerTons2__ResolucionTotalImss(struct soap *soap, ns2__ResolucionTotalImss **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ResolucionTotalImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ComplementoResolucion(struct soap *soap, ns2__ComplementoResolucion *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ComplementoResolucion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ComplementoResolucion(struct soap *soap, const char *tag, int id, ns2__ComplementoResolucion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ComplementoResolucion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ComplementoResolucion ** SOAP_FMAC4 soap_in_PointerTons2__ComplementoResolucion(struct soap *soap, const char *tag, ns2__ComplementoResolucion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ComplementoResolucion **)soap_malloc(soap, sizeof(ns2__ComplementoResolucion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ComplementoResolucion *)soap_instantiate_ns2__ComplementoResolucion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ComplementoResolucion ** p = (ns2__ComplementoResolucion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ComplementoResolucion, sizeof(ns2__ComplementoResolucion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ComplementoResolucion(struct soap *soap, ns2__ComplementoResolucion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ComplementoResolucion);
	if (soap_out_PointerTons2__ComplementoResolucion(soap, tag?tag:"ns2:ComplementoResolucion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ComplementoResolucion ** SOAP_FMAC4 soap_get_PointerTons2__ComplementoResolucion(struct soap *soap, ns2__ComplementoResolucion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ComplementoResolucion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__DatosResolucion(struct soap *soap, ns2__DatosResolucion *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__DatosResolucion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__DatosResolucion(struct soap *soap, const char *tag, int id, ns2__DatosResolucion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__DatosResolucion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__DatosResolucion ** SOAP_FMAC4 soap_in_PointerTons2__DatosResolucion(struct soap *soap, const char *tag, ns2__DatosResolucion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__DatosResolucion **)soap_malloc(soap, sizeof(ns2__DatosResolucion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__DatosResolucion *)soap_instantiate_ns2__DatosResolucion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__DatosResolucion ** p = (ns2__DatosResolucion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__DatosResolucion, sizeof(ns2__DatosResolucion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__DatosResolucion(struct soap *soap, ns2__DatosResolucion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__DatosResolucion);
	if (soap_out_PointerTons2__DatosResolucion(soap, tag?tag:"ns2:DatosResolucion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__DatosResolucion ** SOAP_FMAC4 soap_get_PointerTons2__DatosResolucion(struct soap *soap, ns2__DatosResolucion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__DatosResolucion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__MontosFechasDatamart(struct soap *soap, ns2__MontosFechasDatamart *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__MontosFechasDatamart))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__MontosFechasDatamart(struct soap *soap, const char *tag, int id, ns2__MontosFechasDatamart *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__MontosFechasDatamart);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__MontosFechasDatamart ** SOAP_FMAC4 soap_in_PointerTons2__MontosFechasDatamart(struct soap *soap, const char *tag, ns2__MontosFechasDatamart **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__MontosFechasDatamart **)soap_malloc(soap, sizeof(ns2__MontosFechasDatamart *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__MontosFechasDatamart *)soap_instantiate_ns2__MontosFechasDatamart(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__MontosFechasDatamart ** p = (ns2__MontosFechasDatamart **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__MontosFechasDatamart, sizeof(ns2__MontosFechasDatamart), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__MontosFechasDatamart(struct soap *soap, ns2__MontosFechasDatamart *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__MontosFechasDatamart);
	if (soap_out_PointerTons2__MontosFechasDatamart(soap, tag?tag:"ns2:MontosFechasDatamart", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__MontosFechasDatamart ** SOAP_FMAC4 soap_get_PointerTons2__MontosFechasDatamart(struct soap *soap, ns2__MontosFechasDatamart **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__MontosFechasDatamart(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ValidarResolucionImss(struct soap *soap, ns2__ValidarResolucionImss *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ValidarResolucionImss))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ValidarResolucionImss(struct soap *soap, const char *tag, int id, ns2__ValidarResolucionImss *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ValidarResolucionImss);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ValidarResolucionImss ** SOAP_FMAC4 soap_in_PointerTons2__ValidarResolucionImss(struct soap *soap, const char *tag, ns2__ValidarResolucionImss **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ValidarResolucionImss **)soap_malloc(soap, sizeof(ns2__ValidarResolucionImss *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ValidarResolucionImss *)soap_instantiate_ns2__ValidarResolucionImss(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ValidarResolucionImss ** p = (ns2__ValidarResolucionImss **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ValidarResolucionImss, sizeof(ns2__ValidarResolucionImss), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ValidarResolucionImss(struct soap *soap, ns2__ValidarResolucionImss *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ValidarResolucionImss);
	if (soap_out_PointerTons2__ValidarResolucionImss(soap, tag?tag:"ns2:ValidarResolucionImss", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ValidarResolucionImss ** SOAP_FMAC4 soap_get_PointerTons2__ValidarResolucionImss(struct soap *soap, ns2__ValidarResolucionImss **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ValidarResolucionImss(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__TipoSolicitante(struct soap *soap, ns2__TipoSolicitante *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__TipoSolicitante))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__TipoSolicitante(struct soap *soap, const char *tag, int id, ns2__TipoSolicitante *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__TipoSolicitante);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__TipoSolicitante ** SOAP_FMAC4 soap_in_PointerTons2__TipoSolicitante(struct soap *soap, const char *tag, ns2__TipoSolicitante **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__TipoSolicitante **)soap_malloc(soap, sizeof(ns2__TipoSolicitante *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__TipoSolicitante *)soap_instantiate_ns2__TipoSolicitante(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__TipoSolicitante ** p = (ns2__TipoSolicitante **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__TipoSolicitante, sizeof(ns2__TipoSolicitante), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__TipoSolicitante(struct soap *soap, ns2__TipoSolicitante *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__TipoSolicitante);
	if (soap_out_PointerTons2__TipoSolicitante(soap, tag?tag:"ns2:TipoSolicitante", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__TipoSolicitante ** SOAP_FMAC4 soap_get_PointerTons2__TipoSolicitante(struct soap *soap, ns2__TipoSolicitante **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__TipoSolicitante(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__ValidaConvivenciaMarcas(struct soap *soap, ns2__ValidaConvivenciaMarcas *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__ValidaConvivenciaMarcas))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__ValidaConvivenciaMarcas(struct soap *soap, const char *tag, int id, ns2__ValidaConvivenciaMarcas *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__ValidaConvivenciaMarcas);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__ValidaConvivenciaMarcas ** SOAP_FMAC4 soap_in_PointerTons2__ValidaConvivenciaMarcas(struct soap *soap, const char *tag, ns2__ValidaConvivenciaMarcas **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__ValidaConvivenciaMarcas **)soap_malloc(soap, sizeof(ns2__ValidaConvivenciaMarcas *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__ValidaConvivenciaMarcas *)soap_instantiate_ns2__ValidaConvivenciaMarcas(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__ValidaConvivenciaMarcas ** p = (ns2__ValidaConvivenciaMarcas **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__ValidaConvivenciaMarcas, sizeof(ns2__ValidaConvivenciaMarcas), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__ValidaConvivenciaMarcas(struct soap *soap, ns2__ValidaConvivenciaMarcas *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__ValidaConvivenciaMarcas);
	if (soap_out_PointerTons2__ValidaConvivenciaMarcas(soap, tag?tag:"ns2:ValidaConvivenciaMarcas", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__ValidaConvivenciaMarcas ** SOAP_FMAC4 soap_get_PointerTons2__ValidaConvivenciaMarcas(struct soap *soap, ns2__ValidaConvivenciaMarcas **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__ValidaConvivenciaMarcas(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__SaldosCuentasPmg(struct soap *soap, ns2__SaldosCuentasPmg *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__SaldosCuentasPmg))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__SaldosCuentasPmg(struct soap *soap, const char *tag, int id, ns2__SaldosCuentasPmg *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__SaldosCuentasPmg);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__SaldosCuentasPmg ** SOAP_FMAC4 soap_in_PointerTons2__SaldosCuentasPmg(struct soap *soap, const char *tag, ns2__SaldosCuentasPmg **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__SaldosCuentasPmg **)soap_malloc(soap, sizeof(ns2__SaldosCuentasPmg *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__SaldosCuentasPmg *)soap_instantiate_ns2__SaldosCuentasPmg(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__SaldosCuentasPmg ** p = (ns2__SaldosCuentasPmg **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__SaldosCuentasPmg, sizeof(ns2__SaldosCuentasPmg), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__SaldosCuentasPmg(struct soap *soap, ns2__SaldosCuentasPmg *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__SaldosCuentasPmg);
	if (soap_out_PointerTons2__SaldosCuentasPmg(soap, tag?tag:"ns2:SaldosCuentasPmg", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__SaldosCuentasPmg ** SOAP_FMAC4 soap_get_PointerTons2__SaldosCuentasPmg(struct soap *soap, ns2__SaldosCuentasPmg **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__SaldosCuentasPmg(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfSaldoSubCuenta(struct soap *soap, ArrayOfSaldoSubCuenta *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfSaldoSubCuenta(struct soap *soap, const char *tag, int id, ArrayOfSaldoSubCuenta *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptrSaldo, 1, type, SOAP_TYPE_ArrayOfSaldoSubCuenta);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfSaldoSubCuenta ** SOAP_FMAC4 soap_in_PointerToArrayOfSaldoSubCuenta(struct soap *soap, const char *tag, ArrayOfSaldoSubCuenta **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfSaldoSubCuenta **)soap_malloc(soap, sizeof(ArrayOfSaldoSubCuenta *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfSaldoSubCuenta *)soap_instantiate_ArrayOfSaldoSubCuenta(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ArrayOfSaldoSubCuenta ** p = (ArrayOfSaldoSubCuenta **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfSaldoSubCuenta, sizeof(ArrayOfSaldoSubCuenta), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfSaldoSubCuenta(struct soap *soap, ArrayOfSaldoSubCuenta *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfSaldoSubCuenta);
	if (soap_out_PointerToArrayOfSaldoSubCuenta(soap, tag?tag:"SOAP-ENC:Array", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ArrayOfSaldoSubCuenta ** SOAP_FMAC4 soap_get_PointerToArrayOfSaldoSubCuenta(struct soap *soap, ArrayOfSaldoSubCuenta **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfSaldoSubCuenta(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__EstadoProceso(struct soap *soap, ns2__EstadoProceso *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__EstadoProceso))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__EstadoProceso(struct soap *soap, const char *tag, int id, ns2__EstadoProceso *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__EstadoProceso);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__EstadoProceso ** SOAP_FMAC4 soap_in_PointerTons2__EstadoProceso(struct soap *soap, const char *tag, ns2__EstadoProceso **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__EstadoProceso **)soap_malloc(soap, sizeof(ns2__EstadoProceso *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__EstadoProceso *)soap_instantiate_ns2__EstadoProceso(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__EstadoProceso ** p = (ns2__EstadoProceso **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__EstadoProceso, sizeof(ns2__EstadoProceso), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__EstadoProceso(struct soap *soap, ns2__EstadoProceso *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__EstadoProceso);
	if (soap_out_PointerTons2__EstadoProceso(soap, tag?tag:"ns2:EstadoProceso", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__EstadoProceso ** SOAP_FMAC4 soap_get_PointerTons2__EstadoProceso(struct soap *soap, ns2__EstadoProceso **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__EstadoProceso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons2__Afiliado(struct soap *soap, ns2__Afiliado *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns2__Afiliado))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons2__Afiliado(struct soap *soap, const char *tag, int id, ns2__Afiliado *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns2__Afiliado);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns2__Afiliado ** SOAP_FMAC4 soap_in_PointerTons2__Afiliado(struct soap *soap, const char *tag, ns2__Afiliado **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns2__Afiliado **)soap_malloc(soap, sizeof(ns2__Afiliado *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns2__Afiliado *)soap_instantiate_ns2__Afiliado(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns2__Afiliado ** p = (ns2__Afiliado **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns2__Afiliado, sizeof(ns2__Afiliado), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons2__Afiliado(struct soap *soap, ns2__Afiliado *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons2__Afiliado);
	if (soap_out_PointerTons2__Afiliado(soap, tag?tag:"ns2:Afiliado", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns2__Afiliado ** SOAP_FMAC4 soap_get_PointerTons2__Afiliado(struct soap *soap, ns2__Afiliado **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons2__Afiliado(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
